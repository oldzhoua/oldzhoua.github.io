<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java高级_注解]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E9%AB%98%E7%BA%A7-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java高级_注解@SafeVarargs 挺有意思的一个注解 @SafeVarargs 这是1.7 之后新加入的基本注解. 如例所示，当使用可变数量的参数的时候，而参数的类型又是泛型T的话，就会出现警告。 这个时候，就使用@SafeVarargs来去掉这个警告 @SafeVarargs注解只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。一个方法使用@SafeVarargs注解的前提是，开发人员必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题。 1234567public class User &#123; @SafeVarargs public static &lt;T&gt; T getData(T... ds) &#123; return ds.length &gt; 0 ? (T) ds[0] : null; &#125;&#125; 自定义注解创建1234567@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface MyNote &#123; String name() default "zhw";&#125; 使用自定义注解1234567891011121314151617@MyNote(name = "zhwzhw")class Util &#123;&#125;public class NoteTest &#123; public static void main(String[] args) &#123; test1(); &#125; public static void test1() &#123; //反射获取注解 MyNote myNote = Util.class.getAnnotation(MyNote.class); // 获取方法 String name = myNote.name(); System.out.println(name); &#125;&#125; 结果: zhwzhw 相信刚刚接触的人一定很茫然 那么接下来讲解一下其中的元注解 元注解 元注解 @Target@Retention@Inherited@Documented@Repeatable (java1.8 新增) 有这么五种 @Target @Target 表示这个注解能放在什么位置上 12345678910111213141516171819@Target(&#123; // 能修饰包 ElementType.PACKAGE, // 能修饰类、接口或枚举类型 ElementType.TYPE, ElementType.TYPE_USE, ElementType.TYPE_PARAMETER, // 能修饰构造器 ElementType.CONSTRUCTOR, // 能修饰方法 ElementType.METHOD, // 能修饰成员变量 ElementType.FIELD, // 能修饰局部变量 ElementType.LOCAL_VARIABLE, // 能修饰参数 ElementType.PARAMETER, // 能修饰注解 ElementType.ANNOTATION_TYPE&#125;) @Retention 表示生命周期 只能选择一个生命周期 下面是错误的写法,只是方便说明而已 1234567@Retention(&#123; // 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了 RetentionPolicy.CLASS, // 注解在运行起来之后依然存在，程序可以通过反射获取这些信息 RetentionPolicy.RUNTIME, // 注解只在源代码中存在，编译成class之后，就没了 RetentionPolicy.SOURCE&#125;) @Inherited 表示该类有继承性 @Documented 在用javadoc命令生成API文档后，该文档里会出现该注解说明 @Repeatable 当没有@Repeatable修饰的时候，注解在同一个位置，只能出现一次 1234567891011121314151617181920212223@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Names &#123; FileType[] value();&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@Repeatable(Names.class)public @interface FileType &#123; String value();&#125;@FileType( ".java" ) @FileType( ".html" ) @FileType( ".css" ) @FileType( ".js" ) public void work()&#123; &#125;]]></content>
      <categories>
        <category>java</category>
        <category>java高级_注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级_反射机制]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E9%AB%98%E7%BA%A7-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java高级_反射机制类对象获取 先创建对象类 123456789101112131415161718192021222324class User &#123; public String name; private String sex; static String str; static &#123; str = "已经初始化!"; System.out.println("初始化..." + str); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "User [name=" + name + ", sex=" + sex + "]"; &#125;&#125; 有三种方式获取 1234567891011121314public static void test1() throws Exception &#123; // 初始化类静态属性 Class c1 = Class.forName("zhw.base.User"); System.out.println(c1); // 不会初始化类静态属性 Class c2 = User.class; System.out.println(c2); // 初始化类静态属性 Class c3 = new User().getClass(); System.out.println(c3); &#125; 通过反射创建对象12345678public static void test2() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); &#125; 通过反射修改对象属性值 getField只能获取public属性,包括继承的属性 getDeclaredField可以获取本类所有属性 12345678910111213141516171819public static void test3() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); // 获取对象属性 // getField只能获取public属性,包括继承的属性 Field f1 = cci.getClass().getField("name"); // getDeclaredField可以获取本类所有属性 Field f2 = cci.getClass().getDeclaredField("sex"); f2.setAccessible(true); // 设置值 f1.set(cci, "zhw"); f2.set(cci, "man"); System.out.println(cci); &#125; 通过反射调用对象方法123456789101112131415public static void test4() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); // 反射获取对象方法 Method m = cci.getClass().getMethod("setName", String.class); // 调用方法 m.invoke(cci, "zhw"); System.out.println(cci.getName()); &#125;]]></content>
      <categories>
        <category>java</category>
        <category>java高级_反射机制</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_Lamda-Stream]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-Lamda-Stream%2F</url>
    <content type="text"><![CDATA[Java中级_Lamda-StreamLamda规则: 接口必须是函数式接口---@FunctionalInterface 接口里面只能够存在一个抽象方法 java8还有个特性就是如果你的接口中没有抽象方法，但有个默认(default)方法，它也是函数式接口 语法: - 简写模式: (参数列表）-&gt; 方法主体 -无参模式: () -&gt; 方法主体 - 非简写模式：（参数列表）-&gt; {方法主体;} Stream三步骤:创建流 - 中间操作 - 最终操作 创建流流的创建有两种方式。 如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。 如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流； 123456789101112131415161718192021public static void test1() &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); ls.add("zz"); ls.add("aa"); ls.add("bb"); System.out.println(ls); List&lt;String&gt; bs = Arrays.asList("bb","cc","dd"); System.out.println(bs); // 集合直接使用stream()方法创建流 Stream&lt;String&gt; stream = ls.stream(); bs.stream(); // 数组 // 使用Arrays工具类stream()方法创建 String[] js = &#123;"aa","cc","bb"&#125;; Stream&lt;String&gt; stream2 = Arrays.stream(js); // 使用Stream类of()方法创建 Stream&lt;String&gt; stream3 = Stream.of("aa","bb","cc"); &#125; 中间操作 filter (过滤) map (映射) sorted (排序) distinct (去重) limit / skip (限制) filter (过滤) 根据判断条件过滤元素 123List&lt;UserDO&gt; resultList = userList.stream() .filter(user -&gt; user.id != 0) .collect(Collectors.toList()); map (映射) 映射每个元素到对应的方法 123List&lt;String&gt; bs = Arrays.asList("bb","cc","dd","cc"); System.out.println("map=========="); bs.stream().map(i -&gt; i+"未知数").forEach(System.out::println); 结果: map= = = = = = =bb未知数cc未知数dd未知数cc未知数 sorted (排序) 按条件进行排序 123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1);System.out.println("sorted==========");ls.stream().sorted().forEach(System.out::println); 结果: sorted= = = = = = = = = =135 distinct (去重) 去除集合或者数组中重复得数据 12Stream&lt;String&gt; s3 = Stream.of("aa","bb","cc" ,"cc");s3.distinct().forEach(System.out::println); 结果: aabbcc limit/skip limit 返回 Stream 的前面 n 个元素； skip 则是扔掉前 n 个元素。 limit123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1);System.out.println("limit==========");ls.stream().limit(1).forEach(System.out::println); 结果: limit = = = = = = = = = =3 skip123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1); System.out.println("skip= = = = = = = = = =");ls.stream().skip(1).forEach(System.out::println); 结果 skip= = = = = = = = = =51 最终操作 匹配 anyMatch() - - 根据条件返回是否有匹配的结果 allMatch() – 只要有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回true。 noneMatch() – 只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。 组合 reduce() - -把元素组合起来 计数 count() max() min() 迭代 forEach() 汇总 collect() –将流中的元素汇总 匹配1boolean isFound = userList.stream() .anyMatch(user -&gt; Objects.equals(user.getId(), userId)); 组合123List&lt;Integer&gt; nums = Arrays.asList(1, 2, 5, 4); int result = nums.stream().reduce(10,(a, c) -&gt; a + c); System.out.println(result); 结果:22]]></content>
      <categories>
        <category>java</category>
        <category>java中级_lamda-stream</category>
      </categories>
      <tags>
        <tag>lamda</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_网络编程]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java中级_网络编程OSI与TCP/IP体系模型OSI体系结构 OSI体系结构 7.应用层 6.表示层 5.会话层 4.传输层 3.网络层 2.数据链路层 1.物理层 TCP/IP体系结构 TCP/IP体系结构 4.应用层(协议:Telnet,FTP,SMTP…) 3.传输层(TCP/UDP) 2.网际层IP 1.网络接口层 TCP是 Tranfer Control Protocol 的简称; 是一种面向连接的保证可靠传输的协议. UDP是 User Datagram Protocol 的简称 是一种无连接的协议. TCP/UDP比较：UDP： 每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。 UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。 TCP： 面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。 TCP传输数据大小没有限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。 TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。 TCP/UDP应用：TCP: 远程连接,文件传输… TCP传输没有UDP快 UDP: 音视频传输… Socket12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; try &#123; Socket s = new Socket("127.0.0.1", 9999); //打开字节流输出流 OutputStream os = s.getOutputStream(); //封装字节流-数据流 DataOutputStream dos = new DataOutputStream(os); //读取控制台数据 Scanner scanner = new Scanner(System.in); String data = scanner.next(); //发送数据到服务端 dos.writeUTF(data); os.close(); s.close();// // 启动发送信息线程// new SendThread(s).start();// // 启动接收信息线程// new RecieveThread(s).start(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; ServerSocket12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; try &#123; // 服务器端打开端口9999 ServerSocket ss = new ServerSocket(9999); // 在9999端口监听 System.out.println("正在监听9999"); Socket s = ss.accept(); System.out.println("请求连接:" + s); // 打开字节流输入流 InputStream is = s.getInputStream(); //封装字节流-数据流 DataInputStream dis = new DataInputStream(is); // 读取客户端发送过来的数据 String readUTF = dis.readUTF(); System.out.println("客户端:"+readUTF); is.close(); s.close(); ss.close();// // 启动发送信息线程// new SendThread(s).start();// // 启动接收信息线程// new RecieveThread(s).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 多线程交互 发送信息线程 1234567891011121314151617181920212223242526272829303132333435/** * * @ClassName: SendThread * @Description: 发送信息线程 * @author zhouhongwei * */public class SendThread extends Thread &#123; private Socket s; public SendThread(Socket s) &#123; this.s = s; &#125; public void run() &#123; try &#123; // 打开字节流输出流 OutputStream os = s.getOutputStream(); // 封装字节流-数据流 DataOutputStream dos = new DataOutputStream(os); while (true) &#123; // 读取控制台数据 Scanner scanner = new Scanner(System.in); String data = scanner.next(); // 发送数据到服务端 dos.writeUTF(data); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 接收信息线程 123456789101112131415161718192021222324252627282930313233/** * * @ClassName: RecieveThread * @Description: 接收信息线程 * @author zhouhongwei * */public class RecieveThread extends Thread &#123; private Socket s; public RecieveThread(Socket s) &#123; this.s = s; &#125; public void run() &#123; try &#123; // 打开字节流输入流 InputStream is = s.getInputStream(); // 封装字节流-数据流 DataInputStream dis = new DataInputStream(is); while (true) &#123; // 读取客户端发送过来的数据 String readUTF = dis.readUTF(); System.out.println(readUTF); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 服务器端 123456789101112131415161718public static void main(String[] args) &#123; try &#123; // 服务器端打开端口9999 ServerSocket ss = new ServerSocket(9999); // 在9999端口监听 System.out.println("正在监听9999"); Socket s = ss.accept(); // 启动发送信息线程 new SendThread(s).start(); // 启动接收信息线程 new RecieveThread(s).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 客户端 12345678910111213141516public static void main(String[] args) &#123; try &#123; Socket s = new Socket("127.0.0.1", 9999); // 启动发送信息线程 new SendThread(s).start(); // 启动接收信息线程 new RecieveThread(s).start(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 说一下,网络编程,有 NIO,也有Netty框架]]></content>
      <categories>
        <category>java</category>
        <category>java中级-网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_集合]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java中级_集合总框架 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类 Collection Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支 List List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。 List 有序,可重复 List的实现类有LinkedList, ArrayList, Vector, Stack。 List接口提供了一个特殊的迭代器，称为ListIterator，其允许元件插入和更换，并且除了该Iterator接口提供正常操作的双向访问。 提供了一种方法来获取从列表中的指定位置开始的列表迭代器。 ArrayList ArrayList擅长于随机访问。同时ArrayList是非同步的。 优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高 Vector Vector是线程安全的动态数组 优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低 LinkedList LinkedList不能随机访问,也是非同步的 优点: 底层数据结构是双向链表，查询慢，增删快。缺点: 线程不安全，效率高 ArrayList-LinkedList-异同点 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 Set Set是一个不允许有重复元素的集合,无序，Set最多有一个null元素。 虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 Set的实现类有HashSet和TreeSet,LinkHashSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 HashSet 没有重复元素的集合 是由HashMap实现的 不保证元素的顺序 是非同步的 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。 LinkedHashSet 底层是基于LinkedHashMap来实现的 有序，非同步。 根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序 当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 TreeSet 一个有序集合，其底层是基于TreeMap实现的，非线程安全 TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式 TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 HashSet、LinkedHashSet、TreeSet比较 Set接口Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。 Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。 HashSetHashSet有以下特点： 不能保证元素的排列顺序，顺序有可能发生变化。 不是同步的。 集合元素可以是null，但只能放入一个null。 当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。 注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 TreeSet类TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。 TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。 Map Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口 不能存在相同的key值，当然value值可以相同。 HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的， 是一个单链表结构 非线程安全 LinkHashMap LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序 双重链接列表 非线程安全 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能 但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 TreeMap TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点 排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 HashTable与HashMap的异同点 相同点： 都实现了Map、Cloneable、java.io.Serializable接口。 都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点： （1）历史原因：HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。 （2）同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。 （3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。 （4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。 (5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 HashMap、Hashtable、LinkedHashMap和TreeMap比较 Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 Hashtable 与 HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。 TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。 TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 Iterator 它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的 12345678910public interface Iterator&lt;E&gt; &#123; //判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 boolean hasNext(); //返回集合里下一个元素。 E next(); //删除集合里上一次next方法返回的元素。 default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125;&#125; 操作一下Iterator的这三个方法 123456789101112131415public static void Test1() &#123; List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String t = it.next(); if ("bbb".equals(t)) &#123; it.remove(); &#125; &#125; System.out.println("After iterate : " + a);&#125; 结果为: Before iterate : [aaa, bbb, ccc]After iterate : [aaa, ccc] ListIterator 针对List集合 12345678910111213141516171819202122232425public static void Test2() &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) &#123; System.out.println("it.next() : " +it.next() + " ,前位置: " + it.previousIndex() + ",后位置: " + it.nextIndex()); &#125; while (it.hasPrevious()) &#123; System.out.println("it.previous() : "+it.previous()); &#125; it = a.listIterator(1); while (it.hasNext()) &#123; String t = it.next(); System.out.println("t:" + t); if ("ccc".equals(t)) &#123; it.set("nnn"); &#125; else &#123; it.add("kkk"); &#125; &#125; System.out.println("After iterate : " + a);&#125; 结果: Before iterate : [aaa, bbb, ccc]it.next() : aaa ,前位置: 0,后位置: 1it.next() : bbb ,前位置: 1,后位置: 2it.next() : ccc ,前位置: 2,后位置: 3it.previous() : cccit.previous() : bbbit.previous() : aaat:bbbt:cccAfter iterate : [aaa, bbb, kkk, nnn] Enumeration 作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。只提供了遍历Vector和HashTable类型集合元素的功能，不支持元素的移除操作 用法和Iterator类似,该接口有2个方法 1234boolean hasMoreElements() 测试此枚举是否包含更多元素。 E nextElement() 如果此枚举对象至少有一个要提供的元素，则返回此枚举的下一个元素. 操作Enumeration方法 123456789101112public static void Test3() &#123; Vector&lt;String&gt; v = new Vector&lt;String&gt;(); v.addElement("Lisa"); v.addElement("Billy"); v.addElement("Mr Brown"); System.out.println("Enumeration前"+v); Enumeration&lt;String&gt; e = v.elements();//返回Enumeration对象 while(e.hasMoreElements())&#123; String value = (String)e.nextElement();//调用nextElement方法获得元素 System.out.println(value); &#125; &#125; 结果: Enumeration前[Lisa, Billy, Mr Brown]LisaBillyMr Brown 工具类Collections 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。]]></content>
      <categories>
        <category>java</category>
        <category>java中级_集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Java中级1.异常1.分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 123456789101112131415异常的体系结构 * java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。 * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked)不会生成字节码文件 * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException//空指针异常 * |-----ArrayIndexOutOfBoundsException//数组角标越界 * |-----ClassCastException//类型转化异常 * |-----NumberFormatException//编码格式异常 * |-----InputMismatchException//输入不匹配 * |-----ArithmeticException//算术异常 2.处理异常方式 throws try-catch-finally finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 3.自定义异常12345678910public class MyException extends Exception&#123; private static final long serialVersionUID = 1L; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 2.JDBC1.定义 JDBC的全称是java数据库链接（Java Data Base Connect），它是用于执行SQL语句的java代码，应用程序可以通过JDBC链接到数据库，并使用SQL语句来完成对数据库中数据的新增、查询、删除和更新等操作 PreparedStatement的优点-防止SQL注入式攻击 PreparedStatement有预编译机制，性能比Statement更快 PreparedStatement 使用参数设置，可读性好，不易犯错 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Connection c = null; Statement s = null; try &#123; // 初始化驱动 Class.forName("com.mysql.jdbc.Driver"); // 建立与数据库的Connection连接 c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/a?characterEncoding=UTF-8", "root", "admin"); // 创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql); // SQL语句 String sql = "insert into cc values(?,?)"; ps.setString(1, "aaa"); ps.setString(1, "bbb"); // 执行SQL ps.execute(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯 // 先关闭PreparedStatement if (ps != null) try &#123; ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 后关闭Connection if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 3.I/O 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 所有的IO操作都在java.io包之中进行定义，而且整个java.io包实际上就是五个类和一个接口：（1）五个类：File、InputStream、OutputStream、Reader、Wirter；（2）一个接口：Serializable。 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 1.File 没啥好补充的 2.字节流与字符流 （1）字节操作流：OutputStream、InputStream；（2）字符操作流：Writer、Reader。 字节流 OutputStream和InputStream是字节流的两个顶层父类。让他们提供了输出流类和输入流类通用API，字节流一般用于读写二进制数据，如图像和声音数据。 OutputStream12345678910111213141516171819202122232425public static void Test2() throws IOException &#123; System.out.println("开始创建文件..."); // 定义文件路径 File file = new File("D:" + File.separator + "java" + File.separator + "test" + File.separator + UUID.randomUUID().toString() + ".txt"); // 判断路径存在? if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; // 文件存在? if (file.exists()) &#123; // 文件存在 file.delete(); // 删除文件 &#125; else &#123; // 文件不存在 file.createNewFile(); // 创建新文件 &#125; // 实例化输出 FileOutputStream fos = new FileOutputStream(file); String data = "哈哈哈哈哈哈哈哈哈"; System.out.println("开始生成数据源..." + file.getAbsolutePath()); // 输出数据 转化为字节数组输出 fos.write(data.getBytes()); // 关闭资源 fos.close(); System.out.println("输出流演示完成!"); &#125; InputStream字符流字符输入流writer]]></content>
      <categories>
        <category>java</category>
        <category>java中级</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
        <tag>JDBC</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java基础一.八种基本数据类型byte 8位 默认值为0 short 16位 默认值0 int 32位 默认值0 long 64位 默认值0L float 32位 默认值 0.0F double 64位 默认值0.0D char 16位 默认值 空 boolean 8位 默认值 false 二.String-字符串1.String 字符串不变; 它们的值在创建后不能被更改。 字符串缓冲区(StringBuffer,StringBuilder)支持可变字符串。 因为String对象是不可变的，它们可以被共享 传递null参数到此类中的构造函数或方法将导致抛出NullPointerException 。 1234 String str = "abc";// 相当于 char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data); compareTo 12public int compareTo(String anotherString)//按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值 isEmpty() 12public boolean isEmpty()//true如果，只有 length()是 0 。 切割字符串 split() 12public String[] split(String regex)//该方法的工作原理是通过使用给定表达式和限制参数为零调用双参数split方法。 因此，尾随的空字符串不会包含在结果数组中。 substring() 12public String substring(int beginIndex)//返回一个字符串，该字符串是此字符串的子字符串 charAt() 12public char charAt(int index)//返回char指定索引处的值。 指数范围为0至length() - 1 。 该序列的第一个char值在索引0 ，下一个索引为1 ，依此类推，与数组索引一样。 2.StringBuffer 一个可变的字符序列 线程不安全 在可能的情况下，建议使用这个类别优先于StringBuilder ，因为它在大多数实现中将更快。 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 3.StringBuilder 可变的字符序列 线程安全 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 三.位运算 与（&amp;）、非（~）、或（|）、异或（^） 1.与 &amp; 两个操作数中位都为1，结果才为1，否则结果为0 2.非 ~ 如果位为0，结果是1，如果位为1，结果是0 3.或 | 两个位只要有一个为1，那么结果就是1，否则就为0 4.异或 ^ 两个操作数的位中，相同则结果为0，不同则结果为1 5.十进制-二进制 二进制: 0 1 1 1 1 1 1 1 1 1 二进制 128 64 32 16 8 4 2 1 十进制 十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。 6.十进制-八进制 八进制：它的基数是8，总共有8个数字符号(0，1，2，3，4，5，6，7)， 十进制整数转换成八进制采用“除8倒取余”，十进制小数转换成二进制小数采用“乘8取整”。 7.十进制-十六进制 十六进制：它的基数是16，总共有16个数字符号(0，1，2，3，4，5，6，7，8，9， ​ A[表示10]，B[表示11]，C[表示12]，D[表示13]，E[表示14]，F[表示15])， 十进制整数转换成十六进制采用“除16倒取余”，十进制小数转换成十六进制小数采用“乘16取整”。 8.二进制-八进制-十六进制 为什么有八进制,十六进制?因为其是2的倍数,方便运算 因为8=2^3^ 16=2^4^ 二进制-八进制 二进制转换成八进制的时候，只要将二进制的表示从右往左开始，每三位二进制数为1组 八进制转换为二进制只需要将八进制的每一个数用三位二进制表示，然后相连既可以。 二进制(0011 0101)B转换为八进制第一组:101 第二组:011 第三组:00第一组计算过程是:1 20+0 21+1 22=5；第二组计算过程是:0 20+1 21+1 22=6；所以最后的结果是65。也就是用6和5直接相连，而不是相加，这里还要注意一下相连的顺序问题，是6–5的方向。 二进制-十六进制二进制转换为十六进制就是将二进制每四位二进制为一组 十六进制转换为二进制只要需要将十六进制的每一个数用四位二进制表示，然后相连即可。 四.接口 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 一个类只由抽象方法和全局常量组成 1.很干净的接口123public interface TestInterface &#123;&#125; 2.概念而言,接口可以放的东西 JDK 1.8 以后，接口里可以有静态方法和方法体了 12345678910111213public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract //（只能是 public abstract，其他修饰符都会报错） public String SIX = ""; // 方法 public abstract int getData(); //接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量 //（并且只能是 public，用 private 修饰会报编译错误）。 int getDataa();&#125; 但是,也可以放普通内部类,抽象内部类,内部接口 1234567891011121314public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 方法 public abstract int getData(); // 普通内部类 class AA&#123;&#125; // 抽象内部类 abstract class BB&#123;&#125; // 内部接口 interface CC &#123;&#125; // 外部接口 static interface DD&#123;&#125;&#125; 3.接口与类的区别 不能实例化对象 没有构造方法 方法必须是抽象方法 只有用 static 和 final修饰的变量 不能被继承,而是要被类实现 支持多继承 4.接口的应用1.Factory工厂设计模式使用工厂设计模式，解耦 12345678&gt; // 没有使用工厂模式 &gt; public static void main(String[] args) &#123;&gt; //Fruit f = new Apple();&gt; Fruit f = new Orange();&gt; f.eat();&gt; &gt; &#125;&gt; 1234567891011121314151617181920&gt; // 创建工厂类&gt; class Factory&#123;&gt; public static Fruit getInstance(String className)&#123;&gt; if("apple".equals(className))&#123;&gt; return new Apple();&gt; &#125;else if("orange".equals(className))&#123;&gt; return new Orange();&gt; &#125;else&#123;&gt; return null;&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; // 使用工厂模式&gt; public static void main(String[] args) &#123;&gt; Fruit f = Factory.getInstance("apple");&gt; f.eat();&gt; &gt; &#125;&gt; 2.Proxy代理设计模式 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 抽象对象角色 目标对象角色 代理对象角色 1234// 抽象对象角色public interface SourceObj &#123; public void doSomethings();&#125; 12345678// 目标对象角色public class RealObj implements SourceObj&#123; @Override public void doSomethings() &#123; System.out.println("do somethings"); &#125;&#125; 1234567891011121314151617// 代理对象角色public class ProxyObj implements SourceObj&#123; //创建目标对象 RealObj realObj = new RealObj(); @Override public void doSomethings() &#123; // 添加新的方法 System.out.println("before do somethings"); realObj.doSomethings(); // 添加新的方法 System.out.println("end do somethings"); &#125;&#125; 五.抽象方法1.定义抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 抽象类定义： 1.抽象方法必须为 public 或 protected, 2.不能被实例化，采用向上转型处理 3.必须有子类 一个子类只能继承一个抽象类 4.子类不是抽象方法，则需要全部重写父类的抽象方法 123456789101112public abstract class C &#123; //构造方法 public C()&#123; System.out.println("C类的构造方法"); &#125; //普遍方法 public void a() &#123; System.out.println("有方法体"); &#125; // 抽象方法 public abstract void b();&#125; 有构造方法，总是先执行父类的构造，再去执行子类的构造方法 1234567891011public class D extends C &#123; // 构造方法 public D() &#123; System.out.println("D类的构造方法"); &#125; @Override public void b() &#123; System.out.println("d-c.b"); &#125;&#125; 1234public static void StringTest() &#123; D d = new D(); d.b();&#125; 结果：总是先执行父类的构造，再去执行子类的构造方法C类的构造方法D类的构造方法d-c.b 允许内部抽象类 使用static声明外部抽象类 123456abstract class A&#123;//定义一个抽象类 这里不允许使用static声明 static abstract class B&#123;//static定义的内部类属于外部类 public abstract void print(); &#125;&#125; 2.抽象类的应用Template 模板设计模式 模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 这种类型的设计模式属于行为型模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板模式主要由抽象模板(Abstract Template)角色和具体模板(Concrete Template)角色组成 123456789101112131415// 抽象模板角色abstract class Game&#123; //启动游戏 protected abstract void runGame(); //结束游戏 protected abstract void endPlayGame(); //模板方法 public final void play() &#123; runGame(); endPlayGame(); &#125; &#125; 12345678910111213// 具体模板角色class ContraGame extends Game&#123; @Override protected void runGame() &#123; System.out.println("启动aa游戏..."); &#125; @Override protected void endPlayGame() &#123; System.out.println("角色死亡，aa游戏结束！"); &#125;&#125; 123456//测试public static void main(String[] args) &#123; Game game = new ContraGame(); game.play(); System.out.println();&#125; 结果： 启动aa游戏… 角色死亡，aa游戏结束！ 优点 扩展性好，对不变的代码进行封装，对可变的进行扩展；可维护性好，因为将公共代码进行了提取，使用的时候直接调用即可； 缺点 因为每一个不同的实现都需要一个子类来实现，导致类的个数增加，会使系统变得复杂； 使用场景 有多个子类共有逻辑相同的方法；重要的、复杂的方法，可以考虑作为模板方法。 注意事项 为防止恶意操作，一般模板方法都加上 final 关键词！防止修改 六.重写与重载1.区别 区别 重写 重载 1 英文 Override OverLoading 2 定义 方法名相同，参数类型及参数个数不同， 方法名，参数类型，参数个数，返回值完全相同 3 权限 没有权限要求 子类的重写父类的方法，该方法不能拥有比父类更严格的访问控制权限 4 范围 发生在一个类中 发生在继承关系类中 2.this与super 区别 this super 1 定义 表示本类对象 表示父类对象 2 使用 this.属性，this.方法，this(); super.属性，super.方法(),super() 3 构造方法 放在首行 放在首行 4 查找范围 先从本类查找，找不到去父类找 直接找父类 5 特殊 表示当前对象]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基本类型</tag>
        <tag>String</tag>
        <tag>位运算</tag>
        <tag>接口</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F06%2F12%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java中级_多线程]]></title>
    <url>%2F2020%2F05%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java中级_多线程线程 线程是进程中的一个实体 是被系统独立调度和分配的基本单位 一个标准的线程: 线程ID, 当前指令指针(PC) 寄存器集合 堆栈 Java默认线程有两个: main()主线程 GC线程 线程状态 之前线程的状态 （1）新建状态（New）：当线程对象对创建后，即进入了新建状态 （2）就绪状态（Runnable）：当调用线程对象的start()方法,线程即进入就绪状态 （3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行,,执行run()方法 (4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行 （5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 在Java中 在Thread.state源码来看 线程状态有6种 1234567891011121314public enum State &#123;状态 // 新生 NEW, // 运行状态 RUNNABLE, // 阻塞状态 BLOCKED, // 等待----一直等 WAITING, // 超时等待---过时不候 TIMED_WAITING, // 终止 TERMINATED; &#125; 1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 2.运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池 中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU 时间片后变为运行中状态（running）。3.阻塞(BLOCKED)：表示线程阻塞于锁。4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 6.终止(TERMINATED)：表示该线程已经执行完毕。 Java无法开启一个线程: 通过调用本地方法来开启的 1private native void start0(); 多线程 实现Runnable接口,实现Callable和继承Thread可以得到一个线程类 继承Thread方式1234567891011121314class ThreadTest extends Thread &#123; // 线程主体 private String title; public ThreadTest(String title) &#123; this.title = title; &#125; @Override public void run() &#123; // 线程主方法 for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--继承Thread类似创建线程"); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; // Thread ThreadTest t1 = new ThreadTest("线程A"); ThreadTest t2 = new ThreadTest("线程B"); ThreadTest t3 = new ThreadTest("线程C"); t1.start(); // 在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的 t2.start(); t3.start(); &#125; 结果: 线程A–继承Thread类似创建线程线程B–继承Thread类似创建线程线程C–继承Thread类似创建线程线程B–继承Thread类似创建线程线程A–继承Thread类似创建线程线程B–继承Thread类似创建线程线程C–继承Thread类似创建线程线程A–继承Thread类似创建线程线程C–继承Thread类似创建线程 实现Runable接口方式1234567891011121314class RunableTest implements Runnable &#123;// 线程主体 private String title; public RunableTest(String title) &#123;// 线程主方法 this.title = title; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--实现Runable类似创建线程"); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; // Runable RunableTest ta = new RunableTest("Runable-aa"); RunableTest tb = new RunableTest("Runable-bb"); RunableTest tc = new RunableTest("Runable-cc"); new Thread(ta).start(); // 借助Thread类的构造方法启动线程 new Thread(tb).start(); new Thread(tc).start(); &#125; 结果: Runable-aa–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-aa–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-aa–实现Runable类似创建线程 实现Callable方式 123456789101112class CallableTest implements Callable&lt;String&gt; &#123; private String name; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 3; i++) &#123; name = "" + i; System.out.println("name:" + name); &#125; return "测试结束"; &#125;&#125; 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; // Callable CallableTest c1 = new CallableTest(); CallableTest c2 = new CallableTest(); CallableTest c3 = new CallableTest(); //FutureTask是Runnable接口的子类，可以使用Thread类的构造来接收task对象 FutureTask&lt;String&gt; ft1 = new FutureTask&lt;String&gt;(c1); FutureTask&lt;String&gt; ft2 = new FutureTask&lt;String&gt;(c2); FutureTask&lt;String&gt; ft3 = new FutureTask&lt;String&gt;(c3); new Thread(ft1).start(); new Thread(ft2).start(); new Thread(ft3).start(); //多线程执行完毕后，可以使用FutureTask的父接口Future中的get()方法取得执行结果 System.out.println("ft1:" + ft1.get()); System.out.println("ft2:" + ft2.get()); System.out.println("ft3:" + ft3.get()); &#125; 结果: name:0name:0name:0name:1name:1name:2name:1name:2name:2ft1:测试结束ft2:测试结束ft3:测试结束 Runable与Callable区别:不同点Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果 Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛 注：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。 关键字Sleep Thread.sleep(2000); 表示当前线程暂停1000毫秒 ，其他线程不受影响Thread.sleep(2000); 会抛出InterruptedException 中断异常 12345678910111213@Override public void run() &#123; // 线程主方法 try &#123; Thread.sleep(2000); System.out.println("...暂停了2秒才开始输出"); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--继承Thread类似创建线程"); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Join t3.join(3000); 3秒 把某一下线程加入到主线程,表示只有等该线程执行完成才继续运行其他线程 1234567891011public static void main(String[] args) throws Exception &#123; // Thread ThreadTest t1 = new ThreadTest(&quot;线程A&quot;); ThreadTest t2 = new ThreadTest(&quot;线程B&quot;); ThreadTest t3 = new ThreadTest(&quot;线程C&quot;); t1.start(); // 在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的 t2.start(); t3.start(); //把t3线程加入到主线程 3秒 t3.join(3000);&#125; setPriority 线程优先级 12345678// 优先级最高t1.setPriority(Thread.MAX_PRIORITY);// 正常t2.setPriority(Thread.NORM_PRIORITY);// 优先级最低t3.setPriority(Thread.MIN_PRIORITY);// 可以使用数字t4.setPriority(10); yield 临时暂停 1t3.yield(); setDaemon 守护线程 t1.setDaemon(true);设置当前线程为守护进程 1t1.setDaemon(true);]]></content>
      <categories>
        <category>java</category>
        <category>java中级_多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新hexo]]></title>
    <url>%2F2020%2F03%2F22%2F%E9%87%8D%E6%96%B0hexo%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[java测试]]></title>
    <url>%2F2019%2F07%2F11%2Fjava%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[java]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Blogs-Introduce]]></title>
    <url>%2F2019%2F05%2F12%2FBlogs-Introduce%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo github 搭建博客]]></title>
    <url>%2F2019%2F05%2F12%2Fhexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一，创建本地博客 安装软件 Node.js Git 安装hexo（以后的命令，均可以在鼠标右键Git Bash Here） 1$ npm install -g hexo-cli 建立一个Hexo文件夹，用于存放博客 在Hexo目录下，初始化Hexo文件 1Hexo init 在Hexo目录下安装hexo扩展插件 1npm install 在Hexo目录下安装git插件: 1npm install hexo-deployer-git --save 在Hexo目录下生成静态页面: 1hexo generate 在Hexo目录下启动本地服务器: 1hexo server 浏览器输入:http://localhost:4000 二, 部署到github 设置user.name和user.email: git config –global user.name “你的GitHub用户名” 注意global前面是两个双杠【-】 git config –global user.email “你的GitHub注册邮箱” 生成ssh密匙: ssh-keygen -t rsa -C “你的GitHub注册邮箱” ​ 【按需一般需要三次回车】确定 (此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 把id_rsa.pub的内容复制到GitHub账号:用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮,Title随便写. 修改目录配置文件: 1234deploy: type: git repo: git@github.com:oldzhoua/oldzhoua.github.io.git branch: master 清空静态页面: hexo clean 生成静态页面: hexo generate 部署到GitHub: hexo deploy 过程会让你输入g’ithub账号和密码 浏览器输入: oldzhoua.github.io 使用自己的域名 购买域名之后 在域名解析那里填写两个CNAME和A 类型: CNAME&gt;主机记录填写:www CNAME&gt;记录值填写: oldzhoua.github.io A&gt;主机记录填写:@ A&gt;主机值填写:( ping oldzhoua.github.io 会得到的IP值) 在Blogs文件夹下的source目录目录下建立一个没有后缀名的文件,写入,www.oldzhou.top,保存. 在GitHub自己的库中Settings 下的Github Page下填写域名. 在命令行输入: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入自己的域名访问&gt;完成 三，安装NexT主题 安装NexT 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 站点配置文件找到theme 12Hexo/_config.ymltheme: next 更改主题和验证主题之间，我们最好使用hexo clean清理Hexo的缓存 在Hexo目录下检查安装 1hexo s --debug 你可以打开http://localhost:4000在浏览器中，并检查站点是否正确工作 四，个性化设置 现在NexT外观，编辑更改方案主题配置文件，搜索scheme关键字 next主题有四种方案: Muse→默认方案。使用黑白色调，主要看上去干净。 Mist→具有整洁的单列视图。 Pisces→双页面计划布局。 Gemini→有不同的带阴影的列块来显示视图。 12345Next/_config.yml#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 编辑站点配置文件，设置language你需要的语言 12HEXO/config.ymllanguage: zh-CN 配置菜单项，默认情况下，Next提供home和archives页面。其他不提供 12345678910Next/_config.ymlmenu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 刚添加完菜单项的是无法打开的,需要在站点文件下创建相应的路径文件: 在站点文件下了输入以下命令: 1234hexo new page categorieshexo new page tagshexo new page abouthexo new page archives 默认情况下，Next显示没有徽章的菜单项的图标 12345Next/_config.ymlmenu_settings: icons: true # 显示计数 badges: true 配置网站标签页图标，放在Hexo\themes\next\source\images 123456789HEXO/_config.ymlfavicon: #一张16*16，32*32的图片 small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml 配置头像, 编辑主题配置文件 123456Next/_config.ymlavatar: url: /images/avatar.gif rounded: true rotated: true opacity: 1 配置作者，编辑站点配置文件的值，并设置author你的昵称 123HEXO/_config.yml# Siteauthor: xxx 配置描述，编辑站点配置文件的值，并设置description可以是你喜欢的句子 123HEXO/_config.yml# Sitedescription: xxxxxxx 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 配置头像: 在主题文件中: 1avatar: /images/touxiang.jpg 可以检查一下效果: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入: http://localhost:4000/ 设置动态背景: 在主题配置文件中: 12# Canvas-nestcanvas_nest: true 修改文章超链接样式: 在Blogs/themes/next/source/css/_common/components/post/post.styl 文件中添加css: 12345678.post-body p a&#123; color: #FF0000; border-bottom: 2px solid #FF0000; &amp;:hover &#123; color: #4DFFFF; border-bottom: 2px solid #4DFFFF; &#125;&#125; 在文章末尾添加文章结束标记: 在 Blogs\themes\next\layout_macro 下打开命令行新建 passage-end-tag.swig 文件: 1touch passage-end-tag.swig 在新建文件中添加: 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #fc6423;font-size:16px;&quot;&gt;---本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读!---&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 在 Blogs\themes\next\layout_macro\post.swig 中的如下面位置添加: 12345678 &#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件添加: 12passage_end_tag: enabled: true 设置头像及样式: 1avatar: 头像地址 设置头像圆角:在Blogs/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 添加: 12345.site-author-image &#123; border-radius: 70px; -webkit-border-radius: 70px; -moz-border-radius: 70px;&#125; 侧栏社交图标: 在主题配置文件搜索social 去掉#选择 123456789social: Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype || xxx,xxx表示图标,在Font Awesome Icon 网站找然后复制下来 文章添加阴影效果: 在Blogs\themes\next\source\css_custom\custom.styl下添加: 12345.post &#123; box-shadow: 0 0 10px rgba(255, 0, 0, .8); -webkit-box-shadow: 0 0 10px rgba(255, 0, 0, .8); -moz-box-shadow: 0 0 10px rgba(255, 0, 0, .8); &#125; 文件上传的方法 在站点文件下打开命令行安装插件: 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 在站点配置文件修改如下: 1post_asset_folder: true 在 hexo new “标题” 的时候,会在同级目录下生成多一个同名的文件夹(用于放图片)格式如下: 1![](标题\图片名.png) 需要注意的是,如果是以选择的方式添加的,可以选择把多余的路径删掉, 比如: 1![](E:\Blogs\source\_posts\标题\图片名.png) 1![](标题\图片名.png) 然后重新部署一下就可以看到图片了 设置底部添加访问量: 使用busuanzi: 在 Blogs/themes/next/layout/_partials/footer.swig 文件中顶部添加: 1234567&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 设置网站底部字数统计 在站点目录下安装插件 1npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig 文件中添加: 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 设置文章统计功能 安装插件 1npm install hexo-wordcount --save 修改主题配置文件: 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 设置网页进度条 在主题配置文件搜索pace:值改为 true,去掉#选择款式 1234567# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shoppace_theme: pace-theme-minimal 设置网站标签页图标 在图标网站, 比如: 阿里巴巴矢量图标库 ,下载一张16x16,32x32的图 在Blogs/themes/next/source/images 中,替换默认的两张图片 如果修改了名字侧需要在主题配置文件中搜索favicon 12345# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png 隐藏底部标记 在Blogs/themes/next/layout/_partials/footer.swig 中,用注释掉相应的代码 设置博文置顶 在Blogs/node_modules/hexo-generator-index/lib/generator.js 的代码改为: 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章头添加top: xx,值越大越靠前显示: 1234567title: next主题优化系列二date: 2019-01-18 14:21:49tags:- next- 优化categories: nexttop: 88 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 增加版权信息 在Blogs/themes/next/layout/_macro/ 添加 my-copyright.swig文件 1touch my-copyright.swig my-copyright.swig代码: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在Blogs/themes/next/source/css/_common/components/post/添加 my-copyright.styl文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 在Blogs/themes/next/layout/_macro/post.swig 文件中如下位置添加代码: 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 如: 12345678910111213141516&#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在Blogs/themes/next/source/css/_common/components/post/post.styl文件最后添加: 1@import &quot;my-post-copyright&quot; 在文章头添加:copyright : true 123456tags: - next - 优化 categories: next copyright: true top: 配置站点配置文件: 123456# URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://oldzhoua.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: 重新部署就可以看见效果了 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
