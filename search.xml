<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中级]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Java中级1.异常1.分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 123456789101112131415异常的体系结构 * java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。 * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked)不会生成字节码文件 * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException//空指针异常 * |-----ArrayIndexOutOfBoundsException//数组角标越界 * |-----ClassCastException//类型转化异常 * |-----NumberFormatException//编码格式异常 * |-----InputMismatchException//输入不匹配 * |-----ArithmeticException//算术异常 2.处理异常方式 throws try-catch-finally finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 3.自定义异常12345678910public class MyException extends Exception&#123; private static final long serialVersionUID = 1L; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 2.JDBC1.定义 JDBC的全称是java数据库链接（Java Data Base Connect），它是用于执行SQL语句的java代码，应用程序可以通过JDBC链接到数据库，并使用SQL语句来完成对数据库中数据的新增、查询、删除和更新等操作 PreparedStatement的优点-防止SQL注入式攻击 PreparedStatement有预编译机制，性能比Statement更快 PreparedStatement 使用参数设置，可读性好，不易犯错 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Connection c = null; Statement s = null; try &#123; // 初始化驱动 Class.forName("com.mysql.jdbc.Driver"); // 建立与数据库的Connection连接 c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/a?characterEncoding=UTF-8", "root", "admin"); // 创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql); // SQL语句 String sql = "insert into cc values(?,?)"; ps.setString(1, "aaa"); ps.setString(1, "bbb"); // 执行SQL ps.execute(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯 // 先关闭PreparedStatement if (ps != null) try &#123; ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 后关闭Connection if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 3.I/O 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 所有的IO操作都在java.io包之中进行定义，而且整个java.io包实际上就是五个类和一个接口：（1）五个类：File、InputStream、OutputStream、Reader、Wirter；（2）一个接口：Serializable。 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 1.File 没啥好补充的 2.字节流与字符流 （1）字节操作流：OutputStream、InputStream；（2）字符操作流：Writer、Reader。 字节流 OutputStream和InputStream是字节流的两个顶层父类。让他们提供了输出流类和输入流类通用API，字节流一般用于读写二进制数据，如图像和声音数据。 OutputStream12345678910111213141516171819202122232425public static void Test2() throws IOException &#123; System.out.println("开始创建文件..."); // 定义文件路径 File file = new File("D:" + File.separator + "java" + File.separator + "test" + File.separator + UUID.randomUUID().toString() + ".txt"); // 判断路径存在? if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; // 文件存在? if (file.exists()) &#123; // 文件存在 file.delete(); // 删除文件 &#125; else &#123; // 文件不存在 file.createNewFile(); // 创建新文件 &#125; // 实例化输出 FileOutputStream fos = new FileOutputStream(file); String data = "哈哈哈哈哈哈哈哈哈"; System.out.println("开始生成数据源..." + file.getAbsolutePath()); // 输出数据 转化为字节数组输出 fos.write(data.getBytes()); // 关闭资源 fos.close(); System.out.println("输出流演示完成!"); &#125; InputStream字符流字符输入流writer]]></content>
      <categories>
        <category>java</category>
        <category>java中级</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>JDBC</tag>
        <tag>I/O</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java基础一.八种基本数据类型byte 8位 默认值为0 short 16位 默认值0 int 32位 默认值0 long 64位 默认值0L float 32位 默认值 0.0F double 64位 默认值0.0D char 16位 默认值 空 boolean 8位 默认值 false 二.String-字符串1.String 字符串不变; 它们的值在创建后不能被更改。 字符串缓冲区(StringBuffer,StringBuilder)支持可变字符串。 因为String对象是不可变的，它们可以被共享 传递null参数到此类中的构造函数或方法将导致抛出NullPointerException 。 1234 String str = "abc";// 相当于 char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data); compareTo 12public int compareTo(String anotherString)//按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值 isEmpty() 12public boolean isEmpty()//true如果，只有 length()是 0 。 切割字符串 split() 12public String[] split(String regex)//该方法的工作原理是通过使用给定表达式和限制参数为零调用双参数split方法。 因此，尾随的空字符串不会包含在结果数组中。 substring() 12public String substring(int beginIndex)//返回一个字符串，该字符串是此字符串的子字符串 charAt() 12public char charAt(int index)//返回char指定索引处的值。 指数范围为0至length() - 1 。 该序列的第一个char值在索引0 ，下一个索引为1 ，依此类推，与数组索引一样。 2.StringBuffer 一个可变的字符序列 线程不安全 在可能的情况下，建议使用这个类别优先于StringBuilder ，因为它在大多数实现中将更快。 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 3.StringBuilder 可变的字符序列 线程安全 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 三.位运算 与（&amp;）、非（~）、或（|）、异或（^） 1.与 &amp; 两个操作数中位都为1，结果才为1，否则结果为0 2.非 ~ 如果位为0，结果是1，如果位为1，结果是0 3.或 | 两个位只要有一个为1，那么结果就是1，否则就为0 4.异或 ^ 两个操作数的位中，相同则结果为0，不同则结果为1 5.十进制-二进制 二进制: 0 1 1 1 1 1 1 1 1 1 二进制 128 64 32 16 8 4 2 1 十进制 十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。 6.十进制-八进制 八进制：它的基数是8，总共有8个数字符号(0，1，2，3，4，5，6，7)， 十进制整数转换成八进制采用“除8倒取余”，十进制小数转换成二进制小数采用“乘8取整”。 7.十进制-十六进制 十六进制：它的基数是16，总共有16个数字符号(0，1，2，3，4，5，6，7，8，9， ​ A[表示10]，B[表示11]，C[表示12]，D[表示13]，E[表示14]，F[表示15])， 十进制整数转换成十六进制采用“除16倒取余”，十进制小数转换成十六进制小数采用“乘16取整”。 8.二进制-八进制-十六进制 为什么有八进制,十六进制?因为其是2的倍数,方便运算 因为8=2^3^ 16=2^4^ 二进制-八进制 二进制转换成八进制的时候，只要将二进制的表示从右往左开始，每三位二进制数为1组 八进制转换为二进制只需要将八进制的每一个数用三位二进制表示，然后相连既可以。 二进制(0011 0101)B转换为八进制第一组:101 第二组:011 第三组:00第一组计算过程是:1 20+0 21+1 22=5；第二组计算过程是:0 20+1 21+1 22=6；所以最后的结果是65。也就是用6和5直接相连，而不是相加，这里还要注意一下相连的顺序问题，是6–5的方向。 二进制-十六进制二进制转换为十六进制就是将二进制每四位二进制为一组 十六进制转换为二进制只要需要将十六进制的每一个数用四位二进制表示，然后相连即可。 四.接口 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 一个类只由抽象方法和全局常量组成 1.很干净的接口123public interface TestInterface &#123;&#125; 2.概念而言,接口可以放的东西 JDK 1.8 以后，接口里可以有静态方法和方法体了 12345678910111213public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract //（只能是 public abstract，其他修饰符都会报错） public String SIX = ""; // 方法 public abstract int getData(); //接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量 //（并且只能是 public，用 private 修饰会报编译错误）。 int getDataa();&#125; 但是,也可以放普通内部类,抽象内部类,内部接口 1234567891011121314public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 方法 public abstract int getData(); // 普通内部类 class AA&#123;&#125; // 抽象内部类 abstract class BB&#123;&#125; // 内部接口 interface CC &#123;&#125; // 外部接口 static interface DD&#123;&#125;&#125; 3.接口与类的区别 不能实例化对象 没有构造方法 方法必须是抽象方法 只有用 static 和 final修饰的变量 不能被继承,而是要被类实现 支持多继承 4.接口的应用1.Factory工厂设计模式使用工厂设计模式，解耦 12345678&gt; // 没有使用工厂模式 &gt; public static void main(String[] args) &#123;&gt; //Fruit f = new Apple();&gt; Fruit f = new Orange();&gt; f.eat();&gt; &gt; &#125;&gt; 1234567891011121314151617181920&gt; // 创建工厂类&gt; class Factory&#123;&gt; public static Fruit getInstance(String className)&#123;&gt; if("apple".equals(className))&#123;&gt; return new Apple();&gt; &#125;else if("orange".equals(className))&#123;&gt; return new Orange();&gt; &#125;else&#123;&gt; return null;&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; // 使用工厂模式&gt; public static void main(String[] args) &#123;&gt; Fruit f = Factory.getInstance("apple");&gt; f.eat();&gt; &gt; &#125;&gt; 2.Proxy代理设计模式 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 抽象对象角色 目标对象角色 代理对象角色 1234// 抽象对象角色public interface SourceObj &#123; public void doSomethings();&#125; 12345678// 目标对象角色public class RealObj implements SourceObj&#123; @Override public void doSomethings() &#123; System.out.println("do somethings"); &#125;&#125; 1234567891011121314151617// 代理对象角色public class ProxyObj implements SourceObj&#123; //创建目标对象 RealObj realObj = new RealObj(); @Override public void doSomethings() &#123; // 添加新的方法 System.out.println("before do somethings"); realObj.doSomethings(); // 添加新的方法 System.out.println("end do somethings"); &#125;&#125; 五.抽象方法1.定义抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 抽象类定义： 1.抽象方法必须为 public 或 protected, 2.不能被实例化，采用向上转型处理 3.必须有子类 一个子类只能继承一个抽象类 4.子类不是抽象方法，则需要全部重写父类的抽象方法 123456789101112public abstract class C &#123; //构造方法 public C()&#123; System.out.println("C类的构造方法"); &#125; //普遍方法 public void a() &#123; System.out.println("有方法体"); &#125; // 抽象方法 public abstract void b();&#125; 有构造方法，总是先执行父类的构造，再去执行子类的构造方法 1234567891011public class D extends C &#123; // 构造方法 public D() &#123; System.out.println("D类的构造方法"); &#125; @Override public void b() &#123; System.out.println("d-c.b"); &#125;&#125; 1234public static void StringTest() &#123; D d = new D(); d.b();&#125; 结果：总是先执行父类的构造，再去执行子类的构造方法C类的构造方法D类的构造方法d-c.b 允许内部抽象类 使用static声明外部抽象类 123456abstract class A&#123;//定义一个抽象类 这里不允许使用static声明 static abstract class B&#123;//static定义的内部类属于外部类 public abstract void print(); &#125;&#125; 2.抽象类的应用Template 模板设计模式 模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 这种类型的设计模式属于行为型模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板模式主要由抽象模板(Abstract Template)角色和具体模板(Concrete Template)角色组成 123456789101112131415// 抽象模板角色abstract class Game&#123; //启动游戏 protected abstract void runGame(); //结束游戏 protected abstract void endPlayGame(); //模板方法 public final void play() &#123; runGame(); endPlayGame(); &#125; &#125; 12345678910111213// 具体模板角色class ContraGame extends Game&#123; @Override protected void runGame() &#123; System.out.println("启动aa游戏..."); &#125; @Override protected void endPlayGame() &#123; System.out.println("角色死亡，aa游戏结束！"); &#125;&#125; 123456//测试public static void main(String[] args) &#123; Game game = new ContraGame(); game.play(); System.out.println();&#125; 结果： 启动aa游戏… 角色死亡，aa游戏结束！ 优点 扩展性好，对不变的代码进行封装，对可变的进行扩展；可维护性好，因为将公共代码进行了提取，使用的时候直接调用即可； 缺点 因为每一个不同的实现都需要一个子类来实现，导致类的个数增加，会使系统变得复杂； 使用场景 有多个子类共有逻辑相同的方法；重要的、复杂的方法，可以考虑作为模板方法。 注意事项 为防止恶意操作，一般模板方法都加上 final 关键词！防止修改 六.重写与重载1.区别 区别 重写 重载 1 英文 Override OverLoading 2 定义 方法名相同，参数类型及参数个数不同， 方法名，参数类型，参数个数，返回值完全相同 3 权限 没有权限要求 子类的重写父类的方法，该方法不能拥有比父类更严格的访问控制权限 4 范围 发生在一个类中 发生在继承关系类中 2.this与super 区别 this super 1 定义 表示本类对象 表示父类对象 2 使用 this.属性，this.方法，this(); super.属性，super.方法(),super() 3 构造方法 放在首行 放在首行 4 查找范围 先从本类查找，找不到去父类找 直接找父类 5 特殊 表示当前对象]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基本类型</tag>
        <tag>String</tag>
        <tag>位运算</tag>
        <tag>接口</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F06%2F12%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[重新hexo]]></title>
    <url>%2F2020%2F03%2F22%2F%E9%87%8D%E6%96%B0hexo%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[java测试]]></title>
    <url>%2F2019%2F07%2F11%2Fjava%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[java]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Blogs-Introduce]]></title>
    <url>%2F2019%2F05%2F12%2FBlogs-Introduce%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo github 搭建博客]]></title>
    <url>%2F2019%2F05%2F12%2Fhexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一，创建本地博客 安装软件 Node.js Git 安装hexo（以后的命令，均可以在鼠标右键Git Bash Here） 1$ npm install -g hexo-cli 建立一个Hexo文件夹，用于存放博客 在Hexo目录下，初始化Hexo文件 1Hexo init 在Hexo目录下安装hexo扩展插件 1npm install 在Hexo目录下安装git插件: 1npm install hexo-deployer-git --save 在Hexo目录下生成静态页面: 1hexo generate 在Hexo目录下启动本地服务器: 1hexo server 浏览器输入:http://localhost:4000 二, 部署到github 设置user.name和user.email: git config –global user.name “你的GitHub用户名” 注意global前面是两个双杠【-】 git config –global user.email “你的GitHub注册邮箱” 生成ssh密匙: ssh-keygen -t rsa -C “你的GitHub注册邮箱” ​ 【按需一般需要三次回车】确定 (此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 把id_rsa.pub的内容复制到GitHub账号:用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮,Title随便写. 修改目录配置文件: 1234deploy: type: git repo: git@github.com:oldzhoua/oldzhoua.github.io.git branch: master 清空静态页面: hexo clean 生成静态页面: hexo generate 部署到GitHub: hexo deploy 过程会让你输入g’ithub账号和密码 浏览器输入: oldzhoua.github.io 使用自己的域名 购买域名之后 在域名解析那里填写两个CNAME和A 类型: CNAME&gt;主机记录填写:www CNAME&gt;记录值填写: oldzhoua.github.io A&gt;主机记录填写:@ A&gt;主机值填写:( ping oldzhoua.github.io 会得到的IP值) 在Blogs文件夹下的source目录目录下建立一个没有后缀名的文件,写入,www.oldzhou.top,保存. 在GitHub自己的库中Settings 下的Github Page下填写域名. 在命令行输入: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入自己的域名访问&gt;完成 三，安装NexT主题 安装NexT 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 站点配置文件找到theme 12Hexo/_config.ymltheme: next 更改主题和验证主题之间，我们最好使用hexo clean清理Hexo的缓存 在Hexo目录下检查安装 1hexo s --debug 你可以打开http://localhost:4000在浏览器中，并检查站点是否正确工作 四，个性化设置 现在NexT外观，编辑更改方案主题配置文件，搜索scheme关键字 next主题有四种方案: Muse→默认方案。使用黑白色调，主要看上去干净。 Mist→具有整洁的单列视图。 Pisces→双页面计划布局。 Gemini→有不同的带阴影的列块来显示视图。 12345Next/_config.yml#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 编辑站点配置文件，设置language你需要的语言 12HEXO/config.ymllanguage: zh-CN 配置菜单项，默认情况下，Next提供home和archives页面。其他不提供 12345678910Next/_config.ymlmenu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 刚添加完菜单项的是无法打开的,需要在站点文件下创建相应的路径文件: 在站点文件下了输入以下命令: 1234hexo new page categorieshexo new page tagshexo new page abouthexo new page archives 默认情况下，Next显示没有徽章的菜单项的图标 12345Next/_config.ymlmenu_settings: icons: true # 显示计数 badges: true 配置网站标签页图标，放在Hexo\themes\next\source\images 123456789HEXO/_config.ymlfavicon: #一张16*16，32*32的图片 small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml 配置头像, 编辑主题配置文件 123456Next/_config.ymlavatar: url: /images/avatar.gif rounded: true rotated: true opacity: 1 配置作者，编辑站点配置文件的值，并设置author你的昵称 123HEXO/_config.yml# Siteauthor: xxx 配置描述，编辑站点配置文件的值，并设置description可以是你喜欢的句子 123HEXO/_config.yml# Sitedescription: xxxxxxx 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 配置头像: 在主题文件中: 1avatar: /images/touxiang.jpg 可以检查一下效果: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入: http://localhost:4000/ 设置动态背景: 在主题配置文件中: 12# Canvas-nestcanvas_nest: true 修改文章超链接样式: 在Blogs/themes/next/source/css/_common/components/post/post.styl 文件中添加css: 12345678.post-body p a&#123; color: #FF0000; border-bottom: 2px solid #FF0000; &amp;:hover &#123; color: #4DFFFF; border-bottom: 2px solid #4DFFFF; &#125;&#125; 在文章末尾添加文章结束标记: 在 Blogs\themes\next\layout_macro 下打开命令行新建 passage-end-tag.swig 文件: 1touch passage-end-tag.swig 在新建文件中添加: 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #fc6423;font-size:16px;&quot;&gt;---本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读!---&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 在 Blogs\themes\next\layout_macro\post.swig 中的如下面位置添加: 12345678 &#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件添加: 12passage_end_tag: enabled: true 设置头像及样式: 1avatar: 头像地址 设置头像圆角:在Blogs/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 添加: 12345.site-author-image &#123; border-radius: 70px; -webkit-border-radius: 70px; -moz-border-radius: 70px;&#125; 侧栏社交图标: 在主题配置文件搜索social 去掉#选择 123456789social: Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype || xxx,xxx表示图标,在Font Awesome Icon 网站找然后复制下来 文章添加阴影效果: 在Blogs\themes\next\source\css_custom\custom.styl下添加: 12345.post &#123; box-shadow: 0 0 10px rgba(255, 0, 0, .8); -webkit-box-shadow: 0 0 10px rgba(255, 0, 0, .8); -moz-box-shadow: 0 0 10px rgba(255, 0, 0, .8); &#125; 文件上传的方法 在站点文件下打开命令行安装插件: 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 在站点配置文件修改如下: 1post_asset_folder: true 在 hexo new “标题” 的时候,会在同级目录下生成多一个同名的文件夹(用于放图片)格式如下: 1![](标题\图片名.png) 需要注意的是,如果是以选择的方式添加的,可以选择把多余的路径删掉, 比如: 1![](E:\Blogs\source\_posts\标题\图片名.png) 1![](标题\图片名.png) 然后重新部署一下就可以看到图片了 设置底部添加访问量: 使用busuanzi: 在 Blogs/themes/next/layout/_partials/footer.swig 文件中顶部添加: 1234567&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 设置网站底部字数统计 在站点目录下安装插件 1npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig 文件中添加: 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 设置文章统计功能 安装插件 1npm install hexo-wordcount --save 修改主题配置文件: 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 设置网页进度条 在主题配置文件搜索pace:值改为 true,去掉#选择款式 1234567# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shoppace_theme: pace-theme-minimal 设置网站标签页图标 在图标网站, 比如: 阿里巴巴矢量图标库 ,下载一张16x16,32x32的图 在Blogs/themes/next/source/images 中,替换默认的两张图片 如果修改了名字侧需要在主题配置文件中搜索favicon 12345# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png 隐藏底部标记 在Blogs/themes/next/layout/_partials/footer.swig 中,用注释掉相应的代码 设置博文置顶 在Blogs/node_modules/hexo-generator-index/lib/generator.js 的代码改为: 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章头添加top: xx,值越大越靠前显示: 1234567title: next主题优化系列二date: 2019-01-18 14:21:49tags:- next- 优化categories: nexttop: 88 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 增加版权信息 在Blogs/themes/next/layout/_macro/ 添加 my-copyright.swig文件 1touch my-copyright.swig my-copyright.swig代码: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在Blogs/themes/next/source/css/_common/components/post/添加 my-copyright.styl文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 在Blogs/themes/next/layout/_macro/post.swig 文件中如下位置添加代码: 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 如: 12345678910111213141516&#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在Blogs/themes/next/source/css/_common/components/post/post.styl文件最后添加: 1@import &quot;my-post-copyright&quot; 在文章头添加:copyright : true 123456tags: - next - 优化 categories: next copyright: true top: 配置站点配置文件: 123456# URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://oldzhoua.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: 重新部署就可以看见效果了 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
