<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试_Java基础]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称， 开发工具包，提供了 java 的开发环境和运行环境。 JRE**：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE**，同时还包含了编译 java 源码的编译器 javac**，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK**。** 3. 两个对象的 hashCode()**相同，则 equals()**也一定为 true**，对吗？** equals equals()方法是用来判断其他的对象是否和该对象相等，它的性质有： 自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。 hashCode hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。 它的性质是： 在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。 并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。 大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。 在每个改写了equals()方法的类中，必须要改写hashCode()方法。如果不这样做，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于hash的集合类结合在一起正常运作，这样的集合类包括HashMap、HashSet和HashTable。 需要注意的是: 这个hashCode()方法是合法的，因为相等的对象总是具有同样的散列码. 1 2 3 public int hashCode() { return 0; } 但是它使得每一个对象都具有同样的散列码。因此，每个对象都被映射到同一个散列桶中，从而散列表被退化为链表。对于规模很大的散列表而言，这关系到散列表能否正常工作。 一个好的散列函数通常倾向于“7为不相等的对象产生不相等的散列码”。 如果一个类是非可变的，并且计算散列码的代价也比较大，那么你应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。 不要试图从散列码计算中排除掉一个对象的关键部分以提高性能 不对，两个对象的 hashCode()**相同，equals()不一定 true。(两本书有着同样的书名和作者，但是它们是两本“不同”的书。)** 代码解读：很显然**“通话”和“重地”**的 hashCode() 相同，然而 equals() 则为 false**，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。** 4. final 在 java 中有什么作用？ final 修饰的类叫最终**类，该类不能被继承**。 final 修饰的**方法不能被重写**。 final 修饰的变量叫常量，**常量必须初始化**，初始化之后值就不能被修改。 8. String str=”i”**与 String str=new String(“i”)**一样吗？ 不一样，因为内存的分配方式不一样。**String str=”i”的方式，(JVM java va)java 虚拟机会将其分配到常量池-&gt;方法区中；而 String str=new String(“i”) 则会被分到堆内存中。** 9. 如何将字符串反转？ 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 10. String 类的常用方法都有那些？ indexOf**()**：返回指定字符的索引。 charAt**()**：返回指定索引处的字符。 replace**()**：字符串替换。 trim**()**：去除字符串两端空白。 split**()**：分割字符串，返回一个分割后的字符串数组。 getBytes()**：返回字符串的 byte 类型数组。** length**()**：返回字符串长度。 toLowerCase()**：将字符串转成小写字母。** toUpperCase()**：将字符串转成大写字符。** substring()**：截取字符串。** equals**()**：字符串比较。 11. 抽象类必须要有抽象方法吗？ 在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧 不需要，抽象类不一定非要有抽象方法。 12. 普通类和抽象类有哪些区别？ 1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 2）抽象类不能用来创建对象； 3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 在其他方面，抽象类和普通的类并没有区别。 普通类不能包含**抽象方法**，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 15. java 中 IO 流分为几种？ 按功能来分：**输入流（input）、输出流（output**）。 按类型来分：**字节流和字符流**。 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。 16. BIO**、NIO、**AIO 有什么区别？ BIO**：**Block IO 同步阻塞式 IO**，就是我们平常使用的传统 IO**，它的特点是模式简单使用方便，并发处理能力低。 NIO**：**New IO 同步非阻塞 IO**，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用**。 AIO**：**Asynchronous IO 是 NIO 的升级，也叫 NIO2**，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。** 17. Files**的常用方法都有哪些？** Files.exists()**：检测文件路径是否存在。** Files.createFile()**：创建文件。** Files.createDirectory()**：创建文件夹。** Files.delete()**：删除一个文件或目录。** Files.copy()**：复制文件。** Files.move()**：移动文件。** Files.size()**：查看文件个数。** Files.read()**：读取文件。** Files.write()**：写入文件。** 容器 18. java 容器都有哪些？ 常用容器的图录： Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。 20. List**、Set、**Map 之间的区别是什么？ java的关键字（keyword）有多少个？ 51+2个保留字=53个关键字(java的关键字都是小写的！！) 21. HashMap 和 Hashtable 有什么区别？ hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。 hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。 hashMap允许空键值，而hashTable不允许。 22. 如何决定使用 HashMap 还是 TreeMap**？** 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。 23. 说一下 HashMap 的实现原理？ HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn) 24. 说一下**HashSet 的实现原理？** HashSet底层由HashMap实现 HashSet的值存放于HashMap的key上 HashMap的value统一为PRESENT present 25. ArrayList 和 LinkedList 的区别是什么？ 最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂是 O(1)，而 LinkedList 是 O(n)。 26. 如何实现数组和 List 之间的转换？ List转换成为数组：调用ArrayList的toArray方法。 数组转换成为List：调用Arrays的asList方法。 27. ArrayList 和 Vector 的区别是什么？ Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 ArrayList比Vector快，它因为有同步，不会过载。 ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。 28. Array 和 ArrayList 有何区别？ Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 Array是指定大小的，而ArrayList大小是固定的。 Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。 29. 在 Queue 中 poll()**和 remove()**有什么区别？ poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 30. 哪些集合类是线程安全的？ vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。 enumeration：枚举，相当于迭代器。 statck：堆栈类，先进后出。(hashtable的子类) hashtable：就比hashmap多了个线程安全。 31. 迭代器 Iterator 是什么？ 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 32. Iterator 怎么使用？有什么特点？ Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。 (2) 使用next()获得序列中的下一个元素。 (3) 使用hasNext()检查序列中是否还有元素。 (4) 使用remove()将迭代器新返回的元素删除。 Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。 33. Iterator 和 ListIterator 有什么区别？ Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 多线程 35. 并行和并发有什么区别？ 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 36. 线程和进程的区别？ 简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。 守护线程是什么？ 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。 38. 创建线程有哪几种方式？ ①. 继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 ②. 通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 ③. 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 39. 说一下 runnable 和 callable 有什么区别？ Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已； Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 40. 线程有哪些状态？ 线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 41. sleep() 和 wait() 有什么区别？ sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。 wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程 42. notify()**和 notifyAll()**有什么区别？ 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 43. 线程的 run()**和 start()**有什么区别？ 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。 start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。 44. 创建线程池有哪几种方式？ ①. newFixedThreadPool(int nThreads) 创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。 ②. newCachedThreadPool() 创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。 ③. newSingleThreadExecutor() 这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。 ④. newScheduledThreadPool(int corePoolSize) 创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。 45. 线程池都有哪些状态？ 线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。 线程池各个状态切换框架图： 46. 线程池中 submit()**和 execute()**方法有什么区别？ 接收的参数不一样 submit有返回值，而execute没有 submit方便Exception处理 47. 在 java 程序中怎么保证多线程的运行安全？ 线程安全在三个方面体现： 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）； 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）； 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。 48. 多线程锁的升级原理是什么？ 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。 ​ 锁升级的图示过程： 49. 什么是死锁？ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称. 50. 怎么防止死锁？ 死锁的四个必要条件： 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 51. ThreadLocal 是什么？有哪些使用场景？ 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 synchronized 底层实现原理？ synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 \53. synchronized 和 volatile 的区别是什么？ volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 54. synchronized 和 Lock 有什么区别？ 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）； Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 55. synchronized 和 ReentrantLock 区别是什么？ synchronized是和if、else、for、while一样的关键字， ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中markword。 56. atomic 的原理？ Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。 反射 57. 什么是反射？ 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 Java反射： 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法。对于任意一个对象，能否调用它的任意一个方法 Java反射机制主要提供了以下功能： 在运行时构造任意一个类的对象。 在运行时判断任意一个对象所属的类。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 58. 什么是 java 序列化？什么情况下需要序列化？ 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 什么情况下需要序列化： a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； 59. 动态代理是什么？有哪些应用？ 动态代理： 当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。 动态代理的应用： Spring的AOP 加事务 加权限 加日志 60. 怎么实现动态代理？ 首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。 61. 为什么要使用克隆？ 想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。 62. 如何实现对象克隆？ 有两种方式： 1). 实现Cloneable接口并重写Object类中的clone()方法； 2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 63. 深拷贝和浅拷贝区别是什么？ 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例:assign()） 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型） 1.**写clone()方法时，通常都有一行代码，是什么** clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 2.**面向对象的特征有哪些方面** ==封装==：将对象封装成独立的，高度自治的，相对封闭的模块，实现“高内聚，低耦合”，降低相互的依赖性，这个对象状态（属性）由这个对象自己的行为（方法）来读取和改变，将属性（变量）定位private，只有这个类自己的方法才可以访问到这些成员变量，一个原则是：让方法和它待在一起。 ==继承==：表示的是类与类的关系，是子类共享父类所有数据和方法的一种机制，可提高软件的可重用性和扩展性，缺点是加强了耦合性。 构造方法和private修饰的方法不可以被继承。 ==多态==：程序运行时的多种状态，增强了软件的灵活性和扩展性。 ==抽象==： 将事物的相似和共性之处，拿出来，然后将这些事物归为一个类，忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面，抽象包括行为抽象和状态抽象两个方面。 把握一个原则：当前系统需要什么就只考虑什么。 2.java**中实现多态的机制是什么？** 靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定\，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 3.abstract class**和interface有什么区别**? 抽象类：含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。 含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。 abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，==所以，不能有抽象构造方法或抽象静态方法**==。 如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为**abstract**类型。 接口：（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。 - 接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 ==**语法区别==：** 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），==但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型==。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 一个类可以实现多个接口，但只能继承一个抽象类。 ==**应用上的区别**==： 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约 而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。 //父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 4.abstract**的method是否可同时是static,是否可同时是native，是否可同时是**synchronized? abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。 例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk的源代码，可以发现FileOutputStream的open方法的定义如下：native void open(String name) throws FileNotFoundException;```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，==但需要在前面声明native==。关于synchronized与abstract合用的问题，我觉得也不行，synchronized应该是作用在一个具体的方法上才有意义，而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。**5.****什么是内部类？****Static Nested Class** **和** **Inner Class****的不同。**首先内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中 在方法内部定义的内部类前面不能有访问类型修饰符，**6.****内部类可以引用它的包含类的成员吗？有没有什么限制？**一般而言是可以的。如果不是静态内部类，那没有什么限制！但是，如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员**7.Anonymous Inner Class (****匿名内部类****)****是否可以****extends(****继承****)****其它类，是否可以****implements(****实现****)interface(****接口****)?**可以继承其他类或实现其他接口。不仅是可以，而是必须!**8.super.getClass()****方法调用** import java.util.Date; public class Test extends Date&#123; public static void main(String[] args) &#123; new Test().test(); &#125; public void test()&#123; System.out.println(super.getClass().getName()); &#125; &#125; 结果是Test, 在test方法中，直接调用getClass().getName()方法，返回的是Test类名,由于getClass()在Object类中定义成了final，子类不能覆盖该方法。 所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法。 所以，super.getClass().getName()方法返回的也应该是Test，如果想得到父类的名称，应该用如下代码：getClass().getSuperClass().getName();**9.jdk****中哪些类是不能继承的？** 不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中比如，System,String,StringBuffer等类型。**10.String****是最基本的数据类型吗****?**不是，是属于引用类型。引用类型还有数组，日期等类型，java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。基本数据类型包括byte、int、char、long、float、double、boolean和short。**11.String s = &quot;Hello&quot;;s = s + &quot; world!&quot;;****这两行代码执行后，原始的****String****对象中的内容到底变了没有？**没有。因为String由final修饰，被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。如果要使用内容相同的字符串，不必每次都new一个String。比如下面的例子，在构造器中对一个叫S的string引用变量进行初始化，将其设置为初始值：应该如下这样做 public class Demo &#123; private String s; ... public Demo &#123; s = &quot;Initial Value&quot;; &#125; ... &#125;而不是==s = new String(&quot;Initial Value&quot;)==，因为这样每次都会掉用新的构造器，生成新的对象，性能低下的同时，内存开销大**12.****是否可以继承****String****类****?**不能，String类是final类，故不可以继承。**13.String s = new String(&quot;xyz&quot;);****创建了几个****String Object?** **二者之间有什么区别？** 两个或者一个对象。”xyz”对应一个对象，这个对象放在==字符串常量缓冲区==，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象，如果以前就用过’xyz’，就不会创建”xyz”自己了，直接从缓冲区拿。**14.String** **和****StringBuffer****的区别**JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。String类： 表示内容不可改变的字符串，string重写了equals（）方法，new String(“abc”).equals(new String(“abc”)的结果为true，StringBuffer类： 表示内容可以被修改的字符串，因此当你知道字符数据要改变的时候你就可以使用==StringBuffer==（比如：你可以使用StringBuffer来动态构造字符数据），StringBuffer并没有实现equals（）方法，故new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。 StringBuffer sbf = new StringBuffer(); for(int i=0;i&lt;100;i++)&#123; sbf.append(i); &#125;上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。 String str = new String(); for(int i=0;i&lt;100;i++)&#123; str = str + i; &#125; 在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。**15.StringBuffer****与****StringBuilder****的区别**StringBuffer和StringBuilder类都表示内容可以被修改的字符串StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。**16.****如何把一段逗号分割的字符串转换成一个数组****?** 用正则表达式，代码大概为：==String [] result = orgStr.split(“,”);==用 StringTokenizer 代码为（高逼格）： String orgStr = “aa,aa,dd,d”;StringTokenizer tokener = new StringTokenizer(orgStr,”,”);String[] result = new String[tokener.countTokens()];int i = 0;while(tokener.hasMoreElements()){ result[i++] = tokener.nextToken();}for (String s : result) { System.out.println(s);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176面向对象设计原则**1.****单一职责原则**\- 在面向对象设计中，分工理论就是单一职责原则(Single Pesponsibility Prineiple, SRP) \- 两个含义 \- 避免相同的职责分散到不同的类中 \- 避免一个类承担太多职责 \- 为什么要遵循单一设计原则 \- 可以减少类之间的耦合：当需求变化时，只修改一个类，从而隔离了变化。 \- 提高类的复用性 \- 单一职责使得组件可以方便的拆卸和组装 \- 应用：用工厂模式来实现不同数据库操作类。**2.****接口隔离原则：**\- 接口隔离原则(Interface Segregation Principle, ISP): 客户端不应该被强迫实现不会使用的接口\- 接口隔离原则的主要观点 \- 一个类对另外一个类的依赖性应当是建立在最小的接口上 \- ISP 可以达到不强迫客户依赖于他们不使用的方法，接口的实现类应该只呈现为单一职责的角色(遵守SRP原则)。 \- ISP 还可降低客户端之间的相互影响——当某个客户程序要求提供新的职责(需求变更)而迫使接口发生改变时，影响到其他客户程序的可能性会是最小的。 \- 客户端程序不应该依赖它不需要的接口方法 \- ISP强调的是接口对客户端的承诺越少越好，并且要做到专一。 \- 接口污染：过于臃肿的接口设计是对接口的污染。接口污染就是为接口添加不必要的职责，如果开发人员在接口中增加一个新功能的主要目的只是减少接口实现类的数目，则此设计导致接口被不断的“污染” 并 “变胖” **3.****开放** **-** **封闭原则：** \- 开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。 \- 关闭：在模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。 \- 一个模块在扩展性方面应该是开放的，在更改性方面应该是封闭的。 \- 该原则的**核心是想是对抽象编程，而不是具体编程**，因为抽象相对稳定。 让类依赖于固定的抽象，这样的修改就是封闭的，通过面向对象的继承和多态机制，可以实现对抽象体的继承， 通过覆写其方法改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。 \- 在设计方面充分应用 抽象 和 封装 的思想。 \- 在系统功能编程实现方面应用面向接口的编程。**4.****替换原则** **：里氏替换原则****(Liskov Substiution Principle, LSP)****定义以及主要思想：子类型必须能够替换掉它们的父类型、**并出现在父类能够出现的任何地方。 \- 父类的方法都要在子类中实现或者重写, 派生类只实现其抽象类中声明的方法, 而不应当给出多余的方法定义或实现。 \- 在客户端程序中只应该出现父类对象，而不是直接使用子类对象, 这样可以实现运行期绑定(多态绑定)。**5.****依赖倒置原则：依赖倒置的核心原则是解耦，如果脱离这个最原始的原则，那就是本末倒置。**\- 将依赖关系倒置为依赖接口: \- 上层模块不应该依赖下层模块, 它们共同依赖于一个抽象。 \- 抽象不能依赖于具体, 具体应该要依赖于抽象 \- IOC(Inversion of Control) 是依赖倒置原则(Dependence Inversion Principle, DIP)的同义词。 \- DI: 依赖注入 \- DS: 依赖查找 \- 如何满足DIP: \- 每个较高层次类都为它所需要的服务提出一个接口声明, 较低层次实现这个接口 \- 每个高层类都通过该抽象接口使用服务**6.****深拷贝和浅拷贝：** 简单来讲就是复制、克隆；Person p=new Person(“张三”); 浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错 深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间**7.****值传递和引用传递：** 值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量 引用传递：就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改**8.web** **容器功能：** 通信支持、管理Servlet生命周期，多线程、将jsp转换成java等等**9.java****内存分配** 寄存器：我们无法控制 静态域：static定义的静态成员 常量池：编译时被确定并保存在.class文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符） 非ram存储：硬盘等永久存储空间 堆内存：new创建的对象和数组，由java虚拟机自动垃圾回收器管理,存取速度慢 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性**11.****一个****&quot;.java&quot;****源文件中是否可以包括多个类（不是内部类）？有什么限制？**可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。13.简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。 条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型 逻辑操作不会产生短路. 使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算**14.****说说****&amp;****和****&amp;&amp;****的区别。**==相同点==：&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。==&amp;&amp;具有短路功能==：即如果第一个表达式为false，则不再计算第二个表达式。举个列子1：对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException；如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。**15.switch****语句能否作用在****byte****上，能否作用在****long****上，能否作用在****String****上****?**在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。long不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它不能作用于swtich语句中。对于string而言：JDK1.7以前是不能作为switch的，以后即可以作用于switch中。**17.char****型变量中能不能存贮一个中文汉字****?****为什么****?**char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字。不过要注意的是：如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。**18.****用最有效率的方法算出****2****乘以****8****等於几****?**方法：将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8（2的3次方），只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是将2左移3位，即2 &lt;&lt; 3。**19.****使用****final****关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？**使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：final StringBuffer a=new StringBuffer(&quot;immutable&quot;);执行如下语句将报告编译期错误：a=new StringBuffer(&quot;&quot;);但是，执行如下语句则可以通过编译：a.append(&quot; broken!&quot;);java有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： public void method(final StringBuffer param) &#123; &#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(&quot;a&quot;);**20.java** **中对象的创建方法有几种？**通过new来创建通过反射创建通过复制创建**21.&quot;==&quot;****和****equals****方法究竟有什么区别？**如果是在object对象中，那么两者所表示的都是值是否相等（public boolean equals(Object obj)&#123;return (this==obj); &#125;）,可以看到object的equals方法是使用的“==”比较。一般而言，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符，也就是比较内存中所存储的两个变量的值是否相等。举例：String a=new String(&quot;foo&quot;); String b=new String(&quot;foo&quot;);它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。在实际开发中，我们经常要比较传递进行来的字符串内容是否等，此时是使用的equals（）方法。对于equals（）而言，默认情况是从object类继承的，当希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由自己写代码来决定在什么情况即可认为两个对象的内容是相同的。**22.****静态变量和实例变量的区别？**在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。、总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。举例：java 对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。 public static void main(String[] args) { public static int staticVar = 0; public int instanceVar = 0; public VariantTest() { staticVar++; instanceVar++; System.out.println(“staticVar =” + staticVar + ”,instanceVar =”+instanceVar); }}` 23.**是否可以从一个static方法内部发出对非static方法的调用？** 不可以。 对于static修饰的静态方法，是随着类的加载而加载，且调用的时可以不用创建对象而直接调用 非静态方法要与对象联系在一起，只有创建了对象了以后才能调用非静态方法，即当一个静态方法被调用的时候，有可能还没有创建任何实例对象。 24.Integer**与int的区别** int是java提供的8种原始数据类型之一，系统给的默认值为0。 Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。系统给的默认值为null。 即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况： 在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 25.Math.round(11.5)**等於多少? Math.round(-11.5)等於多少**? Math类中提供了三个与取整有关的方法：ceil（向上取整）、floor（向下取整）、round（四舍五入） 举例： Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11 Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12 算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 26.**下面的代码有什么不妥之处**? \1. if(username.equals(“zxx”){}； 2.int x = 1; return x==1?true:false; 答：第一个问题少了一个右括号;第二个问题没有错误 28.Overload**和Override的区别。Overload的方法是否可以改变返回值的类型**? Overload:表示方法重载，表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数、类型、位置不同），通过定义不同的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行： 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 不能通过访问权限、返回类型、抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 Override：表示方法重写（覆盖），表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，当通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。 重写的方法的标志必须要和被重写的方法的标志完全匹配，才能达到重写的效果； 重写的方法的返回值必须和被重写的方法的返回一致； 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类（因为子类是解决父类的一些方法，不能比父类更多问题）； 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写(子类方法的访问权限只能比父类的更大，不能更小)。 29.ClassLoader**如何加载**class 。 jvm里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap类加载负责加载jre/lib/rt.jar中的类， 我们平时用的jdk中的类都位于rt.jar中。extclassloader负责加载jar/lib/ext/*.jar中的类，appclassloader负责classpath指定的目录或jar中的类。除了bootstrap之外，其他的类加载器本身也都是java类，它们的父类是ClassLoader。 一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？ 如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关联。椅子与腿和背时组合关系。 说说has a与is a的区别 is-a表示的是属于继承关系，比如兔子属于一种动物（继承关系）。has-a表示组合，包含关系，比如兔子包含有腿，头等组件； Servlet的生命周期： init、 service、 destroy。 30.**分层设计的好处** 把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合,不会出现牵一发而动全身的问题了 分层的好处： 实现了软件之间的解耦； 便于进行分工 便于维护 提高软件组件的重用 便于替换某种产品，比如持久层用的是hibernate,需要更换产品用toplink，就不用该其他业务代码，直接把配置一改。 便于产品功能的扩展。 便于适用用户需求的不断变化 31.**序列化接口的id有什么用？** 对象经常要通过IO进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没有个统一的干法，于是，sun公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被sun的这种方案处理，必须实现Serializable接口。ObjectOutputStream.writeObject(obj);Object obj = ObjectInputStream.readObject(); 假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun的jdk就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错! 32.hashCode**方法的作用？** hashcode这个方法是用来鉴定2个对象是否相等的。 与equals（）方法的区别： 简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了 hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。 hashcode相当于是一个对象的编码，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。 ==举例==：有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这2个对象是相等的。如果姓名和性别相等就算2个对象相等的话，那么hashcode的方法也要返回姓名的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。++要从物理上判断2个对象是否相等，用==就可以了。++ 33.**构造器Constructor是否可被**override? 重写发生在继承过程中（子父类间），但是构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。 34.**接口是否可继承接口**? 抽象类是否可实现**(implements)接口? 抽象类是否可继承具体类**(concrete class)? 抽象类中是否可以有静态的**main**方法？ 接口是特殊的抽象类，他是多态的经典体现。 抽象类是指具有抽象方法的类，该类中出了有抽象方法外，其他普通方法具有的属性抽象方法都有。他们的唯一区别就是不能创建实例对象和允许有abstract方法； 因此：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类。抽象类中可以有静态的main方法。 题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串 所以，上面的代码应该只创建了一个String对象(编译优化后的结果)。写如下两行代码，最终打印的结果应该为true。 String s = “a” + “b” + “c” + “d”; System.out.println(s == “abcd”); 结论：**finally中的代码比return 和break语句后执行，只要JVM中没有遇到system.exition的异常，是JVM直接退出，那么finally都会被执行**。 6.final, finally, finalize**的区别。** final：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承，内部类要访问局部变量，局部变量必须定义成final类型。 finally：是异常处理语句结构的一部分，表示总是执行，除非是遇到重大错误error，才不会执行finally。 finalize：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。 7.**运行时异常与一般异常有何异同？** 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常（程序在虚拟机上运行时发生的非正常状态），是一种常见运行错误。 java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 8.error**和exception有什么区别**? error：表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception： 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 9.Java**中的异常处理机制的简单原理和应用。** 异常是指java程序运行时（非编译）所发生的非正常情况或错误，Java使用面向对象的方式来处理异常，它把程序中发生的每s个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。 所有异常的根类为java.lang.Throwable：Throwable下面又派生了两个子类：Error和Exception。 Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了（内存溢出和线程死锁等系统问题）。 Exception表示程序还能够克服和恢复的问题： 其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉。 普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。 java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。 提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。 10.Throwable**：异常的父类。** error :jvm严重错误，JVM无法继续，因此这是不可捕捉无法用程序去恢复的错误。 exception： 可以捕获到，可以恢复。 cheched exception：IO/SQL异常，JVM要求我们对出现的异常进行catch。 runtime exception：运行时异常，我们可以不处理，将其抛出最后可以抛给JVM处理，多线程由thread.run()抛出，单线程由main（）函数抛出。运行时异常也有一般异常的子类，可以被catch到，如果不对其处理，要么线程终止，要么主线程终止（异常的处理目标就是将异常程序恢复正常）。 11.**请写出你最常见到的5个runtime exception。** 在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。 ArrayindexOfBoundsException：数组越界异常。 NullPointerException：空指针异常。 ClassCastException：类型转换异常。 ClassNotFoundException：指定类不存在。 ArithmeticException：数字运算异常。 ArrayStoreException：数组存储与声明类型不兼容。 numberFormatException：数字格式异常。 12.Java**语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？** Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。 try：指定一块预防所有”异常”的程序。 cache：紧跟在try程序后面，用来指定想要捕捉的”异常”的类型。 throw：不处理异常，直接明确地抛出一个”异常”，给上一层处理。 finally：确保一段代码不管发生什么”异常”都被执行一段代码。 13.java**中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？** java5以前，有如下两种： 第一种(继承)： new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下： new Thread(){ public void run(){ } }.start(); 第二种（实现接口）： new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下： new Thread(new Runnable(){ public void run(){ } } ).start(); 从java5开始，还有如下一些线程池创建多线程的方式： ExecutorService pool = Executors.newFixedThreadPool(3) for(int i=0;i&lt;10;i++){ pool.execute(new Runable(){ public void run(){ } }); } Executors.newCachedThreadPool().execute(new Runable(){ public void run(){ } }); Executors.newSingleThreadExecutor().execute(new Runable(){ public void run(){ } }); 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。 suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。 对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 用synchronized关键字修饰同步方法。 14.sleep() 和 wait() 有什么区别**?** sleep: 就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行。 如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。 wait: 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行。 只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。 如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。 15.**同步和异步有何异同，在什么情况下分别使用他们？举例说明。** 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 16.**同步有几种实现方法**? 同步的实现方面有两种，分别是synchronized,wait与notify。 wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 17.**当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法**? 其他方法前是否加了synchronized关键字，如果没加，则能。 如果这个方法内部调用了wait，则可以进入其他synchronized方法。 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。 18.**线程的基本概念、线程的基本状态以及状态之间的关系。** 好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。 状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。 19.**简述synchronized和java.util.concurrent.locks.Lock的异同？** 主要相同点：Lock能完成synchronized所实现的所有功能。 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 举例说明（对下面的题用lock进行了改写）： package com.huawei.interview; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ThreadTest { private int j; private Lock lock = new ReentrantLock(); public static void main(String[] args) { // TODO Auto-generated method stub ThreadTest tt = new ThreadTest(); for(int i=0;i&lt;2;i++) { new Thread(tt.new Adder()).start(); new Thread(tt.new Subtractor()).start(); } } private class Subtractor implements Runnable { @Override public void run() { // TODO Auto-generated method stub while(true) { lock.lock(); try { System.out.println(“j–=” + j–); }finally { lock.unlock(); } } } } private class Adder implements Runnable { @Override public void run() { while(true) { /synchronized (ThreadTest.this) { System.out.println(“j++=” + j++); }/ lock.lock(); try { System.out.println(“j++=” + j++); }finally { lock.unlock(); } } } } } 1.**你所知道的集合类都有哪些？主要方法？** 最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。 List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。 map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合， map也有get方法，参数是key，返回值是key对应的value。 2.**介绍Collection框架的结构。** 集合框架(Collection Framework)泛指java.util包的若干个类和接口。如Collection，List，ArrayList，LinkedList，Vector(自动增长数组),HashSet,HashMap等。 集合框架中的类主要封装的是典型的数据结构,如动态数组,链表,堆栈,集合，哈希表等。 集合框架类似编程中经常用到的工具类，使得编码这专注于业务层的实现，不需要从底层实现相关细节—“数据结构的封装”和”典型算法的实现”。 3.Comparable**和Comparator接口是干什么的。** Java提供了只包含一个compareTo()方法的Comparable接口。 这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。 只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时 候，这个方法才返回true。 4.Collection**框架中实现比较要实现什么接口。** SortedSet和SortedMap接口对元素按指定规则排序。 SortedMap是对key列进行排序要实现 comparable 接口,把你的自定义类实现以上接口，实现 compareTo方法就OK了。 5.comparable/comparator**区别。** 用Comparable简单,只要实现Comparable接口的对象直接就成为一个可以比较的对象但是需要修改源代码。 用Comparator的好处是不需要修改源代码,而是另外实现一个比较器,当某个自定义的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。 6.List 和 Map 区别**?** List：是存储单列数据的集合，List中存储的数据是有顺序，并且允许重复。 Map：是存储键和值这样的双列数据的集合；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 7.List**、Map、Set三个接口，存取元素时，各有什么特点？** List与Set都是单列元素的集合，它们有一个共同的父接口Collection。 List 以特定次序来持有元素，可有重复元素。 Set 无法拥有重复元素,内部排序. Map 保存key-value值，value可多值。 Set里面不允许有重复的元素。 存元素：add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true；当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。 取元素：没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 List表示有先后顺序的集合。 存元素：多次调用add(Object)方法时，每次加入的对象按先来后到的顺序排序，也可以插队，即调用add(int index,Object)方法，就可以指定当前对象在集合中的存放位置。 取元素：方法1：Iterator接口取得所有，逐一遍历各个元素。 Map是双列的集合。 Map是双列的集合，存放用put方法:put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。 取元素：用get(Object key)方法根据key获得相应的value。也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获得key和value组合成的Map.Entry对象的集合。 注意： HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65在hashSet中的存储顺序不是62,65,78，LinkedHashSet按插入的顺序存储。 那被存储对象的hashcode方法还有什么作用呢？hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。 同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。 8.ArrayList**和Vector的区别。** 这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，数据是允许重复的. 这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。 ArrayList与Vector的区别，这主要包括两个方面。 数据增长： 同步性： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次增加多个存储单元，增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。 Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 Vector是线程安全的，而ArrayList是线程序不安全的 对于Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。 9.**能创建 volatile 数组吗？** 可以，但是创建的对象或数组的地址具有可见性，里面的数据是不可见的。 10.**去掉一个Vector集合中重复的元素。** 方法一：HashSet set = new HashSet(vector); 方法二： Vector newVector = new Vector(); for (int i=0;i&lt;vector.size();i++) { Object obj = vector.get(i); if(!newVector.contains(obj); //不包含 newVector.add(obj); } 11.**说出ArrayList,Vector, LinkedList的存储性能和特性。** ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。 而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 12.Collection 和 Collections**的区别。** Collection是集合类的上级接口，继..承于他的接口主要有Set 和List。 Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 13.Set**里的元素是不能重复的，那么用什么方法来区分重复与否呢**? 是用**==还是equals()? 它们有何区别**? Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。 Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 equals()和==方法决定引用值是否指向同一对象，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 14.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对? 对。 如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。 如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的。 例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。 15.TreeSet**里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！** 当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的。 实验代码 public class Parent implements Comparable { private int age = 0; public Parent(int age){ this.age = age; } public int compareTo(Object o) { System.out.println(“method of parent”); Parent o1 = (Parent)o; return age&gt;o1.age?1:age&lt;o1.age?-1:0; } } public class Child extends Parent { public Child(){ super(3); } public int compareTo(Object o) { System.out.println(“method of child”); return 1; } } public class TreeSetTest { public static void main(String[] args) { TreeSet set = new TreeSet(); set.add(new Parent(3)); set.add(new Child()); set.add(new Parent(4)); System.out.println(set.size()); } } 16.**快速失败(fail-.fast)和安全失败(fail-.safe)的区别是什么？** Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。 java.util 包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 17.HashMap**和Hashtable的区别。** HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 就HashMap与Hashtable主要从三方面来说。 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。 值：只有HashMap可以让你将空值作为一个表的条目的key或value。 18.HashMap**的数据结构。** 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）。 所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。 Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“）。 19.HashMap**的工作原理是什么**? Java中的HashMap是以键值对(key-.value)的形式存储元素的。 HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。 当调用put() 方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。 如果key已经存在了，value会被更新成新值。 HashMap的一些重要的特性是它的容量 (capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 20.HashMap**什么时候进行扩容呢？** java 当HshMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75， 也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍， 然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的， 因为0.751000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 21.HashSet**的底层实现是什么**? 通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。 在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。 22.CorrentHashMap**的工作原理**? 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。 23.LinkedHashMap**的实现原理**? LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。 LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。 LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。 一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。 24.**数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是 ArrayList**？ Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。 ArrayList处理固定大小的基本数据类型的时候，这种方式相对比较慢。 25.Java**集合类框架的最佳实践有哪些？** 假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现 hashCode()和equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 26.**为什么集合类没有实现Cloneable和Serializable接口？** 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。 因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。 28.Iterator**和ListIterator的区别是什么？** Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 2**）HashMap的底层实现，之后会问ConcurrentHashMap的底层实现** HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。允许使用null值和null键。 ConcurrentHashMap基于双数组和链表的Map接口的同步实现 ConcurrentHashMap中元素的key是唯一的、value值可重复 ConcurrentHashMap不允许使用null值和null键 ConcurrentHashMap是无序的 为什么使用ConcurrentHashMap： 我们都知道HashMap是非线程安全的，当我们只有一个线程在使用HashMap的时候，自然不会有问题，但如果涉及到多个线程，并且有读有写的过程中，HashMap就会fail-fast。要解决HashMap同步的问题，我们的解决方案有:Hashtable 、Collections.synchronizedMap(hashMap) 这两种方式基本都是对整个hash表结构加上同步锁，这样在锁表的期间，别的线程就需要等待了，无疑性能不高，所以我们引入ConcurrentHashMap，既能同步又能多线程访问 ConcurrentHashMap的数据结构： ConcurrentHashMap的数据结构为一个Segment数组，Segment的数据结构为HashEntry的数组，而HashEntry存的是我们的键值对，可以构成链表。可以简单的理解为数组里装的是HashMap 6**）wait和sleep的区别，必须理解** sleep方法属于线程，wait方法属于对象 sleep休眠当前线程，不会释放对象锁，wait使当前线程进入等待状态，释放对象锁，只有针对此对象调用notify()方法（且共享对象资源释放）后本线程才会继续执行 7**）JVM的内存结构，JVM的算法** JVM内存结构主要有三大块：堆内存、方法区和栈，几乎所有的对象实例都存放在堆里，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 15**）说说http,https协议** http是一种超文本协议，默认端口80，以明文传输。 https是http协议的安全版，安全基础是SSL，以密文传输 16**）osi五层网络协议** 应用层、传输层、网络层、数据链路层、物理层 18**）说说tcp三次握手，四次挥手** 1.客户端向服务器发送一个syn包，进入发送状态 2.服务器收到syn包，确认客户的syn，并向客户端发送syn+ack包，进入接受状态 3.客户端接受的来自服务的的syn包信息，向服务的发出ack包，次数两者进入tcp连接成功状态 21**）请写一段栈溢出、堆溢出的代码** 堆溢出，死循环存值，JVM就会抛出OutOfMemoryError:java heap space异常 public static void main(String[] args) { List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); int i=0; while(true){ list.add(new byte[510241024]); System.out.println(“分配次数：”+(++i)); } } 栈溢出，栈空间不足——StackOverflowError实例 public class StackSOFTest { int depth = 0; public void sofMethod(){ depth ++ ; sofMethod(); } public static void main(String[] args) { StackSOFTest test = null; try { test = new StackSOFTest(); test.sofMethod(); } finally { System.out.println(“递归次数：”+test.depth); } } } 29.**说出一些常用的类，包，接口，请各举5个。** 注意：要让人家感觉你对java ee开发很熟，java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。 常用的类： BufferedReader BufferedWriter FileReader FileWirter String Integer java.util.Date System Class List HashMap 常用的包： java.lang java.io java.util java.sql javax.servlet org.apache.strtuts.action org.hibernate 常用的接口： Remote List Map Document NodeList Servlet HttpServletRequest HttpServletResponse Transaction(Hibernate) Session(Hibernate) HttpSession 30.java**中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？** 字节流，字符流。 字节流继承于InputStream OutputStream。 OutputStream提供的方法： void write(int b):写入一个字节的数据。 void write(byte[] buffer):将数组buffer的数据写入流。 void write(byte[] buffer,int offset,int len):从buffer[offset]开始，写入len个字节的数据。 void flush():强制将buffer内的数据写入流。 void close():关闭流。 InputStream提供的方法： int read():读出一个字节的数据，如果已达文件的末端，返回值为－1。 int read(byte[] buffer):读出buffer大小的数据，返回值为实际所读出的字节数。 int read(byte[] buffer,int offset,int len)。 int available():返回流内可供读取的字节数目。 long skip(long n):跳过n个字节的数据，返回值为实际所跳过的数据数。 void close():关闭流。 字符流继承于InputStreamReader OutputStreamWriter。 在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。 31.**字节流与字符流的区别。** IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。 计算机中的一切最终都是二进制的字节形式存在，对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，java提供了字符流的包装类。 底层设备永远只接受字节数据， 32.**什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。** 有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，（例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输），但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。 需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。 例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。 33.**描述一下JVM加载class文件的原理机制**? Java语言是一种具有动态性的解释型语言，类（class）只有被加载到JVM后才能运行。当运行指定程序时，JVM会将编译生成的.class文件按照需求和一定的规则加载到内存中，并组织成为一个完整的Java应用程序，这个加载过程是由类加载器完成。 具体来说，就是由ClassLoader和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。 类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用new等方式创建对象时，会隐式地调用类的加载器把对应的类加载到JVM中。显示加载指的是通过直接调用class.forName()方法来把所需的类加载到JVM中。 任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到JVM中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。 此外，在Java语言中，每个类或接口都对应一个.class文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。 在Java语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到JVM中，至于其他类，则在需要的时候才加载：下面是加载的步骤： 初始化。对静态变量和静态代码块执行初始化工作。 装载。根据查找路径找到相应的class文件，然后导入。 链接。链接又可分为3个小步： 检查，检查待加载的class文件的正确性。 准备，给类中的静态变量分配存储空间。 解析，将符号引用转换为直接引用（这一步可选）。 方法中的局部变量使用final修饰后，放在堆中，而不是栈 35.**堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？** 堆栈都是内存的可用区域，但是堆的速度慢容量大，栈的速度快容量小。一个64K的字符串，自然放在堆。栈的内存是很宝贵的。 只有引用及基本数据类型是直接存在栈上。对象类型可能是在堆、方法区、常量池中；放到堆中还是放到栈中，jvm会根据你的数据类型决定。 栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） ：一般由程序员分配释放， 若程序员不释放，程序结束时可能由GC回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 36.GC**是什么**? 为什么要有**GC?** GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃。 Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 37.**垃圾回收的优点和原理。并考虑2种回收机制。** Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。 优点： 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。 垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不用实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 38.**垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？** 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。 通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。 不过垃圾回收机制的回收是不确定的，不一定会马上回收内存。 可以主动通知虚拟机进行垃圾回收：程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。实际上GC是一个守护线程(守护线程的作用是为其他线程提供服务)。 39.**什么时候用assert？** assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。 在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。 一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 public class AssertTest { public static void main(String[] args) { int i = 0; for(i=0;i&lt;5;i++) { System.out.println(i); } //假设程序不小心多了一句–i; –i; assert i==5; } } 40.java**中会存在内存泄漏吗，请简单描述。** 所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。 由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收： java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景(通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的）。 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 内存泄露的另外一种情况：当一个对象被存储进**HashSet**集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 41.**能不能自己写个类，也叫java.lang.String？** 可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。 但是在实际应用中，这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。 虽然java提供了endorsed技术，可以覆盖jdk中的某些类。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类。 package java.lang; public class String { public static void main(String[] args) { System.out.println(“string”); } } 报告的错误如下： java.lang.NoSuchMethodError: main Exception in thread “main” 这是因为加载了jre自带的java.lang.String，而该类中没有main方法。 194.说一下 jvm 的主要组成部分？及其作用？ 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 组件的作用: 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 195. 说一下 jvm 运行时数据区？ 程序计数器 虚拟机栈 本地方法栈 堆 方法区 有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。 196.说一下堆栈的区别？ 栈内存存储的是局部变量而堆内存存储的是实体； 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。 197.队列和栈是什么？有什么区别？ 队列和栈都是被用来预存储数据的。 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。 栈和队列很相似，但它运行对元素进行后进先出进行检索。 198.什么是双亲委派模型？ 在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 类加载器分类： 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库； 其他类加载器： 扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=“box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;”&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt; 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 \199. 说一下类加载的执行过程？ 类加载分为以下 5 个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 检查：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 200.怎么判断对象是否可以被回收？ 一般有两种方法来判断： 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 201. java 中都有哪些引用类型？ 强引用 软引用 弱引用 虚引用 202. 说一下 jvm 有哪些垃圾回收算法？ 标记-清除算法 标记-整理算法 复制算法 分代算法 203.**说一下 jvm 有哪些垃圾回收器？** Serial：最早的单线程串行垃圾回收器。 Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。 ParNew：是 Serial 的多线程版本。 Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。 CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。 204.**详细介绍一下 CMS 垃圾回收器？** CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 205.**新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？** 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 206. 简述分代垃圾回收器是怎么工作的？ 分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。 207.**说一下 jvm 调优的工具？** JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。 jconsole：用于对 JVM 中的内存、线程和类等进行监控； jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。 \208. 常用的 jvm 调优的参数都有哪些？ -Xms2g：初始化推大小为 2g； -Xmx2g：堆最大内存为 2g； -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4； -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2； –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合； -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合； -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合； -XX:+PrintGC：开启打印 gc 信息； -XX:+PrintGCDetails：打印 gc 详细信息。 2.**你所知道网络协议有那些？** HTTP：超文本传输协议 FTP：文件传输协议 SMPT：简单邮件协议 TELNET：远程终端协议 POP3：邮件读取协议 3.Java**都有那些开发平台？** JAVA SE：主要用在客户端开发 JAVA EE：主要用在web应用程序开发 JAVA ME：主要用在嵌入式应用程序开发 4.**什么是JVM？java虚拟机包括什么？** JVM：java虚拟机，运用硬件或软件手段实现的虚拟的计算机，Java虚拟机包括：寄存器，堆栈，处理器 5.Java**是否需要开发人员回收内存垃圾吗？** 大多情况下是不需要的。Java提供了一个系统级的线程来跟踪内存分配，不再使用的内存区将会自动回收 7.**什么是数据结构？** 计算机保存，组织数据的方式 8.Java**的数据结构有那些？** 线性表（ArrayList） 链表（LinkedList） 栈（Stack） 队列（Queue） 图（Map） 树（Tree） 9.**什么是OOP?** 面向对象编程 10.**什么是面向对象？** 世间万物都可以看成一个对象。每个物体包括动态的行为和静态的属性，这些就构成了一个对象。 11.**类与对象的关系?** 类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例 12.Java**中有几种数据类型** 整形：byte,short,int,long 浮点型：float,double 字符型：char 布尔型：boolean 13.**什么是隐式转换，什么是显式转换** 显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。 14.Char**类型能不能转成int类型？能不能转化成string类型，能不能转成double类型** Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；Char&lt;int&lt;long&lt;float&lt;double；Char类型可以隐式转成int,double类型，但是不能隐式转换成string；如果char类型转成byte，short类型的时候，需要强转。 15.**什么是拆装箱？** 拆箱：把包装类型转成基本数据类型 装箱：把基本数据类型转成包装类型 16.Java**中的包装类都是那些？** byte：Byte short：Short int：Integer long：Long float：Float double：Double char：Character boolean：Boolean 17.**一个java类中包含那些内容？** 属性、方法、内部类、构造方法、代码块。 18.**例如： if(a+1.0=4.0)，这样做好吗？** 不好，因为计算机在浮点型数据运算的时候，会有误差，尽量在布尔表达式中不使用浮点型数据(if,while,switch中判断条件不使用浮点型) 19.**那针对浮点型数据运算出现的误差的问题，你怎么解决？** 使用Bigdecimal类进行浮点型数据的运算 20.++i**与i++的区别** ++i：先赋值，后计算 i++：先计算，后赋值 21.**程序的结构有那些？** 顺序结构 选择结构 循环结构 22.**数组实例化有几种方式？** 静态实例化：创建数组的时候已经指定数组中的元素, int[] a=new int[]{1,3,3} 动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值 23.Java**中各种数据默认值** Byte,short,int,long默认是都是0 Boolean默认值是false Char类型的默认值是’’ Float与double类型的默认是0.0 对象类型的默认值是null 24.Java**常用包有那些？** Java.lang Java.io Java.sql Java.util Java.awt Java.net Java.math 25.Java**最顶级的父类是哪个？** Object 26.Object**类常用方法有那些？** Equals Hashcode toString wait notify clone getClass 28.java**中是值传递引用传递？** 理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。 29.**假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？** 改变了，因为传递是对象的引用，操作的是引用所指向的对象 30.**实例化数组后，能不能改变数组长度呢？** 不能，数组一旦实例化，它的长度就是固定的 31.**假设数组内有5个元素，如果对数组进行反序，该如何做？** 创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中 32.**形参与实参** 形参：全称为“形式参数”，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值； 实参：全称为“实际参数”，是在调用方法时传递给该方法的实际值。 33.**构造方法能不能显式调用？** 不能 构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用 36.**内部类与静态内部类的区别？** 静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法； 普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。 如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象 37.Static**关键字有什么作用？** Static可以修饰内部类、方法、变量、代码块 Static修饰的类是静态内部类 Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。 Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。 Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。 38.Final**在java中的作用** Final可以修饰类，修饰方法，修饰变量。 修饰的类叫最终类。该类不能被继承。 修饰的方法不能被重写。 修饰的变量叫常量，常量必须初始化，一旦初始化后，常量的值不能发生改变。 39.Java**中操作字符串使用哪个类？** String，StringBuffer，StringBuilder 42.String str=”aa”,String s=”bb”,String aa=aa+s;**一种创建了几个对象？** 一共有两个引用，三个对象。因为”aa”与”bb”都是常量，常量的值不能改变，当执行字符串拼接时候，会创建一个新的常量是” aabbb”,有将其存到常量池中。 43.**将下java中的math类有那些常用方法？** Pow()：幂运算 Sqrt()：平方根 Round()：四舍五入 Abs()：求绝对值 Random()：生成一个0-1的随机数，包括0不包括1 46.==**与equlas有什么区别？** ==可以判断基本数据类型值是否相等，也可以判断两个对象指向的内存地址是否相同，也就是说判断两个对象是否是同一个对象，Equlas通常用来做字符串比较。 53.**创建一个子类对象的时候，那么父类的构造方法会执行吗？** 会执行。当创建一个子类对象，调用子类构造方法的时候，子类构造方法会默认调用父类的构造方法。 54.**什么是父类引用指向子类对象？** 是java多态一种特殊的表现形式。创建父类引用，让该引用指向一个子类的对象 55.**当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？** 子类重写了父类方法和属性，访问的是父类的属性，调用的是子类的方法 60.**抽象类可以使用final修饰吗？** 不可以。定义抽象类就是让其他继承的，而final修饰类表示该类不能被继承，与抽象类的理念违背了 61.**普通类与抽象类有什么区别？** 普通类不能包含抽象方法，抽象类可以包含抽象方法 抽象类不能直接实例化，普通类可以直接实例化 63.JAVA**为什么需要接口？** 接口弥补了java单继承的缺点 64.**接口有什么特点？** 接口中声明全是public static final修饰的常量 接口中所有方法都是抽象方法 接口是没有构造方法的 接口也不能直接实例化 接口可以多继承 66.Java**中异常分为哪两种？** 编译时异常 运行时异常 67.**说几个常见的编译时异常类？** NullPointerException：空指针异常 ArrayIndexOutOfBoundsException：数组下标越界 NumberFormatException：数字转换异常 IllegalArgumentException：参数不匹配异常 InstantiationException：对象初始化异常 ArithmeticException：算术异常 68.**异常的处理机制有几种？** 异常捕捉：try…catch…finally，异常抛出：throws。 69.**如何自定义一个异常** 继承一个异常类，通常是RumtimeException或者Exception 70.**在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？** 会执行，如果有finally，在finally之后被执行，如果没有finally，在catch之后被执行 72.Thow**与thorws区别** Throw写在代码块内，throws后面跟的是一个具体的异常实例 Throw写在方法前面后面，throws后面跟的是异常类，异常类可以出现多个 74.**使用Log4j对程序有影响吗？** 有，log4j是用来日志记录的，记录一些关键敏感的信息，通常会将日志记录到本地文件或者数据库中。记录在本地文件中，会有频繁的io操作，会耗费一些系统资源。记录在数据库中，会频繁地操作数据库表，对系统性能也有一定的影响。但是为了程序安全以及数据的恢复或者bug的跟踪，这点资源消耗是可以承受的。 75.Log4j**日志有几个级别？** 由低到高：debug、info、wran、error 77.Java**反射创建对象效率高还是通过new创建对象的效率高？** 通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低 79.Collection**接口下有那些集合框架？** List：线性表、Set：无序集合。 85.JDBC**操作的步骤** 加载数据库驱动类 打开数据库连接 执行sql语句 处理返回结果 关闭资源 86.**在使用jdbc的时候，如何防止出现sql注入的问题。** 使用PreparedStatement类，而不是使用Statement类 87.**怎么在JDBC内调用一个存储过程** 使用CallableStatement 88.**是否了解连接池，使用连接池有什么好处？** 数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。 89.**你所了解的数据源技术有那些？使用数据源有什么好处？** Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全；通过配置文件的形式来维护数据库信息，而不是通过硬编码。当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据库信息的更新。 91.**常用io类有那些？** File FileInputSteam，FileOutputStream BufferInputStream，BufferedOutputSream Print Write FileReader，FileWriter BufferReader，BufferedWriter ObjectInputStream，ObjectOutputSream 92.**字节流与字符流的区别** 以字节为单位输入输出数据，字节流按照8位传输 以字符为单位输入输出数据，字符流按照16位传输 93.final**、finalize()、finally** 性质不同 final为关键字； finalize()为方法； finally为区块标志，用于try语句中； 作用 final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）； finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）； finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行； 99.**如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？** 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 3、什么是单例模式？实现步骤？ 单例模式保证了对象唯一。分为懒汉式（在类加载时不初始化）和饿汉式（在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快）。 实现步骤：私有化构造函数、创建一个静态的私有对象、提供公共的访问方法。 10、什么是 ThreadLocal？ThreadLocal 和 Synchonized 的区别？ 线程局部变量。是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。 synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而 ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级_注解]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E9%AB%98%E7%BA%A7-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java高级_注解@SafeVarargs 挺有意思的一个注解 @SafeVarargs 这是1.7 之后新加入的基本注解. 如例所示，当使用可变数量的参数的时候，而参数的类型又是泛型T的话，就会出现警告。 这个时候，就使用@SafeVarargs来去掉这个警告 @SafeVarargs注解只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。一个方法使用@SafeVarargs注解的前提是，开发人员必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题。 1234567public class User &#123; @SafeVarargs public static &lt;T&gt; T getData(T... ds) &#123; return ds.length &gt; 0 ? (T) ds[0] : null; &#125;&#125; 自定义注解创建1234567@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface MyNote &#123; String name() default "zhw";&#125; 使用自定义注解1234567891011121314151617@MyNote(name = "zhwzhw")class Util &#123;&#125;public class NoteTest &#123; public static void main(String[] args) &#123; test1(); &#125; public static void test1() &#123; //反射获取注解 MyNote myNote = Util.class.getAnnotation(MyNote.class); // 获取方法 String name = myNote.name(); System.out.println(name); &#125;&#125; 结果: zhwzhw 相信刚刚接触的人一定很茫然 那么接下来讲解一下其中的元注解 元注解 元注解 @Target@Retention@Inherited@Documented@Repeatable (java1.8 新增) 有这么五种 @Target @Target 表示这个注解能放在什么位置上 12345678910111213141516171819@Target(&#123; // 能修饰包 ElementType.PACKAGE, // 能修饰类、接口或枚举类型 ElementType.TYPE, ElementType.TYPE_USE, ElementType.TYPE_PARAMETER, // 能修饰构造器 ElementType.CONSTRUCTOR, // 能修饰方法 ElementType.METHOD, // 能修饰成员变量 ElementType.FIELD, // 能修饰局部变量 ElementType.LOCAL_VARIABLE, // 能修饰参数 ElementType.PARAMETER, // 能修饰注解 ElementType.ANNOTATION_TYPE&#125;) @Retention 表示生命周期 只能选择一个生命周期 下面是错误的写法,只是方便说明而已 1234567@Retention(&#123; // 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了 RetentionPolicy.CLASS, // 注解在运行起来之后依然存在，程序可以通过反射获取这些信息 RetentionPolicy.RUNTIME, // 注解只在源代码中存在，编译成class之后，就没了 RetentionPolicy.SOURCE&#125;) @Inherited 表示该类有继承性 @Documented 在用javadoc命令生成API文档后，该文档里会出现该注解说明 @Repeatable 当没有@Repeatable修饰的时候，注解在同一个位置，只能出现一次 1234567891011121314151617181920212223@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Names &#123; FileType[] value();&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@Repeatable(Names.class)public @interface FileType &#123; String value();&#125;@FileType( ".java" ) @FileType( ".html" ) @FileType( ".css" ) @FileType( ".js" ) public void work()&#123; &#125;]]></content>
      <categories>
        <category>java</category>
        <category>java高级_注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级_反射机制]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E9%AB%98%E7%BA%A7-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java高级_反射机制类对象获取 先创建对象类 123456789101112131415161718192021222324class User &#123; public String name; private String sex; static String str; static &#123; str = "已经初始化!"; System.out.println("初始化..." + str); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "User [name=" + name + ", sex=" + sex + "]"; &#125;&#125; 有三种方式获取 1234567891011121314public static void test1() throws Exception &#123; // 初始化类静态属性 Class c1 = Class.forName("zhw.base.User"); System.out.println(c1); // 不会初始化类静态属性 Class c2 = User.class; System.out.println(c2); // 初始化类静态属性 Class c3 = new User().getClass(); System.out.println(c3); &#125; 通过反射创建对象12345678public static void test2() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); &#125; 通过反射修改对象属性值 getField只能获取public属性,包括继承的属性 getDeclaredField可以获取本类所有属性 12345678910111213141516171819public static void test3() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); // 获取对象属性 // getField只能获取public属性,包括继承的属性 Field f1 = cci.getClass().getField("name"); // getDeclaredField可以获取本类所有属性 Field f2 = cci.getClass().getDeclaredField("sex"); f2.setAccessible(true); // 设置值 f1.set(cci, "zhw"); f2.set(cci, "man"); System.out.println(cci); &#125; 通过反射调用对象方法123456789101112131415public static void test4() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); // 反射获取对象方法 Method m = cci.getClass().getMethod("setName", String.class); // 调用方法 m.invoke(cci, "zhw"); System.out.println(cci.getName()); &#125;]]></content>
      <categories>
        <category>java</category>
        <category>java高级_反射机制</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_Lamda-Stream]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-Lamda-Stream%2F</url>
    <content type="text"><![CDATA[Java中级_Lamda-StreamLamda规则: 接口必须是函数式接口---@FunctionalInterface 接口里面只能够存在一个抽象方法 java8还有个特性就是如果你的接口中没有抽象方法，但有个默认(default)方法，它也是函数式接口 语法: - 简写模式: (参数列表）-&gt; 方法主体 -无参模式: () -&gt; 方法主体 - 非简写模式：（参数列表）-&gt; {方法主体;} Stream三步骤:创建流 - 中间操作 - 最终操作 创建流流的创建有两种方式。 如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。 如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流； 123456789101112131415161718192021public static void test1() &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); ls.add("zz"); ls.add("aa"); ls.add("bb"); System.out.println(ls); List&lt;String&gt; bs = Arrays.asList("bb","cc","dd"); System.out.println(bs); // 集合直接使用stream()方法创建流 Stream&lt;String&gt; stream = ls.stream(); bs.stream(); // 数组 // 使用Arrays工具类stream()方法创建 String[] js = &#123;"aa","cc","bb"&#125;; Stream&lt;String&gt; stream2 = Arrays.stream(js); // 使用Stream类of()方法创建 Stream&lt;String&gt; stream3 = Stream.of("aa","bb","cc"); &#125; 中间操作 filter (过滤) map (映射) sorted (排序) distinct (去重) limit / skip (限制) filter (过滤) 根据判断条件过滤元素 123List&lt;UserDO&gt; resultList = userList.stream() .filter(user -&gt; user.id != 0) .collect(Collectors.toList()); map (映射) 映射每个元素到对应的方法 123List&lt;String&gt; bs = Arrays.asList("bb","cc","dd","cc"); System.out.println("map=========="); bs.stream().map(i -&gt; i+"未知数").forEach(System.out::println); 结果: map= = = = = = =bb未知数cc未知数dd未知数cc未知数 sorted (排序) 按条件进行排序 123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1);System.out.println("sorted==========");ls.stream().sorted().forEach(System.out::println); 结果: sorted= = = = = = = = = =135 distinct (去重) 去除集合或者数组中重复得数据 12Stream&lt;String&gt; s3 = Stream.of("aa","bb","cc" ,"cc");s3.distinct().forEach(System.out::println); 结果: aabbcc limit/skip limit 返回 Stream 的前面 n 个元素； skip 则是扔掉前 n 个元素。 limit123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1);System.out.println("limit==========");ls.stream().limit(1).forEach(System.out::println); 结果: limit = = = = = = = = = =3 skip123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1); System.out.println("skip= = = = = = = = = =");ls.stream().skip(1).forEach(System.out::println); 结果 skip= = = = = = = = = =51 最终操作 匹配 anyMatch() - - 根据条件返回是否有匹配的结果 allMatch() – 只要有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回true。 noneMatch() – 只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。 组合 reduce() - -把元素组合起来 计数 count() max() min() 迭代 forEach() 汇总 collect() –将流中的元素汇总 匹配1boolean isFound = userList.stream() .anyMatch(user -&gt; Objects.equals(user.getId(), userId)); 组合123List&lt;Integer&gt; nums = Arrays.asList(1, 2, 5, 4); int result = nums.stream().reduce(10,(a, c) -&gt; a + c); System.out.println(result); 结果:22]]></content>
      <categories>
        <category>java</category>
        <category>java中级_lamda-stream</category>
      </categories>
      <tags>
        <tag>lamda</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_网络编程]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java中级_网络编程OSI与TCP/IP体系模型OSI体系结构 OSI体系结构 7.应用层 6.表示层 5.会话层 4.传输层 3.网络层 2.数据链路层 1.物理层 TCP/IP体系结构 TCP/IP体系结构 4.应用层(协议:Telnet,FTP,SMTP…) 3.传输层(TCP/UDP) 2.网际层IP 1.网络接口层 TCP是 Tranfer Control Protocol 的简称; 是一种面向连接的保证可靠传输的协议. UDP是 User Datagram Protocol 的简称 是一种无连接的协议. TCP/UDP比较：UDP： 每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。 UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。 TCP： 面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。 TCP传输数据大小没有限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。 TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。 TCP/UDP应用：TCP: 远程连接,文件传输… TCP传输没有UDP快 UDP: 音视频传输… Socket12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; try &#123; Socket s = new Socket("127.0.0.1", 9999); //打开字节流输出流 OutputStream os = s.getOutputStream(); //封装字节流-数据流 DataOutputStream dos = new DataOutputStream(os); //读取控制台数据 Scanner scanner = new Scanner(System.in); String data = scanner.next(); //发送数据到服务端 dos.writeUTF(data); os.close(); s.close();// // 启动发送信息线程// new SendThread(s).start();// // 启动接收信息线程// new RecieveThread(s).start(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; ServerSocket12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; try &#123; // 服务器端打开端口9999 ServerSocket ss = new ServerSocket(9999); // 在9999端口监听 System.out.println("正在监听9999"); Socket s = ss.accept(); System.out.println("请求连接:" + s); // 打开字节流输入流 InputStream is = s.getInputStream(); //封装字节流-数据流 DataInputStream dis = new DataInputStream(is); // 读取客户端发送过来的数据 String readUTF = dis.readUTF(); System.out.println("客户端:"+readUTF); is.close(); s.close(); ss.close();// // 启动发送信息线程// new SendThread(s).start();// // 启动接收信息线程// new RecieveThread(s).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 多线程交互 发送信息线程 1234567891011121314151617181920212223242526272829303132333435/** * * @ClassName: SendThread * @Description: 发送信息线程 * @author zhouhongwei * */public class SendThread extends Thread &#123; private Socket s; public SendThread(Socket s) &#123; this.s = s; &#125; public void run() &#123; try &#123; // 打开字节流输出流 OutputStream os = s.getOutputStream(); // 封装字节流-数据流 DataOutputStream dos = new DataOutputStream(os); while (true) &#123; // 读取控制台数据 Scanner scanner = new Scanner(System.in); String data = scanner.next(); // 发送数据到服务端 dos.writeUTF(data); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 接收信息线程 123456789101112131415161718192021222324252627282930313233/** * * @ClassName: RecieveThread * @Description: 接收信息线程 * @author zhouhongwei * */public class RecieveThread extends Thread &#123; private Socket s; public RecieveThread(Socket s) &#123; this.s = s; &#125; public void run() &#123; try &#123; // 打开字节流输入流 InputStream is = s.getInputStream(); // 封装字节流-数据流 DataInputStream dis = new DataInputStream(is); while (true) &#123; // 读取客户端发送过来的数据 String readUTF = dis.readUTF(); System.out.println(readUTF); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 服务器端 123456789101112131415161718public static void main(String[] args) &#123; try &#123; // 服务器端打开端口9999 ServerSocket ss = new ServerSocket(9999); // 在9999端口监听 System.out.println("正在监听9999"); Socket s = ss.accept(); // 启动发送信息线程 new SendThread(s).start(); // 启动接收信息线程 new RecieveThread(s).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 客户端 12345678910111213141516public static void main(String[] args) &#123; try &#123; Socket s = new Socket("127.0.0.1", 9999); // 启动发送信息线程 new SendThread(s).start(); // 启动接收信息线程 new RecieveThread(s).start(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 说一下,网络编程,有 NIO,也有Netty框架]]></content>
      <categories>
        <category>java</category>
        <category>java中级-网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_集合]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java中级_集合总框架 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类 Collection Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支 List List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。 List 有序,可重复 List的实现类有LinkedList, ArrayList, Vector, Stack。 List接口提供了一个特殊的迭代器，称为ListIterator，其允许元件插入和更换，并且除了该Iterator接口提供正常操作的双向访问。 提供了一种方法来获取从列表中的指定位置开始的列表迭代器。 ArrayList ArrayList擅长于随机访问。同时ArrayList是非同步的。 优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高 Vector Vector是线程安全的动态数组 优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低 LinkedList LinkedList不能随机访问,也是非同步的 优点: 底层数据结构是双向链表，查询慢，增删快。缺点: 线程不安全，效率高 ArrayList-LinkedList-异同点 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 Set Set是一个不允许有重复元素的集合,无序，Set最多有一个null元素。 虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 Set的实现类有HashSet和TreeSet,LinkHashSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 HashSet 没有重复元素的集合 是由HashMap实现的 不保证元素的顺序 是非同步的 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。 LinkedHashSet 底层是基于LinkedHashMap来实现的 有序，非同步。 根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序 当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 TreeSet 一个有序集合，其底层是基于TreeMap实现的，非线程安全 TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式 TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 HashSet、LinkedHashSet、TreeSet比较 Set接口Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。 Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。 HashSetHashSet有以下特点： 不能保证元素的排列顺序，顺序有可能发生变化。 不是同步的。 集合元素可以是null，但只能放入一个null。 当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。 注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 TreeSet类TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。 TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。 Map Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口 不能存在相同的key值，当然value值可以相同。 HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的， 是一个单链表结构 非线程安全 LinkHashMap LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序 双重链接列表 非线程安全 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能 但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 TreeMap TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点 排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 HashTable与HashMap的异同点 相同点： 都实现了Map、Cloneable、java.io.Serializable接口。 都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点： （1）历史原因：HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。 （2）同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。 （3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。 （4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。 (5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 HashMap、Hashtable、LinkedHashMap和TreeMap比较 Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 Hashtable 与 HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。 TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。 TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 Iterator 它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的 12345678910public interface Iterator&lt;E&gt; &#123; //判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 boolean hasNext(); //返回集合里下一个元素。 E next(); //删除集合里上一次next方法返回的元素。 default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125;&#125; 操作一下Iterator的这三个方法 123456789101112131415public static void Test1() &#123; List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String t = it.next(); if ("bbb".equals(t)) &#123; it.remove(); &#125; &#125; System.out.println("After iterate : " + a);&#125; 结果为: Before iterate : [aaa, bbb, ccc]After iterate : [aaa, ccc] ListIterator 针对List集合 12345678910111213141516171819202122232425public static void Test2() &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) &#123; System.out.println("it.next() : " +it.next() + " ,前位置: " + it.previousIndex() + ",后位置: " + it.nextIndex()); &#125; while (it.hasPrevious()) &#123; System.out.println("it.previous() : "+it.previous()); &#125; it = a.listIterator(1); while (it.hasNext()) &#123; String t = it.next(); System.out.println("t:" + t); if ("ccc".equals(t)) &#123; it.set("nnn"); &#125; else &#123; it.add("kkk"); &#125; &#125; System.out.println("After iterate : " + a);&#125; 结果: Before iterate : [aaa, bbb, ccc]it.next() : aaa ,前位置: 0,后位置: 1it.next() : bbb ,前位置: 1,后位置: 2it.next() : ccc ,前位置: 2,后位置: 3it.previous() : cccit.previous() : bbbit.previous() : aaat:bbbt:cccAfter iterate : [aaa, bbb, kkk, nnn] Enumeration 作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。只提供了遍历Vector和HashTable类型集合元素的功能，不支持元素的移除操作 用法和Iterator类似,该接口有2个方法 1234boolean hasMoreElements() 测试此枚举是否包含更多元素。 E nextElement() 如果此枚举对象至少有一个要提供的元素，则返回此枚举的下一个元素. 操作Enumeration方法 123456789101112public static void Test3() &#123; Vector&lt;String&gt; v = new Vector&lt;String&gt;(); v.addElement("Lisa"); v.addElement("Billy"); v.addElement("Mr Brown"); System.out.println("Enumeration前"+v); Enumeration&lt;String&gt; e = v.elements();//返回Enumeration对象 while(e.hasMoreElements())&#123; String value = (String)e.nextElement();//调用nextElement方法获得元素 System.out.println(value); &#125; &#125; 结果: Enumeration前[Lisa, Billy, Mr Brown]LisaBillyMr Brown 工具类Collections 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。]]></content>
      <categories>
        <category>java</category>
        <category>java中级_集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Java中级1.异常1.分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 123456789101112131415异常的体系结构 * java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。 * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked)不会生成字节码文件 * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException//空指针异常 * |-----ArrayIndexOutOfBoundsException//数组角标越界 * |-----ClassCastException//类型转化异常 * |-----NumberFormatException//编码格式异常 * |-----InputMismatchException//输入不匹配 * |-----ArithmeticException//算术异常 2.处理异常方式 throws try-catch-finally finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 3.自定义异常12345678910public class MyException extends Exception&#123; private static final long serialVersionUID = 1L; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 2.JDBC1.定义 JDBC的全称是java数据库链接（Java Data Base Connect），它是用于执行SQL语句的java代码，应用程序可以通过JDBC链接到数据库，并使用SQL语句来完成对数据库中数据的新增、查询、删除和更新等操作 PreparedStatement的优点-防止SQL注入式攻击 PreparedStatement有预编译机制，性能比Statement更快 PreparedStatement 使用参数设置，可读性好，不易犯错 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Connection c = null; Statement s = null; try &#123; // 初始化驱动 Class.forName("com.mysql.jdbc.Driver"); // 建立与数据库的Connection连接 c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/a?characterEncoding=UTF-8", "root", "admin"); // 创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql); // SQL语句 String sql = "insert into cc values(?,?)"; ps.setString(1, "aaa"); ps.setString(1, "bbb"); // 执行SQL ps.execute(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯 // 先关闭PreparedStatement if (ps != null) try &#123; ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 后关闭Connection if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 3.I/O 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 所有的IO操作都在java.io包之中进行定义，而且整个java.io包实际上就是五个类和一个接口：（1）五个类：File、InputStream、OutputStream、Reader、Wirter；（2）一个接口：Serializable。 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 1.File 没啥好补充的 2.字节流与字符流 （1）字节操作流：OutputStream、InputStream；（2）字符操作流：Writer、Reader。 字节流 OutputStream和InputStream是字节流的两个顶层父类。让他们提供了输出流类和输入流类通用API，字节流一般用于读写二进制数据，如图像和声音数据。 OutputStream12345678910111213141516171819202122232425public static void Test2() throws IOException &#123; System.out.println("开始创建文件..."); // 定义文件路径 File file = new File("D:" + File.separator + "java" + File.separator + "test" + File.separator + UUID.randomUUID().toString() + ".txt"); // 判断路径存在? if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; // 文件存在? if (file.exists()) &#123; // 文件存在 file.delete(); // 删除文件 &#125; else &#123; // 文件不存在 file.createNewFile(); // 创建新文件 &#125; // 实例化输出 FileOutputStream fos = new FileOutputStream(file); String data = "哈哈哈哈哈哈哈哈哈"; System.out.println("开始生成数据源..." + file.getAbsolutePath()); // 输出数据 转化为字节数组输出 fos.write(data.getBytes()); // 关闭资源 fos.close(); System.out.println("输出流演示完成!"); &#125; InputStream字符流字符输入流writer]]></content>
      <categories>
        <category>java</category>
        <category>java中级</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
        <tag>JDBC</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java基础一.八种基本数据类型byte 8位 默认值为0 short 16位 默认值0 int 32位 默认值0 long 64位 默认值0L float 32位 默认值 0.0F double 64位 默认值0.0D char 16位 默认值 空 boolean 8位 默认值 false 二.String-字符串1.String 字符串不变; 它们的值在创建后不能被更改。 字符串缓冲区(StringBuffer,StringBuilder)支持可变字符串。 因为String对象是不可变的，它们可以被共享 传递null参数到此类中的构造函数或方法将导致抛出NullPointerException 。 1234 String str = "abc";// 相当于 char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data); compareTo 12public int compareTo(String anotherString)//按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值 isEmpty() 12public boolean isEmpty()//true如果，只有 length()是 0 。 切割字符串 split() 12public String[] split(String regex)//该方法的工作原理是通过使用给定表达式和限制参数为零调用双参数split方法。 因此，尾随的空字符串不会包含在结果数组中。 substring() 12public String substring(int beginIndex)//返回一个字符串，该字符串是此字符串的子字符串 charAt() 12public char charAt(int index)//返回char指定索引处的值。 指数范围为0至length() - 1 。 该序列的第一个char值在索引0 ，下一个索引为1 ，依此类推，与数组索引一样。 2.StringBuffer 一个可变的字符序列 线程不安全 在可能的情况下，建议使用这个类别优先于StringBuilder ，因为它在大多数实现中将更快。 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 3.StringBuilder 可变的字符序列 线程安全 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 三.位运算 与（&amp;）、非（~）、或（|）、异或（^） 1.与 &amp; 两个操作数中位都为1，结果才为1，否则结果为0 2.非 ~ 如果位为0，结果是1，如果位为1，结果是0 3.或 | 两个位只要有一个为1，那么结果就是1，否则就为0 4.异或 ^ 两个操作数的位中，相同则结果为0，不同则结果为1 5.十进制-二进制 二进制: 0 1 1 1 1 1 1 1 1 1 二进制 128 64 32 16 8 4 2 1 十进制 十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。 6.十进制-八进制 八进制：它的基数是8，总共有8个数字符号(0，1，2，3，4，5，6，7)， 十进制整数转换成八进制采用“除8倒取余”，十进制小数转换成二进制小数采用“乘8取整”。 7.十进制-十六进制 十六进制：它的基数是16，总共有16个数字符号(0，1，2，3，4，5，6，7，8，9， ​ A[表示10]，B[表示11]，C[表示12]，D[表示13]，E[表示14]，F[表示15])， 十进制整数转换成十六进制采用“除16倒取余”，十进制小数转换成十六进制小数采用“乘16取整”。 8.二进制-八进制-十六进制 为什么有八进制,十六进制?因为其是2的倍数,方便运算 因为8=2^3^ 16=2^4^ 二进制-八进制 二进制转换成八进制的时候，只要将二进制的表示从右往左开始，每三位二进制数为1组 八进制转换为二进制只需要将八进制的每一个数用三位二进制表示，然后相连既可以。 二进制(0011 0101)B转换为八进制第一组:101 第二组:011 第三组:00第一组计算过程是:1 20+0 21+1 22=5；第二组计算过程是:0 20+1 21+1 22=6；所以最后的结果是65。也就是用6和5直接相连，而不是相加，这里还要注意一下相连的顺序问题，是6–5的方向。 二进制-十六进制二进制转换为十六进制就是将二进制每四位二进制为一组 十六进制转换为二进制只要需要将十六进制的每一个数用四位二进制表示，然后相连即可。 四.接口 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 一个类只由抽象方法和全局常量组成 1.很干净的接口123public interface TestInterface &#123;&#125; 2.概念而言,接口可以放的东西 JDK 1.8 以后，接口里可以有静态方法和方法体了 12345678910111213public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract //（只能是 public abstract，其他修饰符都会报错） public String SIX = ""; // 方法 public abstract int getData(); //接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量 //（并且只能是 public，用 private 修饰会报编译错误）。 int getDataa();&#125; 但是,也可以放普通内部类,抽象内部类,内部接口 1234567891011121314public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 方法 public abstract int getData(); // 普通内部类 class AA&#123;&#125; // 抽象内部类 abstract class BB&#123;&#125; // 内部接口 interface CC &#123;&#125; // 外部接口 static interface DD&#123;&#125;&#125; 3.接口与类的区别 不能实例化对象 没有构造方法 方法必须是抽象方法 只有用 static 和 final修饰的变量 不能被继承,而是要被类实现 支持多继承 4.接口的应用1.Factory工厂设计模式使用工厂设计模式，解耦 12345678&gt; // 没有使用工厂模式 &gt; public static void main(String[] args) &#123;&gt; //Fruit f = new Apple();&gt; Fruit f = new Orange();&gt; f.eat();&gt; &gt; &#125;&gt; 1234567891011121314151617181920&gt; // 创建工厂类&gt; class Factory&#123;&gt; public static Fruit getInstance(String className)&#123;&gt; if("apple".equals(className))&#123;&gt; return new Apple();&gt; &#125;else if("orange".equals(className))&#123;&gt; return new Orange();&gt; &#125;else&#123;&gt; return null;&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; // 使用工厂模式&gt; public static void main(String[] args) &#123;&gt; Fruit f = Factory.getInstance("apple");&gt; f.eat();&gt; &gt; &#125;&gt; 2.Proxy代理设计模式 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 抽象对象角色 目标对象角色 代理对象角色 1234// 抽象对象角色public interface SourceObj &#123; public void doSomethings();&#125; 12345678// 目标对象角色public class RealObj implements SourceObj&#123; @Override public void doSomethings() &#123; System.out.println("do somethings"); &#125;&#125; 1234567891011121314151617// 代理对象角色public class ProxyObj implements SourceObj&#123; //创建目标对象 RealObj realObj = new RealObj(); @Override public void doSomethings() &#123; // 添加新的方法 System.out.println("before do somethings"); realObj.doSomethings(); // 添加新的方法 System.out.println("end do somethings"); &#125;&#125; 五.抽象方法1.定义抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 抽象类定义： 1.抽象方法必须为 public 或 protected, 2.不能被实例化，采用向上转型处理 3.必须有子类 一个子类只能继承一个抽象类 4.子类不是抽象方法，则需要全部重写父类的抽象方法 123456789101112public abstract class C &#123; //构造方法 public C()&#123; System.out.println("C类的构造方法"); &#125; //普遍方法 public void a() &#123; System.out.println("有方法体"); &#125; // 抽象方法 public abstract void b();&#125; 有构造方法，总是先执行父类的构造，再去执行子类的构造方法 1234567891011public class D extends C &#123; // 构造方法 public D() &#123; System.out.println("D类的构造方法"); &#125; @Override public void b() &#123; System.out.println("d-c.b"); &#125;&#125; 1234public static void StringTest() &#123; D d = new D(); d.b();&#125; 结果：总是先执行父类的构造，再去执行子类的构造方法C类的构造方法D类的构造方法d-c.b 允许内部抽象类 使用static声明外部抽象类 123456abstract class A&#123;//定义一个抽象类 这里不允许使用static声明 static abstract class B&#123;//static定义的内部类属于外部类 public abstract void print(); &#125;&#125; 2.抽象类的应用Template 模板设计模式 模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 这种类型的设计模式属于行为型模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板模式主要由抽象模板(Abstract Template)角色和具体模板(Concrete Template)角色组成 123456789101112131415// 抽象模板角色abstract class Game&#123; //启动游戏 protected abstract void runGame(); //结束游戏 protected abstract void endPlayGame(); //模板方法 public final void play() &#123; runGame(); endPlayGame(); &#125; &#125; 12345678910111213// 具体模板角色class ContraGame extends Game&#123; @Override protected void runGame() &#123; System.out.println("启动aa游戏..."); &#125; @Override protected void endPlayGame() &#123; System.out.println("角色死亡，aa游戏结束！"); &#125;&#125; 123456//测试public static void main(String[] args) &#123; Game game = new ContraGame(); game.play(); System.out.println();&#125; 结果： 启动aa游戏… 角色死亡，aa游戏结束！ 优点 扩展性好，对不变的代码进行封装，对可变的进行扩展；可维护性好，因为将公共代码进行了提取，使用的时候直接调用即可； 缺点 因为每一个不同的实现都需要一个子类来实现，导致类的个数增加，会使系统变得复杂； 使用场景 有多个子类共有逻辑相同的方法；重要的、复杂的方法，可以考虑作为模板方法。 注意事项 为防止恶意操作，一般模板方法都加上 final 关键词！防止修改 六.重写与重载1.区别 区别 重写 重载 1 英文 Override OverLoading 2 定义 方法名相同，参数类型及参数个数不同， 方法名，参数类型，参数个数，返回值完全相同 3 权限 没有权限要求 子类的重写父类的方法，该方法不能拥有比父类更严格的访问控制权限 4 范围 发生在一个类中 发生在继承关系类中 2.this与super 区别 this super 1 定义 表示本类对象 表示父类对象 2 使用 this.属性，this.方法，this(); super.属性，super.方法(),super() 3 构造方法 放在首行 放在首行 4 查找范围 先从本类查找，找不到去父类找 直接找父类 5 特殊 表示当前对象]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基本类型</tag>
        <tag>String</tag>
        <tag>位运算</tag>
        <tag>接口</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F06%2F12%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java中级_多线程]]></title>
    <url>%2F2020%2F05%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java中级_多线程线程 线程是进程中的一个实体 是被系统独立调度和分配的基本单位 一个标准的线程: 线程ID, 当前指令指针(PC) 寄存器集合 堆栈 Java默认线程有两个: main()主线程 GC线程 线程状态 之前线程的状态 （1）新建状态（New）：当线程对象对创建后，即进入了新建状态 （2）就绪状态（Runnable）：当调用线程对象的start()方法,线程即进入就绪状态 （3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行,,执行run()方法 (4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行 （5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 在Java中 在Thread.state源码来看 线程状态有6种 1234567891011121314public enum State &#123;状态 // 新生 NEW, // 运行状态 RUNNABLE, // 阻塞状态 BLOCKED, // 等待----一直等 WAITING, // 超时等待---过时不候 TIMED_WAITING, // 终止 TERMINATED; &#125; 1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 2.运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池 中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU 时间片后变为运行中状态（running）。3.阻塞(BLOCKED)：表示线程阻塞于锁。4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 6.终止(TERMINATED)：表示该线程已经执行完毕。 Java无法开启一个线程: 通过调用本地方法来开启的 1private native void start0(); 多线程 实现Runnable接口,实现Callable和继承Thread可以得到一个线程类 继承Thread方式1234567891011121314class ThreadTest extends Thread &#123; // 线程主体 private String title; public ThreadTest(String title) &#123; this.title = title; &#125; @Override public void run() &#123; // 线程主方法 for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--继承Thread类似创建线程"); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; // Thread ThreadTest t1 = new ThreadTest("线程A"); ThreadTest t2 = new ThreadTest("线程B"); ThreadTest t3 = new ThreadTest("线程C"); t1.start(); // 在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的 t2.start(); t3.start(); &#125; 结果: 线程A–继承Thread类似创建线程线程B–继承Thread类似创建线程线程C–继承Thread类似创建线程线程B–继承Thread类似创建线程线程A–继承Thread类似创建线程线程B–继承Thread类似创建线程线程C–继承Thread类似创建线程线程A–继承Thread类似创建线程线程C–继承Thread类似创建线程 实现Runable接口方式1234567891011121314class RunableTest implements Runnable &#123;// 线程主体 private String title; public RunableTest(String title) &#123;// 线程主方法 this.title = title; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--实现Runable类似创建线程"); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; // Runable RunableTest ta = new RunableTest("Runable-aa"); RunableTest tb = new RunableTest("Runable-bb"); RunableTest tc = new RunableTest("Runable-cc"); new Thread(ta).start(); // 借助Thread类的构造方法启动线程 new Thread(tb).start(); new Thread(tc).start(); &#125; 结果: Runable-aa–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-aa–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-aa–实现Runable类似创建线程 实现Callable方式 123456789101112class CallableTest implements Callable&lt;String&gt; &#123; private String name; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 3; i++) &#123; name = "" + i; System.out.println("name:" + name); &#125; return "测试结束"; &#125;&#125; 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; // Callable CallableTest c1 = new CallableTest(); CallableTest c2 = new CallableTest(); CallableTest c3 = new CallableTest(); //FutureTask是Runnable接口的子类，可以使用Thread类的构造来接收task对象 FutureTask&lt;String&gt; ft1 = new FutureTask&lt;String&gt;(c1); FutureTask&lt;String&gt; ft2 = new FutureTask&lt;String&gt;(c2); FutureTask&lt;String&gt; ft3 = new FutureTask&lt;String&gt;(c3); new Thread(ft1).start(); new Thread(ft2).start(); new Thread(ft3).start(); //多线程执行完毕后，可以使用FutureTask的父接口Future中的get()方法取得执行结果 System.out.println("ft1:" + ft1.get()); System.out.println("ft2:" + ft2.get()); System.out.println("ft3:" + ft3.get()); &#125; 结果: name:0name:0name:0name:1name:1name:2name:1name:2name:2ft1:测试结束ft2:测试结束ft3:测试结束 Runable与Callable区别:不同点Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果 Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛 注：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。 关键字Sleep Thread.sleep(2000); 表示当前线程暂停1000毫秒 ，其他线程不受影响Thread.sleep(2000); 会抛出InterruptedException 中断异常 12345678910111213@Override public void run() &#123; // 线程主方法 try &#123; Thread.sleep(2000); System.out.println("...暂停了2秒才开始输出"); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--继承Thread类似创建线程"); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Join t3.join(3000); 3秒 把某一下线程加入到主线程,表示只有等该线程执行完成才继续运行其他线程 1234567891011public static void main(String[] args) throws Exception &#123; // Thread ThreadTest t1 = new ThreadTest(&quot;线程A&quot;); ThreadTest t2 = new ThreadTest(&quot;线程B&quot;); ThreadTest t3 = new ThreadTest(&quot;线程C&quot;); t1.start(); // 在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的 t2.start(); t3.start(); //把t3线程加入到主线程 3秒 t3.join(3000);&#125; setPriority 线程优先级 12345678// 优先级最高t1.setPriority(Thread.MAX_PRIORITY);// 正常t2.setPriority(Thread.NORM_PRIORITY);// 优先级最低t3.setPriority(Thread.MIN_PRIORITY);// 可以使用数字t4.setPriority(10); yield 临时暂停 1t3.yield(); setDaemon 守护线程 t1.setDaemon(true);设置当前线程为守护进程 1t1.setDaemon(true);]]></content>
      <categories>
        <category>java</category>
        <category>java中级_多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新hexo]]></title>
    <url>%2F2020%2F03%2F22%2F%E9%87%8D%E6%96%B0hexo%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[java测试]]></title>
    <url>%2F2019%2F07%2F11%2Fjava%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[java]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Blogs-Introduce]]></title>
    <url>%2F2019%2F05%2F12%2FBlogs-Introduce%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo github 搭建博客]]></title>
    <url>%2F2019%2F05%2F12%2Fhexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一，创建本地博客 安装软件 Node.js Git 安装hexo（以后的命令，均可以在鼠标右键Git Bash Here） 1$ npm install -g hexo-cli 建立一个Hexo文件夹，用于存放博客 在Hexo目录下，初始化Hexo文件 1Hexo init 在Hexo目录下安装hexo扩展插件 1npm install 在Hexo目录下安装git插件: 1npm install hexo-deployer-git --save 在Hexo目录下生成静态页面: 1hexo generate 在Hexo目录下启动本地服务器: 1hexo server 浏览器输入:http://localhost:4000 二, 部署到github 设置user.name和user.email: git config –global user.name “你的GitHub用户名” 注意global前面是两个双杠【-】 git config –global user.email “你的GitHub注册邮箱” 生成ssh密匙: ssh-keygen -t rsa -C “你的GitHub注册邮箱” ​ 【按需一般需要三次回车】确定 (此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 把id_rsa.pub的内容复制到GitHub账号:用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮,Title随便写. 修改目录配置文件: 1234deploy: type: git repo: git@github.com:oldzhoua/oldzhoua.github.io.git branch: master 清空静态页面: hexo clean 生成静态页面: hexo generate 部署到GitHub: hexo deploy 过程会让你输入g’ithub账号和密码 浏览器输入: oldzhoua.github.io 使用自己的域名 购买域名之后 在域名解析那里填写两个CNAME和A 类型: CNAME&gt;主机记录填写:www CNAME&gt;记录值填写: oldzhoua.github.io A&gt;主机记录填写:@ A&gt;主机值填写:( ping oldzhoua.github.io 会得到的IP值) 在Blogs文件夹下的source目录目录下建立一个没有后缀名的文件,写入,www.oldzhou.top,保存. 在GitHub自己的库中Settings 下的Github Page下填写域名. 在命令行输入: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入自己的域名访问&gt;完成 三，安装NexT主题 安装NexT 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 站点配置文件找到theme 12Hexo/_config.ymltheme: next 更改主题和验证主题之间，我们最好使用hexo clean清理Hexo的缓存 在Hexo目录下检查安装 1hexo s --debug 你可以打开http://localhost:4000在浏览器中，并检查站点是否正确工作 四，个性化设置 现在NexT外观，编辑更改方案主题配置文件，搜索scheme关键字 next主题有四种方案: Muse→默认方案。使用黑白色调，主要看上去干净。 Mist→具有整洁的单列视图。 Pisces→双页面计划布局。 Gemini→有不同的带阴影的列块来显示视图。 12345Next/_config.yml#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 编辑站点配置文件，设置language你需要的语言 12HEXO/config.ymllanguage: zh-CN 配置菜单项，默认情况下，Next提供home和archives页面。其他不提供 12345678910Next/_config.ymlmenu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 刚添加完菜单项的是无法打开的,需要在站点文件下创建相应的路径文件: 在站点文件下了输入以下命令: 1234hexo new page categorieshexo new page tagshexo new page abouthexo new page archives 默认情况下，Next显示没有徽章的菜单项的图标 12345Next/_config.ymlmenu_settings: icons: true # 显示计数 badges: true 配置网站标签页图标，放在Hexo\themes\next\source\images 123456789HEXO/_config.ymlfavicon: #一张16*16，32*32的图片 small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml 配置头像, 编辑主题配置文件 123456Next/_config.ymlavatar: url: /images/avatar.gif rounded: true rotated: true opacity: 1 配置作者，编辑站点配置文件的值，并设置author你的昵称 123HEXO/_config.yml# Siteauthor: xxx 配置描述，编辑站点配置文件的值，并设置description可以是你喜欢的句子 123HEXO/_config.yml# Sitedescription: xxxxxxx 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 配置头像: 在主题文件中: 1avatar: /images/touxiang.jpg 可以检查一下效果: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入: http://localhost:4000/ 设置动态背景: 在主题配置文件中: 12# Canvas-nestcanvas_nest: true 修改文章超链接样式: 在Blogs/themes/next/source/css/_common/components/post/post.styl 文件中添加css: 12345678.post-body p a&#123; color: #FF0000; border-bottom: 2px solid #FF0000; &amp;:hover &#123; color: #4DFFFF; border-bottom: 2px solid #4DFFFF; &#125;&#125; 在文章末尾添加文章结束标记: 在 Blogs\themes\next\layout_macro 下打开命令行新建 passage-end-tag.swig 文件: 1touch passage-end-tag.swig 在新建文件中添加: 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #fc6423;font-size:16px;&quot;&gt;---本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读!---&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 在 Blogs\themes\next\layout_macro\post.swig 中的如下面位置添加: 12345678 &#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件添加: 12passage_end_tag: enabled: true 设置头像及样式: 1avatar: 头像地址 设置头像圆角:在Blogs/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 添加: 12345.site-author-image &#123; border-radius: 70px; -webkit-border-radius: 70px; -moz-border-radius: 70px;&#125; 侧栏社交图标: 在主题配置文件搜索social 去掉#选择 123456789social: Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype || xxx,xxx表示图标,在Font Awesome Icon 网站找然后复制下来 文章添加阴影效果: 在Blogs\themes\next\source\css_custom\custom.styl下添加: 12345.post &#123; box-shadow: 0 0 10px rgba(255, 0, 0, .8); -webkit-box-shadow: 0 0 10px rgba(255, 0, 0, .8); -moz-box-shadow: 0 0 10px rgba(255, 0, 0, .8); &#125; 文件上传的方法 在站点文件下打开命令行安装插件: 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 在站点配置文件修改如下: 1post_asset_folder: true 在 hexo new “标题” 的时候,会在同级目录下生成多一个同名的文件夹(用于放图片)格式如下: 1![](标题\图片名.png) 需要注意的是,如果是以选择的方式添加的,可以选择把多余的路径删掉, 比如: 1![](E:\Blogs\source\_posts\标题\图片名.png) 1![](标题\图片名.png) 然后重新部署一下就可以看到图片了 设置底部添加访问量: 使用busuanzi: 在 Blogs/themes/next/layout/_partials/footer.swig 文件中顶部添加: 1234567&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 设置网站底部字数统计 在站点目录下安装插件 1npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig 文件中添加: 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 设置文章统计功能 安装插件 1npm install hexo-wordcount --save 修改主题配置文件: 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 设置网页进度条 在主题配置文件搜索pace:值改为 true,去掉#选择款式 1234567# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shoppace_theme: pace-theme-minimal 设置网站标签页图标 在图标网站, 比如: 阿里巴巴矢量图标库 ,下载一张16x16,32x32的图 在Blogs/themes/next/source/images 中,替换默认的两张图片 如果修改了名字侧需要在主题配置文件中搜索favicon 12345# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png 隐藏底部标记 在Blogs/themes/next/layout/_partials/footer.swig 中,用注释掉相应的代码 设置博文置顶 在Blogs/node_modules/hexo-generator-index/lib/generator.js 的代码改为: 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章头添加top: xx,值越大越靠前显示: 1234567title: next主题优化系列二date: 2019-01-18 14:21:49tags:- next- 优化categories: nexttop: 88 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 增加版权信息 在Blogs/themes/next/layout/_macro/ 添加 my-copyright.swig文件 1touch my-copyright.swig my-copyright.swig代码: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在Blogs/themes/next/source/css/_common/components/post/添加 my-copyright.styl文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 在Blogs/themes/next/layout/_macro/post.swig 文件中如下位置添加代码: 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 如: 12345678910111213141516&#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在Blogs/themes/next/source/css/_common/components/post/post.styl文件最后添加: 1@import &quot;my-post-copyright&quot; 在文章头添加:copyright : true 123456tags: - next - 优化 categories: next copyright: true top: 配置站点配置文件: 123456# URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://oldzhoua.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: 重新部署就可以看见效果了 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
