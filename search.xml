<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java高级_JVM]]></title>
    <url>%2F2020%2F06%2F19%2FJava%E9%AB%98%E7%BA%A7-JVM%2F</url>
    <content type="text"><![CDATA[1.JVM的介绍 JVM是Java Virtual Machine（Java虚拟机）的缩写 本章所论的JVM是HotSpot VM , 是 Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机 介绍我所知的另外两种: Jrockit: 由BEA公司开发的专注于服务器端应用的虚拟机。号称世界上最快的虚拟机 J9 ：J9由IBM公司开发，曾广泛应用于IBM公司系统内部及IBM小型机上。现已经捐献给Eclipse基金会。 2.JVM的作用 java是一门高级语言,符合人们的习惯,但不符合电话的理解,因此需要在硬件上进行转化 就是将.java文件转成Java字节码文件(.class),由JVM进行解析和执行. 3.JVM图解 接下来就按着图解来进行拆分讲解 4.Javac编译器4.1编译器介绍 编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序, 或者是把程序转换成计算机或者微型处理器能够识别的机器代码 0 - 1 4.2编译器作用 对于 Java 虚拟机来说，识别的是.class文件, 而编译器的作用就是把.java.文件转化成.class文件 在JDK安装目录有一个叫 javac 的编译器的工具,它就是把Java代码编译成字节码文件的 一般讲的是Javac编译器,下面讲一下另外两种 4.3编译器种类 从源码到字节码 - javac编译器 从字节码到机器码: ​ 2.1 使用 Java 解释器解释执行字节码 ​ 启动速度快-不需要翻译 ​ 运行速度慢- 机器码运行的效率比解释器高 ​ 2.2 使用 JIT 编译器(即时编译器)将字节码转化为本地机器代码。 ​ 启动速度慢,运行速度快 JIT编译器(动态编译)在JVM中有两种内置的即时编译器 Client Compiler 和 Server Compiler Client Comlier: 优化少,编译速度快 Server Comlier: 根据性能优化,编译质量好,耗时长 虽然有两种模式,但是JVM提供了三种运行模式: mixed mode (默认,混合),Interpreted Mode(解释),Compiled Mode(编译) 从源码到机器码: AOT编译器 (JDK9新特性) :在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码,静态编译 以上三种是JVM重要的编译器 编译速度上，解释执行 &gt; AOT 编译器 &gt; JIT 编译器 编译质量上，JIT 编译器 &gt; AOT 编译器 &gt; 解释执行 5.类加载器 类加载介绍类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。 类加载器是JVM一部分,负责动态加载Java类到Java虚拟机的内存空间中 类加载器作用JVM中4种类加载器 启动类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的类库加载到虚拟机内存中 由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 扩展类加载器它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中 应用程序类加载器它负责加载用户类路径（ClassPath）上所指定的类库 自定义类加载器用户根据需求自己定义的。也需要继承自ClassLoader. 3.类加载器的时机 ​ 1.new一个对象的时候，也就是创建类实例的时候 ​ 2.访问某个类或接口的静态变量，或者对该静态变量赋值 ​ 3.调用类的静态方法 ​ 4.反射（Class.forName(“xxx.xxx”)） ​ 5.初始化一个类的子类（会首先初始化子类的父类） ​ 6.JVM启动时标明的启动类，即文件名和类名相同的那个类 4.类加载器的机制 - 双亲委派模型 双亲委派模型介绍: 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。 双亲委派机制好处: 保证java类库中的类不受用户类影响，防止用户自定义一个类库中的同名类，引起问题。 5.类加载的方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 6.类加载的生命周期:加载: 将编译后的.Class文件加载到内存中 连接:(验证,准备,解析) **验证:** 确保**Class文件**的字节流中包含的信息符合当前**虚拟机的要求**，并且不会危害虚拟机自身的安全 ​ 准备: 为类变量分配内存并设置初始值，使用的是方法区的内存​ 解析: 将class文件的常量池的符号引用替换为直接引用的过程（是静态链接）。初始化: 为类的静态变量赋予程序中指定的初始值，还有执行静态代码块中的程序。使用卸载 JVM把java文件数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型 将指定的class文件读取到内存里，并运行该class文件里的Java程序的过程，就称之为类的加载；反之，将某个class文件的运行时数据从JVM中移除的过程，就称之为类的卸载。 6.运行时数据区6.1虚拟机栈 线程私有生命周期与线程相同每个方法执行会创建一个栈帧 栈帧: 局部变量表： 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 存放的信息包括 基本数据类型,对象引用,returnAddress类型 操作数栈: 保存着Java 虚拟机执行过程中的数据 动态链接：指向运行时常量池中该栈帧所属方法的引用 方法出口：储存返回地址 退出方法的方式 正常完成出口 异常完成出口，不会返回值，返回地址通过异常处理器表来确定 退出过程 1）恢复上层方法的局部变量表和操作数栈 2）把返回值压入调用者的栈帧的操作数栈中 3）调整PC计数器指向下一条指令 6.2本地方法栈 线程私有与虚拟机栈一样，只是服务的方法类型不一样 使用到的Native方法服务 6.3程序计数器 线程私有当前线程执行字节码的行号指示器 此内存区域是唯一一个不会出现OutOfMemoryError情况的区域。 1.如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数 2.如果正在执行的是Natvie方法，这个计数器值则为空（Undefined） 6.4方法区(元空间) 线程共享储存已加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 元空间使用本地内存，理论上电脑有多少内存，它就有多少内存，避免的内存溢出问题 常量池 编译器生成的各种字面量和符号引用 符号引用: 类符号引用, 方法符号引用, 字段符号引用 一个java类（假设为People类）被编译成一个class文件时，如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。 字面量: 文本字符串, 八种基本类型, 声明为final的常量 String a = “abc”,这个abc就是字面量 ​ int a = 1; 这个1就是字面量 6.5堆 线程共享占内存最大的一块存放对象实例垃圾回收的主要区域 在GC角度来看,可以分为两个区理解: 新生代,老年代 新生代 类诞生和成长的地方,甚至是死亡 又分为三个区: Eden区, Survivor(from)区, Survivor(to)区设置两个Survivor区是为了解决碎片化的问题 采用的是复制算法 Eden区(伊甸园区): 所有对象都是这 New 出来的 (对象优先在Eden分配,大对象直接进入老年代) 如果这里空间满了,将会进行轻GC ,存活的对象将放进from区 Survivor(from)区: 出生时位于Eden，一次MinorGC存活后进入Survivor，每经历一次GC，年龄加一，年龄达到15进入老年代 from区和to区会进行互换角色 Survivor(to)区: 为空的就是to区 老年代 采用标记整理算法(标记压缩算法) 当Survivor中相同年龄的对象大小总和大于Survivor的一半，则这些对象进入老年代 如果老年代满了会处罚Full GC GC gc分类 Minor GC 当Eden区满时，会触发Minor GC，对新生代进行垃圾回收。 MajorGC 对老年代进行垃圾回收 full GC 对整个堆进行垃圾回收 触发条件 1.老年代空间不足 2.方法区空间不足 3.调用system.gc(),这个只是建议JVM执行full GC，但不是一定就会立刻执行。 4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存 两个名词 stop-the-world JVM由于要执行gc而会暂停应用程序的执行，这一过程叫做stop-the-world。它会在任何一种GC算法中出现，而我们对gc的优化也是致力于减少它发生的时间来提高程序性能。 safepoint 当我们对某一个对象进行可达性分析时，它的引用关系此时最好是不能变化的，也就是它必须处于安全点的。也就是说safepoint就是分析过程中对象引用不会发生变化的点（场景：方法调用，循环跳转，异常跳转等） 4种算法复制算法: 是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。 优点 简单高效，不会出现内存碎片问题缺陷 内存利用率低 存活对象较多时效率明显会降低 标记-清除算法: 先按照可达性算法标记所有被引用的对象，然后遍历堆，清除未被标记的算法。它的会产生内存碎片，以及出现大对象找不到连续空间的问题。（标记过程会暂停所有进程，也就是我们说的stop-the-world STW） 1.将需要回收的对象标记起来2.清除对象 优点: ​ 不需要额外的空间 缺点: ​ 两次扫描,耗时长 ​ 会产生大量的不连续的内存碎片 标记-整理算法: 原理和标记清除算法类似，只是最后一步的清除改为了将存活对象全部移动到一端，然后再将边界之外的内存全部回收。 优点: ​ 不需要额外空间 缺点: ​ 需要移动大量对象，效率不高 分代回收算法: 根据各个年代的特点选取不同的垃圾收集算法 新生代使用复制算法 老年代使用标记-整理或者标记-清除算法 对象存活引用计数法: 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。缺陷：循环引用会导致内存泄漏 可达性分析算法: 该算法是通过一系列的称为“GC Roots”的对象作为起始点, 从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain), 当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。 判断一个对象是否可回收的过程 1.找到GC Roots不可达的对象，如果没有重写finalize()或者调用过finalize()，则将该对象加入到F-Queue中2.再次进行标记，如果此时对象还未与GC Roots建立引用关系，则被回收 垃圾收集器 G1 和 CMS G1收集器: G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 同时收集新生代和老年代垃圾 流程: 初始标记：仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 ​ 并发和并行​ 分代收集​ 标记-整理算法​ 将堆分为多个大小相等的region 特点 空间整合，不会产生内存碎片 可预测的停顿参数设置 -XX:+UseG1GC -XX:MaxGCPauseMillis CMS收集器 CMS 是英文 Concurrent Mark-Sweep 的简称， 是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。 对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。 在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 它与其他老年代收集器不同的时，它采用标记清除算法，也就是说它存在内存碎片化的问题，如果要分配一个比较大的对象的内存，就只能触发GC。 流程 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW）。 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。 并发清除：不需要停顿。 标记-清除算法并发收集-低停顿 吞吐量低 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高无法处理浮动垃圾 ​ 可能出现 Concurrent Mode Failure​ 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收​ 由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。​ 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。会产生空间碎片​ 标记 - 清除算法会导致产生不连续的空间碎片 回收对象引用类型 强引用 垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止 软引用 垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收它 软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。 弱引用 垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。 ThreadLocal的key是弱引用 虚引用 如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动 强引用strong reference 不会回收软引用soft reference 溢出才回收弱引用weak reference 下一次被回收虚引用phantom reference 7.执行引擎 所有的执行引擎的基本一致： 输入：字节码文件 处理：字节码解析 输出：执行结果。 物理机的执行引擎是由硬件实现的，和物理机的执行过程不同的是虚拟机的执行引擎由于自己实现的。 8.本地方法 用native修饰的，不能和abstract共同使用的，不显示方法体但却是用非Java语言实现方法体的方法。 9.本地方法库 个人理解:类似C, C++ 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级-JUC-concurrent]]></title>
    <url>%2F2020%2F06%2F18%2FJava%E9%AB%98%E7%BA%A7-JUC-concurrent%2F</url>
    <content type="text"><![CDATA[队列: FIFO 先进先出特点 阻塞队列 同步队列 阻塞队列: java.util.concurrentInterface BlockingQueue 参数类型E - 此集合中保存的元素的类型All Superinterfaces:Collection ， Iterable ， Queue All Known Subinterfaces:BlockingDeque ， TransferQueue 所有已知实现类：ArrayBlockingQueue ， DelayQueue ， LinkedBlockingDeque ， LinkedBlockingQueue ， LinkedTransferQueue ， PriorityBlockingQueue ， SynchronousQueue 官方解释: BlockingQueue方法有四种形式，具有不同的操作方式， 不能立即满足，但可能在将来的某个时间点满足： 一个抛出异常， 第二个返回一个特殊值（ null或false ，具体取决于操作）， 第三个程序将无限期地阻止当前线程，直到操作成功为止， 第四个程序块在放弃之前只有给定的最大时限。 这些方法总结在下表中： Summary of BlockingQueue methods Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable 个人解释: 四种用法: 1.抛异常 2.返回特殊值 null/false 3.一直阻塞当前线程 4.超时等待 什么时候使用阻塞队列: 多线程并发 线程池 仔细看一下 不能立即满足，但可能在将来的某个时间点满足 先看后面半句话:可能在将来的某个时间点满足 代码测试]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JUC</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级-JUC-locks]]></title>
    <url>%2F2020%2F06%2F18%2FJava%E9%AB%98%E7%BA%A7-JUC-locks%2F</url>
    <content type="text"><![CDATA[ReadWriteLock java.util.concurrent.locksInterface ReadWriteLock 所有已知实现类：ReentrantReadWriteLock public interface ReadWriteLock A ReadWriteLock维护一对关联的locks ，一个用于只读操作，一个用于写入。 read lock可以由多个阅读器线程同时进行，只要没有作者。 write lock是独家的 为什么要使用: 希望更加细腻度的控制锁,读和写锁分离 未用锁之前的效果: 1234567891011121314151617181920212223242526272829303132333435class WriteRead &#123; // 写 public void write() &#123; System.out.println(Thread.currentThread().getName() + "开始写"); System.out.println(Thread.currentThread().getName() + "结束写"); &#125; // 读 public void read() &#123; System.out.println(Thread.currentThread().getName() + "开始读"); System.out.println(Thread.currentThread().getName() + "结束读"); &#125;&#125;public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; readWriteLock(); &#125; public static void readWriteLock() &#123; WriteRead writeRead = new WriteRead(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.lock(); &#125;,"线程" + i).start(); &#125; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.lock(); &#125;,"线程" + i).start(); &#125; &#125;&#125; 结果: 线程1开始写线程2开始写 &lt;–插队线程2结束写 &lt;–插队线程1结束写线程8开始写线程9开始写线程9结束写线程8结束写线程4结束写线程7开始写线程7结束写线程6开始写 … 加锁的效果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class WriteRead &#123; final ReadWriteLock rwl = new ReentrantReadWriteLock(); // 写 public void writelock() &#123; rwl.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + "开始写"); System.out.println(Thread.currentThread().getName() + "结束写"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; rwl.writeLock().unlock(); &#125; &#125; // 读 public void readlock() &#123; rwl.readLock().lock(); System.out.println(Thread.currentThread().getName() + "开始读"); System.out.println(Thread.currentThread().getName() + "结束读"); rwl.readLock().unlock(); &#125;&#125;public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; readWriteLock(); &#125; public static void readWriteLock() &#123; WriteRead writeRead = new WriteRead(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.writelock(); &#125;,"线程" + i).start(); &#125; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.readlock(); &#125;,"线程" + i).start(); &#125; &#125;&#125; 结果: 线程3开始写线程3结束写线程7开始写线程7结束写线程0开始写线程0结束写线程1开始写线程1结束写线程2开始写线程2结束写线程4开始写线程4结束写线程6开始写线程6结束写线程5开始写线程5结束写线程8开始写线程8结束写线程9开始写线程9结束写 ReadWriteLock这个接口很简单,只有一个实现类ReentrantReadWriteLock java.util.concurrent.locksClass ReentrantReadWriteLock java.lang.Object java.util.concurrent.locks.ReentrantReadWriteLock All Implemented Interfaces:Serializable ， ReadWriteLock public class ReentrantReadWriteLockextends Objectimplements ReadWriteLock, SerializableReadWriteLock | Modifier and Type | Class and Description || —————– | ———————————————————— || static class | ReentrantReadWriteLock.ReadLock 该锁由方法 readLock()返回。 || static class | ReentrantReadWriteLock.WriteLock 该锁由方法 writeLock()返回。 | 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JUC</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级-JUC-locks]]></title>
    <url>%2F2020%2F06%2F18%2FJava%E9%AB%98%E7%BA%A7-JUC-Lock%2F</url>
    <content type="text"><![CDATA[ReadWriteLock java.util.concurrent.locksInterface ReadWriteLock 所有已知实现类：ReentrantReadWriteLock public interface ReadWriteLock A ReadWriteLock维护一对关联的locks ，一个用于只读操作，一个用于写入。 read lock可以由多个阅读器线程同时进行，只要没有作者。 write lock是独家的 为什么要使用: 希望更加细腻度的控制锁,读和写锁分离 未用锁之前的效果: 1234567891011121314151617181920212223242526272829303132333435class WriteRead &#123; // 写 public void write() &#123; System.out.println(Thread.currentThread().getName() + "开始写"); System.out.println(Thread.currentThread().getName() + "结束写"); &#125; // 读 public void read() &#123; System.out.println(Thread.currentThread().getName() + "开始读"); System.out.println(Thread.currentThread().getName() + "结束读"); &#125;&#125;public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; readWriteLock(); &#125; public static void readWriteLock() &#123; WriteRead writeRead = new WriteRead(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.lock(); &#125;,"线程" + i).start(); &#125; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.lock(); &#125;,"线程" + i).start(); &#125; &#125;&#125; 结果: 线程1开始写线程2开始写 &lt;–插队线程2结束写 &lt;–插队线程1结束写线程8开始写线程9开始写线程9结束写线程8结束写线程4结束写线程7开始写线程7结束写线程6开始写 … 加锁的效果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class WriteRead &#123; final ReadWriteLock rwl = new ReentrantReadWriteLock(); // 写 public void writelock() &#123; rwl.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + "开始写"); System.out.println(Thread.currentThread().getName() + "结束写"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; rwl.writeLock().unlock(); &#125; &#125; // 读 public void readlock() &#123; rwl.readLock().lock(); System.out.println(Thread.currentThread().getName() + "开始读"); System.out.println(Thread.currentThread().getName() + "结束读"); rwl.readLock().unlock(); &#125;&#125;public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; readWriteLock(); &#125; public static void readWriteLock() &#123; WriteRead writeRead = new WriteRead(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.writelock(); &#125;,"线程" + i).start(); &#125; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; writeRead.readlock(); &#125;,"线程" + i).start(); &#125; &#125;&#125; 结果: 线程3开始写线程3结束写线程7开始写线程7结束写线程0开始写线程0结束写线程1开始写线程1结束写线程2开始写线程2结束写线程4开始写线程4结束写线程6开始写线程6结束写线程5开始写线程5结束写线程8开始写线程8结束写线程9开始写线程9结束写 ReadWriteLock这个接口很简单,只有一个实现类ReentrantReadWriteLock java.util.concurrent.locksClass ReentrantReadWriteLock java.lang.Object java.util.concurrent.locks.ReentrantReadWriteLock All Implemented Interfaces:Serializable ， ReadWriteLock public class ReentrantReadWriteLockextends Objectimplements ReadWriteLock, SerializableReadWriteLock | Modifier and Type | Class and Description || —————– | ———————————————————— || static class | ReentrantReadWriteLock.ReadLock 该锁由方法 readLock()返回。 || static class | ReentrantReadWriteLock.WriteLock 该锁由方法 writeLock()返回。 | 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JUC</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级-JUC二-常用类]]></title>
    <url>%2F2020%2F06%2F17%2FJava%E9%AB%98%E7%BA%A7-JUC%E4%BA%8C-%E5%B8%B8%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[CountDownLatch // 计数器 CyclicBarrier // 循环阻塞 Semaphore //信号量 CountDownLatch java.util.concurrent Class CountDownLatch java.lang.Object java.util.concurrent.CountDownLatch public class CountDownLatchextends Object 解释: 允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。 官方解释: A CountDownLatch用给定的计数初始化。 await方法阻塞，直到由于countDown()方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的await 调用立即返回。 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用CyclicBarrier 。 A CountDownLatch是一种通用的同步工具，可用于多种用途。 一个CountDownLatch为一个计数的CountDownLatch用作一个简单的开/关锁存器，或者门：所有线程调用await在门口等待，直到被调用countDown()的线程打开。 一个CountDownLatch初始化N可以用来做一个线程等待，直到N个线程完成某项操作，或某些动作已经完成N次 个人解释: 就是对线程计数,到达指定数量后,继续执行,否则等待 123456789101112131415161718192021222324/** * * @Title: CountDownLatchTest * @Description: 并发常用类,CountDownLatch 计数器 * @throws InterruptedException 参数 * @return void 返回类型 */ public static void CountDownLatchTest() throws InterruptedException &#123; System.out.println("CountDownLatch"); // 计数器 CountDownLatch countDownLatch = new CountDownLatch(10); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "撤退!"); // 计数器减一 countDownLatch.countDown(); &#125;, "线程" + i).start(); &#125; // 当 countDownLatch = 0 , 唤醒线程, 才会继续往下执行 countDownLatch.await(); System.out.println("结果:" + countDownLatch.getCount()); &#125; 结果: CountDownLatch线程1撤退!线程2撤退!线程5撤退!线程6撤退!线程9撤退!线程0撤退!线程3撤退!线程4撤退!线程7撤退!线程8撤退!结果:0 &lt;-countDownLatch 为0 才执行 CyclicBarrier java.util.concurrent Class CyclicBarrier java.lang.Object java.util.concurrent.CyclicBarrier public class CyclicBarrierextends Object 允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。 官方解释: A CyclicBarrier支持一个可选的Runnable命令，每个屏障点运行一次，在派对中的最后一个线程到达之后，但在任何线程释放之前。 在任何一方继续进行之前，此屏障操作对更新共享状态很有用。 个人解释: 当阻塞的线程到达一定的数量,线程才会继续执行cyclicBarrier定义好的 123456789101112131415161718192021222324public static void CyclicBarrierTest() &#123; System.out.println("CyclicBarrier"); CyclicBarrier cyclicBarrier = new CyclicBarrier(9, () -&gt; &#123; System.out.println("九之极, 万物演化"); &#125;); for (int i = 0; i &lt; 9; i++) &#123; int a = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "取得数据: " + a); try &#123; // 当给定数量的线程等待它时,它才会继续执行 cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "线程" + i).start(); &#125; // 获取等待线程的数量 System.out.println("获取等待线程的数量 " + cyclicBarrier.getParties());&#125; CyclicBarrier线程0取得数据: 0线程3取得数据: 3线程4取得数据: 4线程1取得数据: 1线程2取得数据: 2获取等待线程的数量 9线程6取得数据: 6线程5取得数据: 5线程7取得数据: 7线程8取得数据: 8九之极, 万物演化 &lt;- 9 Semaphore java.util.concurrent Class Semaphorejava.lang.Object java.util.concurrent.Semaphore All Implemented Interfaces:Serializable public class Semaphoreextends Objectimplements Serializable 一个计数信号量。 在概念上，信号量维持一组许可证。 如果有必要，每个acquire()都会阻塞，直到许可证可用，然后才能使用它。 每个release()添加许可证，潜在地释放阻塞获取方。 但是，没有使用实际的许可证对象; Semaphore只保留可用数量的计数，并相应地执行。 官方解释: ​ 信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源。 例如，这是一个使用信号量来控制对一个项目池的访问的类 ​ 在获得项目之前，每个线程必须从信号量获取许可证，以确保某个项目可用。 当线程完成该项目后，它将返回到池中，并将许可证返回到信号量，允许另一个线程获取该项目。 请注意，当调用acquire()时，不会保持同步锁定，因为这将阻止某个项目返回到池中。 信号量封装了限制对池的访问所需的同步，与保持池本身一致性所需的任何同步分开。 个人解释: 相当于 限流 1234567891011121314151617181920212223public static void SemaphoreTest() &#123; // 定义信号量 维持2个许可证 Semaphore semaphore = new Semaphore(2); for (int i = 0; i &lt; 9; i++) &#123; int a = i; new Thread(() -&gt; &#123; try &#123; // 从该信号量获取许可证，阻止直到可用，或线程为 interrupted (中断)。 semaphore.acquire(); System.out.println(Thread.currentThread().getName() + "取得数据: " + a); TimeUnit.SECONDS.sleep(1); System.out.println("等待线程数: " + semaphore.getQueueLength()); System.out.println(Thread.currentThread().getName() + ":1秒后丢弃数据: " + a); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放许可证，将其返回到信号量 semaphore.release(); &#125; &#125;, "线程" + i).start(); &#125; &#125; 结果: 线程2取得数据: 2线程0取得数据: 0等待线程数: 7 &lt;–等待线程数: 7 &lt;–线程2:1秒后丢弃数据: 2线程0:1秒后丢弃数据: 0线程1取得数据: 1线程3取得数据: 3等待线程数: 5 &lt;–等待线程数: 5 &lt;–线程1:1秒后丢弃数据: 1线程3:1秒后丢弃数据: 3线程5取得数据: 5线程6取得数据: 6等待线程数: 3 &lt;–线程5:1秒后丢弃数据: 5等待线程数: 3 &lt;–线程4取得数据: 4线程6:1秒后丢弃数据: 6线程7取得数据: 7等待线程数: 1 &lt;–线程4:1秒后丢弃数据: 4等待线程数: 1 &lt;–线程7:1秒后丢弃数据: 7线程8取得数据: 8等待线程数: 0 &lt;–线程8:1秒后丢弃数据: 8 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级_JUC]]></title>
    <url>%2F2020%2F06%2F16%2FJava%E9%AB%98%E7%BA%A7-JUC%2F</url>
    <content type="text"><![CDATA[并发 java.util.concurrent. 并发—-&gt;充分利用CPU的资源 java.util.concurrent.atomic 原子性 java.util.concurrent.locks 锁 对于锁,可以去看一下&lt;Java中级-多线程一二三&gt;,以后在整理好,抱歉 现在主要讲的是并发下,集合 List, Set , Map的安全问题 对于List集合先看一个List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 123456789101112131415161718192021222324252627282930313233public static void listSate() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 单线程添加数据 for (int i = 0; i &lt; 10; i++) &#123; list.add(UUID.randomUUID().toString().substring(0, 3)); System.out.println(list); &#125; System.out.println("单线程正常添加10个数据:" + list.size()); System.out.println("==========================================="); // 多线程添加数据 List&lt;String&gt; listThread = new ArrayList&lt;String&gt;(); // 不安全 Thread[] ts = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; Thread t = new Thread(() -&gt; &#123; listThread.add(UUID.randomUUID().toString().substring(0, 3)); System.out.println(Thread.currentThread().getId() + "多线程添加数据: \n" + listThread); &#125;, "线程" + i); ts[i] = t; t.start(); &#125; for (Thread t : ts) &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("多线程正常添加10个数据:" + listThread.size()); System.out.println("多线程正常添加10个数据:" + listThread); &#125; 结果: [67a][67a, 501][67a, 501, a85][67a, 501, a85, 934][67a, 501, a85, 934, e9d][67a, 501, a85, 934, e9d, e6c][67a, 501, a85, 934, e9d, e6c, 402][67a, 501, a85, 934, e9d, e6c, 402, 016][67a, 501, a85, 934, e9d, e6c, 402, 016, 24b][67a, 501, a85, 934, e9d, e6c, 402, 016, 24b, be6] 单线程正常添加10个数据:10 15多线程添加数据:[8a0, bfe]14多线程添加数据:[8a0, bfe]16多线程添加数据:[8a0, bfe, 556]17多线程添加数据:[8a0, bfe, 556, 8f9, ef1]Exception in thread “线程4” Exception in thread “线程7” Exception in thread “线程8” 19多线程添加数据:[8a0, bfe, 556, 8f9, ef1, ac1]23多线程添加数据:[8a0, bfe, 556, 8f9, ef1, ac1, e8d, 512, 348]20多线程添加数据:[8a0, bfe, 556, 8f9, ef1, ac1, e8d, 512, 348, 444]java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at java.util.AbstractCollection.toString(AbstractCollection.java:461) 最后发现,在多线程操作的时候,报了ConcurrentModificationException异常 ( 翻译过来就是 并发修改异常 ) 解决办法: 三种: 123List&lt;String&gt; listThread =Collections.synchronizedList(new ArrayList&lt;String&gt;()); // 安全List&lt;String&gt; listThread = new Vector&lt;String&gt;(); // 安全List&lt;String&gt; listThread = new CopyOnWriteArrayList&lt;String&gt;(); // 安全 第一种: 采用集合工具类提供的安全方法Collections.synchronizedList() 第二种是使用List 的子类 Vector 是支持同步的 第三种是使用CopyOnWriteArrayList类 结果就是 :不报异常 对于Set集合先看一个: 1234567891011121314151617181920212223242526272829public static void SetSafe() &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; 10; i++) &#123; set.add(UUID.randomUUID().toString().substring(0, 3)); System.out.println(set); &#125; System.out.println("单线程正常添加10个数据:" + set.size()); System.out.println("==========================================="); /Set&lt;String&gt; setTread = new HashSet&lt;String&gt;(); // 不安全 Thread[] ts = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; Thread t = new Thread(() -&gt; &#123; setTread.add(UUID.randomUUID().toString().substring(0, 3)); System.out.println(Thread.currentThread().getId() + "多线程添加数据: \n" + setTread); &#125;, "线程" + i); ts[i] = t; t.start(); &#125; for (Thread t : ts) &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("多线程正常添加10个数据:" + setTread.size()); System.out.println("多线程正常添加10个数据:" + setTread); &#125; 结果: 同样是抛出异常 ConcurrentModificationException 解决办法: 两种: 12Set&lt;String&gt; setTread = Collections.synchronizedSet(new HashSet&lt;String&gt;()); // 安全Set&lt;String&gt; setTread = new CopyOnWriteArraySet&lt;String&gt;(); // 安全 第一种: 采用Collections集合工具类提供的Collections.synchronizedSet()方法 第二章:采用CopyOnWriteArraySet类 结果就是不报异常 对于Map集合先看一个 12345678910111213141516171819202122232425262728public static void mapSafe() &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); for (int i = 0; i &lt; 10; i++) &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 3)); System.out.println(map); &#125; System.out.println("单线程正常添加10个数据:" + map.size()); System.out.println("==========================================="); Map&lt;String, String&gt; mapTread = new HashMap&lt;String, String&gt;(); 不安全 Thread[] ts = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; Thread t = new Thread(() -&gt; &#123; mapTread.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 3)); System.out.println(mapTread.values()); &#125;, "线程" + i); ts[i] = t; t.start(); &#125; for (Thread t : ts) &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("多线程正常添加10个数据:" + mapTread.size()); &#125; 结果: 报异常 解决办法两个 123Map&lt;String, String&gt; mapTread = new Hashtable&lt;String, String&gt;(); // 安全Map&lt;String, String&gt; mapTread = Collections.synchronizedMap(new HashMap&lt;String, String&gt;()); // 安全Map&lt;String, String&gt; mapTread = new ConcurrentHashMap&lt;String, String&gt;(); // 安全 第一种:采用Map的子类HashTable 第二种:采用集合工具类Collections.synchronizedMap() 第三种:采用 ConcurrentHashMap 类 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_多线程三]]></title>
    <url>%2F2020%2F06%2F16%2FJava%E4%B8%AD%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Lockjava.util.concurrent.locksInterface Lock 所有已知实现类：ReentrantLock ， ReentrantReadWriteLock.ReadLock ， ReentrantReadWriteLock.WriteLock 本章主要讲的是ReentrantLock 这个子类 与Snychronized的区别 先看一先Snychronized对锁的把控 12345678910111213141516171819202122232425262728293031323334353637383940/** * * @Title: snychronizedTest * @Description: synchronized的简单演示 * @return void 返回类型 * @Date 2020年6月16日 */ public static void snychronizedTest() &#123; final Object o = new Object(); new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); synchronized (o) &#123; try &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程a").start(); ; new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); synchronized (o) &#123; try &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程b").start(); ; &#125; 结果: 11:41:35线程a开始运行…11:41:35线程b开始运行…11:41:35线程a试图占有对象…11:41:35线程b试图占有对象…11:41:35线程a占有对象…11:41:38线程a释放对象11:41:38线程a线程结束.11:41:38线程b占有对象…11:41:41线程b释放对象11:41:41线程b线程结束. 接下来就看一下Lock的 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * * @Title: lockTest * @Description: lock(),unlock() * @return void 返回类型 * @Date 2020年6月16日 */ public static void lockTest() &#123; ReentrantLock lock = new ReentrantLock(); new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); lock.lock(); try &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程a").start(); ; new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); lock.lock(); try &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程b").start(); ; &#125; 结果: 11:40:48线程b开始运行…11:40:48线程a开始运行…11:40:48线程b试图占有对象…11:40:48线程a试图占有对象…11:40:48线程b占有对象…11:40:51线程b占有对象完毕11:40:51线程b释放对象11:40:51线程a占有对象…11:40:51线程b线程结束.11:40:54线程a占有对象完毕11:40:54线程a释放对象11:40:54线程a线程结束. Lock-线程交互 Synchronize中使用是的wait(),notify(); 而,Lock使用的子类ReentrantLock并没有这两个方法 但是我们在官网看对Lock接口的介绍 讲到 public interface Lock Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition 可以看到有这么一个Condition 我们看一下官方对Condition的介绍 public interface Condition Condition因素出Object监视器方法（ wait ， notify和notifyAll ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果Lock个实现。 Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。 到这里,可以知道Condition是我们需要的了看一下Conditon的方法 1234567891011121314void await() 导致当前线程等到发信号或 interrupted 。 boolean await(long time, TimeUnit unit) 使当前线程等待直到发出信号或中断，或指定的等待时间过去。 long awaitNanos(long nanosTimeout) 使当前线程等待直到发出信号或中断，或指定的等待时间过去。 void awaitUninterruptibly() 使当前线程等待直到发出信号。 boolean awaitUntil(Date deadline) 使当前线程等待直到发出信号或中断，或者指定的最后期限过去。 void signal() 唤醒一个等待线程。 void signalAll() 唤醒所有等待线程。 可以看出,对应Synchronized的（ wait ， notify和notifyAll ）的Condition方法是 ( await() , signal() , signalAll() ) ; 再看一下官方给出的用法 12345678910111213141516171819202122232425262728293031 class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 现在来使用一下 123456789101112131415161718192021222324252627282930313233343536373839404142public static void lockConditonTest() &#123; ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); lock.lock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); try &#123; Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "临时释放对象,并进行等待2s之后的唤醒"); condition.await(2, TimeUnit.SECONDS); System.out.println(nowdateTest() + Thread.currentThread().getName() + "等待结束,重新占有"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程a").start(); new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); lock.lock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); try &#123; Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "临时释放对象,并唤醒等待线程..."); condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程b").start(); ; &#125; 结果: 11:40:03线程a开始运行…11:40:03线程b开始运行…11:40:03线程b试图占有对象…11:40:03线程a试图占有对象…11:40:03线程b占有对象…11:40:06线程b临时释放对象,并唤醒等待线程…11:40:06线程a占有对象…11:40:06线程b释放对象11:40:06线程b线程结束.11:40:09线程a临时释放对象,并进行等待2s之后的唤醒11:40:11线程a等待结束,重新占有11:40:13线程a释放对象11:40:13线程a线程结束. 再介绍一下Lock的非阻塞获取锁的方法 Lock实现提供了使用synchronized方法和语句的附加功能，通过提供非阻塞尝试来获取锁（ tryLock() ），尝试获取可被中断的锁（ lockInterruptibly()） ，以及尝试获取可以超时（ tryLock(long, TimeUnit) ）。 看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void trylockTest() &#123; ReentrantLock lock = new ReentrantLock(); new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); boolean tryLock = false; try &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); tryLock = lock.tryLock(2, TimeUnit.SECONDS); if (tryLock) &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象完毕"); &#125; else &#123; System.out.println("试图占领失败,撤退"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (tryLock) &#123; lock.unlock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程a").start(); ; new Thread(() -&gt; &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "开始运行..."); boolean tryLock = false; try &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "试图占有对象..."); tryLock = lock.tryLock(2, TimeUnit.SECONDS); if (tryLock) &#123; System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象..."); Thread.sleep(3000); System.out.println(nowdateTest() + Thread.currentThread().getName() + "占有对象完毕"); &#125; else &#123; System.out.println("试图占领失败,撤退"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (tryLock) &#123; lock.unlock(); System.out.println(nowdateTest() + Thread.currentThread().getName() + "释放对象"); &#125; &#125; System.out.println(nowdateTest() + Thread.currentThread().getName() + "线程结束."); &#125;, "线程b").start(); ; &#125; 结果: 11:44:47线程b开始运行…11:44:47线程a开始运行…11:44:47线程b试图占有对象…11:44:47线程a试图占有对象…11:44:47线程a占有对象…试图占领失败,撤退11:44:49线程b线程结束.11:44:50线程a占有对象完毕11:44:50线程a释放对象11:44:50线程a线程结束. 对于tryLock() ,在释放锁的时候,一定要判断一下是否拿到了锁,要不然会报java.lang.IllegalMonitorStateException 是不是以为到这里就结束了? 不,没有, 对于多线程,知道这是可以充分利用我们的CPU资源,但是如果多个线程都同时对一个变量进行修改,会发生什么? 结果有可能正常:但也有可能不正常; 比如 int i = i ++这行代码,很简单是不是,但是但多个线程访问的时候,你猜猜会发生什么?咱们代码来解释一切问题,请看 123456789101112131415161718192021222324static int a = 0; public static void aomticITest() &#123; int s = 10000; Thread[] ts = new Thread[s]; for (int i = 0; i &lt; s; i++) &#123; Thread t = new Thread(() -&gt; &#123; a++; &#125;, "----线程" + i); t.start(); ts[i] = t; &#125; for (Thread thread : ts) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s+ "个线程后a的值:" +a); &#125; 结果: 10000个线程后a的值:10000 10000个线程后a的值:9999 10000个线程后a的值:9997 这里运算了3个结果; 虽然加锁可以实现保证得到正确的结果,但这里研究Aomtic就不加锁了 所以这时候就有原子操作出现了 | int | incrementAndGet() 原子上增加一个当前值。 || —– | ——————————————- || | | 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int a = 0; private static AtomicInteger atomicA =new AtomicInteger();public static void aomticITest() &#123; int s = 10000; Thread[] ts = new Thread[s]; Thread[] tss = new Thread[s]; for (int i = 0; i &lt; s; i++) &#123; Thread t = new Thread(() -&gt; &#123; a++; &#125;, "----线程" + i); t.start(); ts[i] = t; &#125; for (Thread thread : ts) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s+ "个线程后a的值:" +a); for (int i = 0; i &lt; s; i++) &#123; Thread t = new Thread(() -&gt; &#123; atomicA.incrementAndGet(); &#125;, "----线程" + i); t.start(); tss[i] = t; &#125; for (Thread thread : tss) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s+ "个线程后atomicA的值:" +atomicA);&#125; 结果: 10000个线程后a的值:999810000个线程后atomicA的值:10000 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_多线程二]]></title>
    <url>%2F2020%2F06%2F15%2FJava%E4%B8%AD%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[synchronized 1.怎么创建多线程 2.怎么保证多线程修改同一数据的同步性 3.使用线程池创建多线程 时间问题，先看代码 角色类 12345678910111213141516171819202122232425262728293031323334353637public class Role &#123; private String name; private Integer hp; private Integer ack; // 血量减少 public synchronized int delhp(int hp) &#123; while (hp &lt;= 0) &#123; try &#123; System.out.println("血量为0,等待!"); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; hp = hp - 50; this.notify(); return hp; &#125; // 血量增加 public synchronized int addhp(int hp) &#123; while (hp &gt;= 999) &#123; try &#123; System.out.println("血量达到上限999,停止恢复!"); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; hp = hp + 100; this.notify(); return hp; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738394041public static void test1() &#123; Role role = new Role(); role.setName("张三"); role.setHp(500); int n = 1; // 1.使用的创建线程的方式启动好几线程 for (int i = 0; i &lt; n; i++) &#123; Thread t = new Thread(() -&gt; &#123; while (true) &#123; int addhp = role.addhp(role.getHp()); role.setHp(addhp); System.out.println(Thread.currentThread().getName() + "线程--加血后:" + role.getHp()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, UUID.randomUUID().toString().substring(0, 5)); t.start(); &#125; int m = 1; // 1.使用的创建线程的方式启动好几线程 for (int i = 0; i &lt; m; i++) &#123; Thread tt = new Thread(() -&gt; &#123; while (true) &#123; int delhp = role.delhp(role.getHp()); role.setHp(delhp); System.out.println(Thread.currentThread().getName() + "线程掉血--后:" + role.getHp()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, UUID.randomUUID().toString().substring(0, 5)); tt.start(); &#125; &#125; 结果： 36668线程–加血后:65036668线程–加血后:60014a84线程掉血–后:60036668线程–加血后:70014a84线程掉血–后:80036668线程–加血后:80036668线程–加血后:90014a84线程掉血–后:100036668线程–加血后:1000血量达到上限999,停止恢复! 14a84线程掉血–后:950血量达到上限999,停止恢复! ….. 线程池 线程池类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MyThreadPool &#123; // 线程池大小; private int poolSize; // 任务集合 LinkedList&lt;Runnable&gt; tasks = new LinkedList&lt;Runnable&gt;(); public MyThreadPool() &#123; poolSize = 10; synchronized (tasks) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; new TaskThread("线程" + i).start(); &#125; &#125; &#125; public void add(Runnable task) &#123; synchronized (tasks) &#123; tasks.add(task); // 唤醒线程池中等待的线程 tasks.notifyAll(); &#125; &#125; // 创建线程任务类 class TaskThread extends Thread &#123; // 构造方法 public TaskThread(String name) &#123; super(name); &#125; Runnable task; public void run() &#123; System.out.println("启动:" + this.getName()); while (true) &#123; synchronized (tasks) &#123; while (tasks.isEmpty()) &#123; System.out.println("没有任务!休息"); try &#123; tasks.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 从线程池中拿一个线程出来 task = tasks.removeLast(); // 唤醒所有线程 tasks.notifyAll(); &#125; System.out.println(this.getName() + "接到任务,执行"); task.run(); &#125; &#125; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) &#123;// ThreadPool pool = new ThreadPool(); MyThreadPool pool = new MyThreadPool(); Role role = new Role(); role.setName("张三"); role.setHp(500); for (int i = 0; i &lt; 5; i++) &#123; Runnable task = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; int addhp = role.addhp(role.getHp()); role.setHp(addhp); System.out.println(Thread.currentThread().getName() + "线程--加血后:" + role.getHp()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; pool.add(task); &#125; for (int i = 0; i &lt; 5; i++) &#123; Runnable task = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; int delhp = role.delhp(role.getHp()); role.setHp(delhp); System.out.println(Thread.currentThread().getName() + "线程掉血--后:" + role.getHp()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; pool.add(task); &#125; &#125; 结果: … 线程9接到任务,执行线程7接到任务,执行线程8接到任务,执行线程7线程–加血后:800线程9线程–加血后:700线程6线程–加血后:600没有任务!休息线程1接到任务,执行没有任务!休息线程8线程–加血后:900没有任务!休息线程1线程–加血后:1000没有任务!休息线程2接到任务,执行线程5接到任务,执行 … 最后看一下,wait sleep 区别 类不同 : ​ wait -&gt; object ​ sleep: Thread 锁的释放: ​ wait -&gt; 会释放锁 ​ sleep -&gt; 抱着锁睡觉 作用范围: ​ wait :同步代码块中 ​ sleep: 没有限制 异常: ​ wait: 不需要捕获异常 ​ sleep: 需要捕获异常 小唠嗑： 想更加深入的了解多线程的使用,进看《Java中级_多线程三》篇 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_springboot2]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-springboot2%2F</url>
    <content type="text"><![CDATA[SpringBoot 简介 Spring Boot(英文中是“引导”的意思)，是用来简化 Spring 应用的搭建到开发的过程。 应用开箱即用，只要通过 “just run”（可能是 java -jar 或 tomcat 或 maven 插件 run 或 shell 脚本），就可以启动项目。二者，Spring Boot 只要很少的 Spring 配置文件（例如那些 xml，property）。因为“习惯优先于配置”的原则，使得 Spring Boot 在快速开发应用和微服务架构实践中得到广泛应用。 什么是 spring boot？ SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。 05. 为什么要用 spring boot？ Spring Boot使编码变简单 Spring Boot使配置变简单 Spring Boot使部署变简单 Spring Boot使监控变简单 微服务是未来发展的趋势 项目会从传统架构慢慢转向微服务架构 Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。 SpringBoot 特性 自动配置：针对很多 Spring 应用程序常见的应用功能，Spring Boot 能自动提供相关配置；起步依赖：告诉 Spring Boot 需要什么功能，它就能引入需要的库； 命令行界面：这是 Spring Boot 的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建； Actuator：让你能够深入运行中的 Spring Boot 应用程序，一探究竟。 SpringBoot 核心 @SpringBootApplication 这个 Spring Boot 核心注解是由其它三个重要的注解组合，分别是： @SpringBootConfiguration 、 @EnableAutoConfiguration 和 @ComponentScan。 @ SpringBootConfiguration 点开查看发现里面还是应用了@Configuration。任何一个标注了@Configuration 的 Java 类定义的都是一个 JavaConfig 配置类。SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，这里的启动类标注了@Configuration 之后，本身其实也是一个 IoC 容器的配置类。 @EnableAutoConfiguration 是一个复合注解。最重要的是@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration 可以帮助 SpringBoot 应用将所有符合条件的@Configuration 配置都加载到当前 SpringBoot 使用的 IoC 容器。 @ComponentScan 这个注解在 Spring 中很重要，它对应 XML 配置中的元素， @ComponentScan 的功能其实就是自动扫描并加载符合条件的组件（比如@Component 和 @Repository 等）或者 bean 定义，最终将这些 bean 定义加载到 IoC 容器中。 107. spring boot 配置文件有哪几种类型？它们有什么区别？ Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。 108. spring boot 有哪些方式可以实现热部署？ SpringBoot热部署实现有两种方式： ①. 使用spring loaded ②. 使用spring-boot-devtools]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>springboot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_shiro]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-shiro%2F</url>
    <content type="text"><![CDATA[13.Shiro 的优点 > 简单的身份认证, 支持多种数据源 > 对角色的简单的授权, 支持细粒度的授权(方法级) > 支持一级缓存，以提升应用程序的性能； > 内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境 > 非常简单的加密 API > 不跟任何的框架或者容器捆绑, 可以独立运行 简述 Shiro 的核心组件 Shiro 架构 3 个核心组件: > Subject: 正与系统进行交互的人, 或某一个第三方服务. 所有 Subject 实例都被绑定到（且这是必须的）一个SecurityManager 上。 > SecurityManager: Shiro 架构的心脏, 用来协调内部各安全组件, 管理内部组件实例, 并通过它来提供安全管理的各种服务. SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。 当 Shiro 与一个 Subject 进行交互时, 实质上是幕后的 SecurityManager 处理所有繁重的 Subject 安全操作。 > Realms: 本质上是一个特定安全的 DAO. 当配置 Shiro 时, 必须指定至少一个 Realm 用来进行身份验证和/或授权. Shiro 提供了多种可用的 Realms 来获取安全相关的数据. 如关系数据库(JDBC), INI 及属性文件等. 可以定义自己 Realm 实现来代表自定义的数据源。 shiro认证过程 创建SecurityManager -&gt; 主体提交认证 -&gt; SecurityManager认证 -&gt; Authenticator认证 -&gt; Realm验证 shiro 授权过程 创建SecurityManager -&gt;主体授权 -&gt; securityManager授权 -&gt; Authorizer授权 -&gt;Realm获取权限数据]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>shrio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_mysql]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-mysql%2F</url>
    <content type="text"><![CDATA[164. 数据库的三范式是什么？ 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。 第三范式：任何非主属性不依赖于其它非主属性。 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？ 表类型如果是 MyISAM ，那 id 就是 8。 表类型如果是 InnoDB，那 id 就是 5。 InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。 166. 如何获取当前数据库版本？ 使用 select version() 获取当前 MySQL 数据库版本。 167. 说一下 ACID 是什么？ Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 char 和 varchar 的区别是什么？ char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。 chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。 varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。 所以，空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。 169. float 和 double 的区别是什么？ float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。 double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。 170. mysql 的内连接、左连接、右连接有什么区别？ 内连接关键字：inner join；左连接：left join；右连接：right join。 内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。 173. 说一下数据库的事务隔离？ MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。 READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。 REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。 SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。 不可重复读 ：是指在一个事务内，多次读同一数据。 幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。 174. 说一下 mysql 常用的引擎？ InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。 MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。 171. mysql 索引是怎么实现的？ 索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。 172. 怎么验证 mysql 的索引是否满足需求？ 使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。 explain 语法：explain select * from table where type=1。 175. 说一下 mysql 的行锁和表锁？ MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 176. 说一下乐观锁和悲观锁？ 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。 数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 177. mysql 问题排查都有哪些手段？ 使用 show processlist 命令查看当前所有连接信息。 使用 explain 命令查询 SQL 语句执行计划。 开启慢查询日志，查看慢查询的 SQL。 178. 如何做 mysql 的性能优化？ 为搜索字段创建索引。 避免使用 select *，列出需要查询的字段。 垂直分割分表。 选择正确的存储引擎。]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_springmvc]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-springmvc%2F</url>
    <content type="text"><![CDATA[SpringMvc面试题 1**、什么是**Spring MVC ？简单介绍下你对**springMVC的理解?** Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。 2**、SpringMVC的流程？** 具体步骤： 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找） 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view） 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 第十一步：前端控制器向用户响应结果 3**、Springmvc的优点**: （1）可以支持各种视图技术,而不仅仅局限于JSP； （2）与Spring框架集成（如IoC容器、AOP等）； （3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。 （4） 支持各种请求资源的映射策略。 4**、Spring MVC的主要组件？** （1）前端控制器 DispatcherServlet（不需要程序员开发） 作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。 （2）处理器映射器HandlerMapping（不需要程序员开发） 作用：根据请求的URL来查找Handler （3）处理器适配器HandlerAdapter 注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。 （4）处理器Handler（需要程序员开发） （5）视图解析器 ViewResolver（不需要程序员开发） 作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view） （6）视图View（需要程序员开发jsp） View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等） 6**、SpringMVC怎么样设定重定向和转发的？** （1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4” （2）重定向：在返回值前面加”redirect:”，譬如”redirect:http://www.baidu.com&quot; 7**、SpringMvc怎么和AJAX相互调用的？** 通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ： （1）加入Jackson.jar （2）在配置文件中配置json的映射 （3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。 8**、如何解决POST请求中文乱码问题，GET的又如何处理呢？** （1）解决post请求乱码问题： 在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8； （2）get请求中文参数出现乱码解决方法有两个： ①修改tomcat配置文件添加编码与工程编码一致，如下： &lt;ConnectorURIEncoding=”utf-8” connectionTimeout=”20000” port=”8080” protocol=”HTTP/1.1” redirectPort=”8443”/&gt; ②另外一种方法对参数进行重新编码： String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。 9**、Spring MVC的异常处理 ？** 答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。 10**、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？** 答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。 11**、 SpringMVC**常用的注解有哪些？ @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。 @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。 12**、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？** 答：一般用@Conntroller注解,表示是表现层,不能用别的注解代替。 13**、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？** 答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。 10**、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？** 答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。 11**、 SpringMVC**常用的注解有哪些？ @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。 @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。 @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。 12**、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？** 答：一般用@Conntroller注解,表示是表现层,不能用别的注解代替。 13**、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？** 答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。 17**、SpringMvc中函数的返回值是什么？** 答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。 18**、SpringMvc用什么对象从后台向前台传递数据的？** 答：通过Model对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。 19**、怎么样把Model里面的数据放入Session里面？** 答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。 20**、SpringMvc里面拦截器是怎么写的：** 有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可： mvc:interceptors mvc:interceptor ​ &lt;mvc:mapping path=”/modelMap.do” /&gt; ​ &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 21**、注解原理：** 注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 @PathVariable：用于将请求 URL 中的模板变量映射到功能处理方法的参数上，即取出 uri 模板中的变量作为参数。 @CookieValue ：可以把 Request header 中关于 cookie 的值绑定到方法的参数上。 70. spring mvc 和 struts 的区别是什么？ 拦截机制的不同 Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。 SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 底层框架的不同 Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后销毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。 性能方面 Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入 SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。 配置方面 spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。 71. 如何避免 sql 注入？ PreparedStatement（简单又有效的方法） 正常情况下，用户的输入是作为参数值的，而在 SQL 注入中，用户的输入是作为 SQL 指令的一部分，会被数据库进行编译/解释执行。当使用了 PreparedStatement，带占位符 ( ? ) 的 sql 语句只会被编译一次，之后执行只是将占位符替换为用户输入，并不会再次编译/解释，因此从根本上防止了 SQL 注入问题。 String sql = “SELECT * FROM users WHERE name= ? “; PreparedStatement ps = connection.prepareStatement(sql); ps.setString(1, name); 使用正则表达式过滤传入的参数 字符串过滤 JSP中调用该函数检查是否包函非法字符 JSP页面判断代码 ​]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_mybatis]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-mybatis%2F</url>
    <content type="text"><![CDATA[什么是Mybatis？ Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC, 开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。 114. 什么是 ORM 框架？ 对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。 Mybatis**的好处？** 把Sql语句从Java中独立出来。 封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了Java数据库编程的重复工作。 自己编写Sql语句，更加的灵活。 入参无需用对象封装（或者map封装）,使用@Param注解 Mybaits**的优点：** 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，让sql与程序代码的解耦，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接； 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持） 能够与Spring很好的集成； 提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。 6、提供 xml 标签，支持编写动态 sql。 MyBatis**框架的缺点：** SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。 SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 什么是**Mybatis**的接口绑定，有什么好处？ Mybatis实现了DAO接口与xml映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。 Mybatis**在核心处理类叫什么**? SqlSession 查询表名和返回实体**Bean**对象不一致，如何处理？ 映射键值对即可 ${} 和 #{}**的区别？** ${}：简单字符串替换，把${}直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句。 #{}：预编译处理，sql中的#{}替换成？，补全预编译语句，有效的防止Sql语句注入，这种取值是编译好SQL语句再取值。 总结：一般用#{}来进行列的代替 获取上一次自动生成的主键值？ select last _insert_id() Mybatis**工作原理？** 原理： 通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件中构建出SqlSessionFactory。 SqlSessionFactory开启一个SqlSession，通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句。 完成数据库的CRUD操作和事务提交，关闭SqlSession。 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？ 第1种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。 第2种：通过来映射字段名和实体类属性名的一一对应的关系。 模糊查询**like语句该怎么写?** name like “%”#{name}”%” and phone like concat(concat(“%”,#{phone}),”%”) 如何获取自动生成的**(主)键值?** insert 方法总是返回一个int值 ，这个值代表的是插入的行数。 如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。 insert into names (name) values (#{name}) Mybatis**动态sql有什么用？执行原理？有哪些动态sql？** Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。 Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。 18**、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？** Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 22**、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？** 答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 延迟加载主要是通过动态代理的形式实现，通过代理拦截到指定方法，执行数据加载。 21**、MyBatis实现一对多有几种方式,怎么操作的？** 有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。 23**、Mybatis的一级、二级缓存**: 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ； 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 24**、什么是MyBatis的接口绑定？有哪些实现方式？** 接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。 接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。 26**、Mapper编写有哪几种方式？** 第一种：接口实现类继承SqlSessionDaoSupport：使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件。 在sqlMapConfig.xml中配置mapper.xml的位置 定义mapper接口 实现类集成SqlSessionDaoSupport mapper方法中可以this.getSqlSession()进行数据增删改查。 spring 配置 第二种：使用org.mybatis.spring.mapper.MapperFactoryBean： 在sqlMapConfig.xml中配置mapper.xml的位置，如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置 定义mapper接口： mapper.xml中的namespace为mapper接口的地址 mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致 Spring中定义 第三种：使用mapper扫描器： mapper.xml文件编写： mapper.xml中的namespace为mapper接口的地址； mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致； 如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置。 定义mapper接口： 注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录 配置mapper扫描器： 使用扫描器后从spring容器中获取mapper的实现对象。 27**、简述Mybatis的插件运行原理，以及如何编写一个插件。** 答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。 28,**为什么SpringMVC可以正确解析方法参数名称，但MyBatis却不行？** MyBatis 是通过接口跟 SQL 语句绑定然后生成代理类来实现的，因此它无法通过解析字节码来获取方法参数名。 125. mybatis 中 #{}和 ${}的区别是什么？ #{}是预编译处理，${}是字符串替换； Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； Mybatis在处理${}时，就是把${}替换成变量的值； 使用#{}可以有效的防止SQL注入，提高系统安全性。 126. mybatis 有几种分页方式？ 数组分页 sql分页 拦截器分页 RowBounds分页 128. mybatis 逻辑分页和物理分页的区别是什么？ 逻辑分页: 在分页的时候,我们是把所有的数据都查询出来,然后通过RowBounds进行在内存分页.通过源码查看,也是通过ResuleSet结果集进行分页; 物理分页: 直接通过SQL进行在数据库中直接分页,得到的数据就是我们想要分页之后的数据,就是物理分页; 物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。 物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。 132. mybatis 有哪些执行器（Executor）？ Mybatis有三种基本的执行器（Executor）： SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 133. mybatis 分页插件的实现原理是什么？ 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 134. mybatis 如何编写一个自定义插件？ Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为： Executor：拦截执行器的方法(log记录) StatementHandler ：拦截Sql语法构建的处理 ParameterHandler ：拦截参数的处理 ResultSetHandler ：拦截结果集的处理 Mybatis**和hibernate的区别:** hibernate是一个自动化更强、更高级的框架，毕竟在java代码层面上，省去了绝大部分sql编写，取而代之的是用面向对象的方式操作关系型数据库的数据。而MyBatis则是一个能够灵活编写sql语句，并将sql的入参和查询结果映射成POJOs的一个持久层框架。所以， 从表面上看，hibernate能方便、自动化更强，而MyBatis 在Sql语句编写方面则更灵活自由。 对于数据的操作，hibernate是面向对象的，而MyBatis是面向关系的]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_spring]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-spring%2F</url>
    <content type="text"><![CDATA[Spring的三大核心思想： IOC(控制反转)，DI(依赖注入)，AOP（面向切面编程） Spring目的： 就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的, 解决企业应用开发的复杂性 Spring的作用: \1. 基于POJO的轻量级和最小侵入性编程； \2. Spring的非入侵式就是不强制类要实现Spring的任何接口或类，没有任何地方表明它是一个Spring组件。 意味着这个类在Spring应用和非Spring应用中都可以发挥同样的作用。 \3. 通过依赖注入和面向接口实现松耦合； \4. 基于切面和惯例进行声明式编程； \5. 通过切面和模板减少样板式代码。 90. 为什么要使用 spring？ 2.轻量 从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。 3.控制反转 Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 4.面向切面 Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 5.容器 Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。 6.框架 Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。 所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持. Spring MVC 框架： MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring MVC 比较 Struts2: ①. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter ②. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action. ③. Spring MVC 使用更加简洁, 开发效率 Spring MVC 确实比 struts2 高: 支持 JSR303, 处理 ajax 的请求更方便 ④. Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些. 1**、**Spring 在**ssm**中起什么作用？ Spring：轻量级框架 作用：Bean工厂，用来管理Bean的生命周期和框架集成。 两大核心： ①. IOC/DI(控制反转/依赖注入) ：把dao依赖注入到service层，service层反转给action层，Spring顶层容器为BeanFactory。 ②. AOP：面向切面编程 2**、Spring的事务？** 编程式事务管理：编程方式管理事务，极大灵活性，难维护。 声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。 3**、**IOC 在项目中的作用？ 作用：Ioc解决对象之间的依赖问题，把所有Bean的依赖关系通过配置文件或注解关联起来，降低了耦合度。 4**、Spring的配置文件中的内容？** 开启事务注解驱动 事务管理器 开启注解功能，并配置扫描包 配置数据库 配置SQL会话工厂，别名，映射文件 5**、Spring下的注解？** 几种比较重要的注解类型： 1.@Required：该注解应用于设值方法。 2.@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 3.@Qualifier：该注解和@Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 4.JSR-250 Annotations： Spring 支持基于 JSR-250 注解的以下注解，@Resource、 @PostConstruct 和 @PreDestroy。 注册：@Controller @Service @Component 注入：@Autowired 请求地址：@RequestMapping 返回具体数据类型而非跳转：@ResponseBody 6**、**Spring DI 的三种方式**?** 构造器注入：通过构造方法初始化 setter方法注入：通过setter方法初始化 接口注入**/**基于注解的注入 7**、Spring主要使用了什么模式？** 工厂模式：每个Bean的创建通过方法 单例模式：默认的每个Bean的作用域都是单例 代理模式：关于Aop的实现通过代理模式 8**、IOC，AOP的实现原理？** IOC：通过反射机制生成对象注入 AOP：动态代理 IoC(Inversion of Control,**控制反转**) 是一种解耦的设计思想,它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。 Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。 增加了项目的可维护性且降低了开发难度 DI(Dependecy Inject,**依赖注入**)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。 AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善, 它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。 工厂设计模式 Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。 两者对比： BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于BeanFactory来说会占用更少的内存，程序启动速度更快。 ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。 ApplicationContext的三个实现类： ClassPathXmlApplication：把上下文文件当成类路径资源。 FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。 XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。 单例设计模式 在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。 使用单例模式的好处: 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销； 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。 Spring 中 bean 的默认作用域就是 singleton(单例)的。 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域： prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 实现单例的方式： xml: 注解：@Scope(value = “singleton”) 代理设计模式 代理模式在 AOP 中的应用 AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理 当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。 使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。 Spring AOP 和 AspectJ AOP 有什么区别? Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。 模板方法 模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。 Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。 在 Spring 中，所有管理的对象都是 JavaBean 对象，而 BeanFactory 和 ApplicationContext 就是 spring 框架的两个 IOC 容器，现在一般使用 ApplicationContext，其不但包含了 BeanFactory 的作用，同时还进行更多的扩展。 Spring Bean 生命周期 1.Spring 容器 从 XML 文件中读取 Bean 的定义，并实例化 Bean。 2.Spring 根据 Bean 的定义填充所有的属性。 3.如果 Bean 实现了 BeanNameAware 接口，Spring 传递 bean 的 ID 到 setBeanName 方法。 4.如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递 beanfactory 给 setBeanFactory 方法。 5.如 果 有 任 何 与 bean 相 关 联 的 BeanPostProcessors ， Spring 会 在postProcesserBeforeInitialization()方法内调用它们。 6.如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 bean 声明了初始化方法，调用此初始化方法。 7.如果有 BeanPostProcessors 和 bean 关联，这些 bean 的 postProcessAfterInitialization() 方法将被调用。 8.如果 bean 实现了 DisposableBean，它将调用 destroy()方法。注意： 有两个重要的 bean 生命周期方法，第一个是 setup() ， 它是在容器加载 bean 的时候被调用。第二个方法是 teardown() 它是在容器卸载类的时候被调用。 The bean 标签有两个重要的属性 init-method 和 destroy-method。使用它们你可以自己定制初始化和注销方法。它们也有相应的注解@PostConstruct 和@PreDestroy。 95. spring 中的 bean 是线程安全的吗？ Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。 96. spring 支持几种 bean 的作用域？ 当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域： singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例 prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例 request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效 session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效 globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效 如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。 97. spring 自动装配 bean 有哪些方式？ spring中bean装配有两种方式： 隐式的bean发现机制和自动装配 在java代码或者XML中进行显示配置 当然这些方式也可以配合使用。 98. spring 事务实现方式有哪些？ 编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。 基于 TransactionProxyFactoryBean 的声明式事务管理 基于 @Transactional 的声明式事务管理 基于 Aspectj AOP 配置事务 99. spring 的事务隔离？ 事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题： 脏读：一个事务读到另一个事务未提交的更新数据。 幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。 不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。 103. @Autowired 的作用是什么？ @Autowired表示被修饰的类需要注入对象,spring会扫描所有被@Autowired标注的类,然后根据 类型 在ioc容器中找到匹配的类注入。]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_JavaWeb]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-JavaWeb%2F</url>
    <content type="text"><![CDATA[64. jsp 和 servlet 有什么区别？ jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类） jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。 Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。 Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。 65. jsp 有哪些内置对象？作用分别是什么？ JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 66. jsp 的 4 种作用域？ JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 67. session 和 cookie 有什么区别？ 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来标识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 68. 说一下 session 的工作原理？ 其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。 69. 如果客户端禁止 cookie 能实现 session 还能用吗？ Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。 假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种： 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“–enable-trans-sid”选项，让PHP自动跨页传递Session ID。 手动通过URL传值、隐藏表单传递Session ID。 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。 72. 什么是 XSS 攻击，如何避免？ XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。 XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。 73. 什么是 CSRF 攻击，如何避免？ CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。 如何避免： \1. 验证 HTTP Referer 字段 HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。 使用验证码 关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。 在请求地址中添加token并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把token以参数的形式加入请求了。 在HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 异常 网络 79. http 响应码 301 和 302 代表的是什么？有什么区别？ 答：301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。 区别： 301 redirect: 301 代表永久性转移(Permanently Moved)。 302 redirect: 302 代表暂时性转移(Temporarily Moved )。 80. forward 和 redirect 的区别？ Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。 直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。 间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 举个通俗的例子： 直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”； 间接转发就相当于：”A找B借钱，B说没有，让A去找C借”。 81. 简述**TCP 和 UDP**的区别？ TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。 TCP对系统资源要求较多，UDP对系统资源要求较少。 84. OSI 的七层模型都有哪些？ 应用层：网络服务与最终用户的一个接口。 表示层：数据的表示、安全、压缩。 会话层：建立、管理、终止会话。 传输层：定义传输数据的协议端口号，以及流控和差错校验。 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。 物理层：建立、维护、断开物理连接。 85. get 和 post 请求有哪些区别？ GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 86. 如何实现跨域？ 方式一：图片ping或script标签跨域 图片ping常用于跟踪用户点击页面或动态广告曝光次数。 script标签可以得到从其他来源数据，这也是JSONP依赖的根据。 方式二：JSONP跨域 JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。 ​ 缺点： 只能使用Get请求 不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败 JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保 方式三：CORS Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种： Access-Control-Allow-Origin: * Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数： “Access-Control-Allow-Credentials”: true // Ajax设置 “withCredentials”: true 方式四：window.name+iframe window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。 iframe标签的跨域能力； window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。 每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。 方式五：window.postMessage() HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。 下述代码实现了跨域存储localStorage 注意Safari一下，会报错： Blocked a frame with origin “http://localhost:10001” from accessing a frame with origin “http://localhost:10000“. Protocols, domains, and ports must match. 避免该错误，可以在Safari浏览器中勾选开发菜单==&gt;停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。 方式六：修改document.domain跨子域 前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域 在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。 现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = ‘xxx.com’;设置一致，来达到互相访问的作用。 方式七：WebSocket WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。 方式八：代理 同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题 DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器） 来源：blog.csdn.net/ligang2585116/article/details/73072868 87. JSONP 实现原理？ jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。]]></content>
      <categories>
        <category>问题</category>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题_Java基础]]></title>
    <url>%2F2020%2F06%2F14%2F%E9%97%AE%E9%A2%98-Java%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[乱七八糟1.JDK 和 JRE 有什么区别？JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。 2.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 解答: 不对，两个对象的 hashCode()相同，equals()不一定 true。(两本书有着同样的书名和作者，但是它们是两本“不同”的书。) 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 equals equals()方法是用来判断其他的对象是否和该对象相等，它的性质有： 自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。 hashCode hashCode()方法给对象返回一个hash code值。这个方法被用于HashTable，HashMap。 它的性质是： 在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。 并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。 大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。 在每个改写了equals()方法的类中，必须要改写hashCode()方法。如果不这样做，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于hash的集合类结合在一起正常运作，这样的集合类包括HashMap、HashSet和HashTable。 需要注意的是: 这个hashCode()方法是合法的，因为相等的对象总是具有同样的散列码. 1public int hashCode() &#123; return 0; &#125; 但是它使得每一个对象都具有同样的散列码。因此，每个对象都被映射到同一个散列桶中，从而散列表被退化为链表。对于规模很大的散列表而言，这关系到散列表能否正常工作。 一个好的散列函数通常倾向于“7为不相等的对象产生不相等的散列码”。 如果一个类是非可变的，并且计算散列码的代价也比较大，那么你应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。 不要试图从散列码计算中排除掉一个对象的关键部分以提高性能 3.final 在 java 中有什么作用？ final 修饰的类叫最终类，该类不能被继承。 final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。 final 修饰的方法不能被重写。 4.String str=”i”与 String str=new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str=”i”的方式，(JVM java va)java 虚拟机会将其分配到常量池-&gt;方法区中； 而 String str=new String(“i”) 则会被分到堆内存中。 5.如何将字符串反转？使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 6.String 类的常用方法都有那些？indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 7.抽象类必须要有抽象方法吗？ 不需要，抽象类不一定非要有抽象方法。 在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧 8.普通类和抽象类有哪些区别？ 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 抽象类不能用来创建对象； 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 在其他方面，抽象类和普通的类并没有区别。 普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 9.java 中 IO 流分为几种？按功能来分：输入流（input）、输出流（output）。 按类型来分：字节流和字符流。 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。 10.BIO、NIO、AIO 有什么区别？BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 11.Files的常用方法都有哪些？Files.exists()：检测文件路径是否存在。 Files.delete()：删除一个文件或目录。 Files.read()：读取文件。 Files.write()：写入文件。 6）wait和sleep的区别，必须理解sleep方法属于线程，wait方法属于对象 sleep休眠当前线程，不会释放对象锁，wait使当前线程进入等待状态，释放对象锁，只有针对此对象调用notify()方法（且共享对象资源释放）后本线程才会继续执行 7）JVM的内存结构，JVM的算法JVM内存结构主要有三大块：堆内存、方法区和栈， 几乎所有的对象实例都存放在堆里，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 15）说说http,https协议http是一种超文本协议，默认端口80，以明文传输。 https是http协议的安全版，安全基础是SSL，以密文传输 16）osi五层网络协议应用层、传输层、网络层、数据链路层、物理层 18）说说tcp三次握手，四次挥手1.客户端向服务器发送一个syn包，进入发送状态 2.服务器收到syn包，确认客户的syn，并向客户端发送syn+ack包，进入接受状态 3.客户端接受的来自服务的的syn包信息，向服务的发出ack包，次数两者进入tcp连接成功状态 21）请写一段栈溢出、堆溢出的代码堆溢出，死循环存值，JVM就会抛出OutOfMemoryError:java heap space异常 12345678public static void main(String[] args) &#123; List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); int i=0; while(true)&#123; list.add(new byte[5*1024*1024]); System.out.println("分配次数："+(++i)); &#125; &#125;java 栈溢出，栈空间不足——StackOverflowError实例 12345678910111213141516public class StackSOFTest &#123; int depth = 0; public void sofMethod()&#123; depth ++ ; **sofMethod();** &#125; public static void main(String[] args) &#123; StackSOFTest test = null; try &#123; test = new StackSOFTest(); test.sofMethod(); &#125; finally &#123; System.out.println("递归次数："+test.depth); &#125; &#125; &#125; 29.说出一些常用的类，包，接口，请各举5个。注意：要让人家感觉你对java ee开发很熟，java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。 常用的类： BufferedReader BufferedWriter FileReader FileWirter String Integer java.util.Date System Class List HashMap 常用的包： java.lang java.io java.util java.sql javax.servlet org.apache.strtuts.action org.hibernate 常用的接口： Remote List Map Document NodeList Servlet HttpServletRequest HttpServletResponse Transaction(Hibernate) Session(Hibernate) HttpSession 33.描述一下JVM加载class文件的原理机制?Java语言是一种具有动态性的解释型语言，类（class）只有被加载到JVM后才能运行。当运行指定程序时，JVM会将编译生成的.class文件按照需求和一定的规则加载到内存中，并组织成为一个完整的Java应用程序，这个加载过程是由类加载器完成。 具体来说，就是由ClassLoader和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。 类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用new等方式创建对象时，会隐式地调用类的加载器把对应的类加载到JVM中。显示加载指的是通过直接调用class.forName()方法来把所需的类加载到JVM中。 任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到JVM中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。 此外，在Java语言中，每个类或接口都对应一个.class文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。 在Java语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到JVM中，至于其他类，则在需要的时候才加载：下面是加载的步骤： 初始化。对静态变量和静态代码块执行初始化工作。 装载。根据查找路径找到相应的class文件，然后导入。 链接。链接又可分为3个小步： 检查，检查待加载的class文件的正确性。 准备，给类中的静态变量分配存储空间。 解析，将符号引用转换为直接引用（这一步可选）。 方法中的局部变量使用final修饰后，放在堆中，而不是栈 35.堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？堆栈都是内存的可用区域，但是堆的速度慢容量大，栈的速度快容量小。一个64K的字符串，自然放在堆。 栈的内存是很宝贵的。 只有引用及基本数据类型是直接存在栈上。对象类型可能是在堆、方法区、常量池中；放到堆中还是放到栈中，jvm会根据你的数据类型决定。 栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） ：一般由程序员分配释放， 若程序员不释放，程序结束时可能由GC回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 36.GC是什么? 为什么要有GC?GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃。 Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 38.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。 通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。 不过垃圾回收机制的回收是不确定的，不一定会马上回收内存。 可以主动通知虚拟机进行垃圾回收：程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。实际上GC是一个守护线程(守护线程的作用是为其他线程提供服务)。 39.什么时候用assert？assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。 在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。 一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 123456789101112public class AssertTest &#123; public static void main(String[] args) &#123; int i = 0; for(i=0;i&lt;5;i++) &#123; System.out.println(i); &#125; //假设程序不小心多了一句--i; --i; assert i==5; &#125; &#125; 40.java中会存在内存泄漏吗，请简单描述。所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。 由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收： java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景(通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的）。 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 内存泄露的另外一种情况：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 41.能不能自己写个类，也叫java.lang.String？可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。 194.说一下 jvm 的主要组成部分？及其作用？类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 组件的作用: 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 197.队列和栈是什么？有什么区别？队列和栈都是被用来预存储数据的。 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。 栈对元素进行后进先出进行检索。 198.什么是双亲委派模型？在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 类加载器分类： 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库； 其他类加载器： 扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=“box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;”&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt; 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 \199. 说一下类加载的执行过程？类加载分为以下 5 个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 检查：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 200.怎么判断对象是否可以被回收？一般有两种方法来判断： 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 \201. java 中都有哪些引用类型？强引用 软引用 弱引用 虚引用 \202. 说一下 jvm 有哪些垃圾回收算法？标记-清除算法 标记-整理算法 复制算法 分代算法 203.说一下 jvm 有哪些垃圾回收器？Serial：最早的单线程串行垃圾回收器。 Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。 ParNew：是 Serial 的多线程版本。 Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。 CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。 204.详细介绍一下 CMS 垃圾回收器？CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低； 老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 \206. 简述分代垃圾回收器是怎么工作的？分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。 207.说一下 jvm 调优的工具？JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。 jconsole：用于对 JVM 中的内存、线程和类等进行监控； jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。 \208. 常用的 jvm 调优的参数都有哪些？ -Xms2g：初始化推大小为 2g； -Xmx2g：堆最大内存为 2g； -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4； -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2； –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合； -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合； -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合； -XX:+PrintGC：开启打印 gc 信息； -XX:+PrintGCDetails：打印 gc 详细信息。 2.你所知道网络协议有那些？HTTP：超文本传输协议 FTP：文件传输协议 SMPT：简单邮件协议 TELNET：远程终端协议 POP3：邮件读取协议 3.Java都有那些开发平台？JAVA SE：主要用在客户端开发 JAVA EE：主要用在web应用程序开发 JAVA ME：主要用在嵌入式应用程序开发 5.Java是否需要开发人员回收内存垃圾吗？ 大多情况下是不需要的。Java提供了一个系统级的线程来跟踪内存分配，不再使用的内存区将会自动回收 8.Java的数据结构有那些？线性表（ArrayList） 链表（LinkedList） 栈（Stack） 队列（Queue） 图（Map） 树（Tree） 9.什么是OOP?面向对象编程 10.什么是面向对象？世间万物都可以看成一个对象。每个物体包括动态的行为和静态的属性，这些就构成了一个对象。 11.类与对象的关系?类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例 12.Java中有几种数据类型整形：byte,short,int,long 浮点型：float,double 字符型：char 布尔型：boolean 13.什么是隐式转换，什么是显式转换显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。 14.Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；Char&lt;int&lt;long&lt;float&lt;double；Char类型可以隐式转成int,double类型，但是不能隐式转换成string；如果char类型转成byte，short类型的时候，需要强转。 15.什么是拆装箱？拆箱：把包装类型转成基本数据类型 装箱：把基本数据类型转成包装类型 16.Java中的包装类都是那些？byte：Byte short：Short int：Integer long：Long float：Float double：Double char：Character boolean：Boolean 17.一个java类中包含那些内容？属性、方法、内部类、构造方法、代码块。 18.例如： if(a+1.0=4.0)，这样做好吗？不好，因为计算机在浮点型数据运算的时候，会有误差，尽量在布尔表达式中不使用浮点型数据(if,while,switch中判断条件不使用浮点型) 19.那针对浮点型数据运算出现的误差的问题，你怎么解决？使用Bigdecimal类进行浮点型数据的运算 20.++i与i++的区别++i：先赋值，后计算 i++：先计算，后赋值 21.程序的结构有那些？顺序结构 选择结构 循环结构 22.数组实例化有几种方式？静态实例化：创建数组的时候已经指定数组中的元素, int[] a=new int[]{1,3,3} 动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值 23.Java中各种数据默认值Byte,short,int,long默认是都是0 Boolean默认值是false Char类型的默认值是’ ’ Float与double类型的默认是0.0 对象类型的默认值是null 26.Object类常用方法有那些？ Equals Hashcode toString wait notify clone getClass 28.java中是值传递引用传递？理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。 29.假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？改变了，因为传递是对象的引用，操作的是引用所指向的对象 30.实例化数组后，能不能改变数组长度呢？不能，数组一旦实例化，它的长度就是固定的 31.假设数组内有5个元素，如果对数组进行反序，该如何做？创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中 32.形参与实参形参：全称为“形式参数”，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值； 实参：全称为“实际参数”，是在调用方法时传递给该方法的实际值。 33.构造方法能不能显式调用？不能 构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用 36.内部类与静态内部类的区别？静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法； 普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。 如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象 37.Static关键字有什么作用？Static可以修饰内部类、方法、变量、代码块 Static修饰的类是静态类 Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。 Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。 Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。 38.Final在java中的作用Final可以修饰类，修饰方法，修饰变量。 修饰的类叫最终类。该类不能被继承。 修饰的方法不能被重写。 修饰的变量叫常量，常量必须初始化，一旦初始化后，常量的值不能发生改变。 39.Java中操作字符串使用哪个类？String，StringBuffer，StringBuilder 42.String str=”aa”,String s=”bb”,String aa=aa+s;一种创建了几个对象？一共有两个引用，三个对象。因为”aa”与”bb”都是常量，常量的值不能改变，当执行字符串拼接时候，会创建一个新的常量是” aabbb”,有将其存到常量池中。 43.将下java中的math类有那些常用方法？Pow()：幂运算 Sqrt()：平方根 Round()：四舍五入 Abs()：求绝对值 Random()：生成一个0-1的随机数，包括0不包括1 46.==与equlas有什么区别？==可以判断基本数据类型值是否相等，也可以判断两个对象指向的内存地址是否相同，也就是说判断两个对象是否是同一个对象，Equlas通常用来做字符串比较。 53.创建一个子类对象的时候，那么父类的构造方法会执行吗？会执行。当创建一个子类对象，调用子类构造方法的时候，子类构造方法会默认调用父类的构造方法。 54.什么是父类引用指向子类对象？是java多态一种特殊的表现形式。创建父类引用，让该引用指向一个子类的对象 55.当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？ 子类重写了父类方法和属性，访问的是父类的属性，调用的是子类的方法 60.抽象类可以使用final修饰吗？不可以。定义抽象类就是让其他继承的，而final修饰类表示该类不能被继承，与抽象类的理念违背了 64.接口有什么特点？接口中声明全是public static final修饰的常量 接口中所有方法都是抽象方法 接口是没有构造方法的 接口也不能直接实例化 接口可以多继承 68.异常的处理机制有几种？异常捕捉：try…catch…finally，异常抛出：throws。 69.如何自定义一个异常继承一个异常类，通常是RumtimeException或者Exception 70.在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？会执行，如果有finally，在finally之后被执行，如果没有finally，在catch之后被执行 72.Thow与thorws区别Throw写在代码块内，throws后面跟的是一个具体的异常实例 Throw写在方法前面后面，throws后面跟的是异常类，异常类可以出现多个 74.使用Log4j对程序有影响吗？有，log4j是用来日志记录的，记录一些关键敏感的信息，通常会将日志记录到本地文件或者数据库中。记录在本地文件中，会有频繁的io操作，会耗费一些系统资源。记录在数据库中，会频繁地操作数据库表，对系统性能也有一定的影响。但是为了程序安全以及数据的恢复或者bug的跟踪，这点资源消耗是可以承受的。 75.Log4j日志有几个级别？由低到高：debug、info、wran、error 77.Java反射创建对象效率高还是通过new创建对象的效率高？通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低 85.JDBC操作的步骤加载数据库驱动类 打开数据库连接 执行sql语句 处理返回结果 关闭资源 86.在使用jdbc的时候，如何防止出现sql注入的问题。使用PreparedStatement类，而不是使用Statement类 87.怎么在JDBC内调用一个存储过程使用CallableStatement 88.是否了解连接池，使用连接池有什么好处？数据库连接是非常消耗资源的，影响到程序的性能指标。 连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。 89.你所了解的数据源技术有那些？使用数据源有什么好处？Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全；通过配置文件的形式来维护数据库信息，而不是通过硬编码。 当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据库信息的更新。 91.常用io类有那些？File FileInputSteam，FileOutputStream BufferInputStream，BufferedOutputSream Print Write FileReader，FileWriter BufferReader，BufferedWriter 92.字节流与字符流的区别以字节为单位输入输出数据，字节流按照8位传输 以字符为单位输入输出数据，字符流按照16位传输 93.final、finalize()、finally性质不同 final为关键字； finalize()为方法； finally为区块标志，用于try语句中； 作用 final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）； finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）； finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行； 99.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 10、什么是 ThreadLocal？ThreadLocal 和 Synchonized 的区别？线程局部变量。是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。 synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而 ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。 6.深拷贝和浅拷贝： 简单来讲就是复制、克隆；Person p=new Person(“张三”); 浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错 深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间 7.值传递和引用传递： 值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量 引用传递：就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改 8.web 容器功能： 通信支持、管理Servlet生命周期，多线程、将jsp转换成java等等 9.java内存分配 寄存器：我们无法控制 静态域：static定义的静态成员 常量池：编译时被确定并保存在.class文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符） 非ram存储：硬盘等永久存储空间 堆内存：new创建的对象和数组，由java虚拟机自动垃圾回收器管理,存取速度慢 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性 11.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 13.简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。 条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型 逻辑操作不会产生短路. 使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算 14.说说&amp;和&amp;&amp;的区别。 ==相同点==：&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 ==&amp;&amp;具有短路功能==：即如果第一个表达式为false，则不再计算第二个表达式。 15.switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。long不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它不能作用于swtich语句中。 对于string而言：JDK1.7以前是不能作为switch的，以后即可以作用于switch中。 17.char型变量中能不能存贮一个中文汉字?为什么?char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字。 不过要注意的是： 如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字 unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 18.用最有效率的方法算出2乘以8等於几?方法：将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8（2的3次方），只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是将2左移3位，即2 &lt;&lt; 3。 19.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：final StringBuffer a=new StringBuffer(“immutable”); 执行如下语句将报告编译期错误：a=new StringBuffer(“”); 但是，执行如下语句则可以通过编译：a.append(“ broken!”); java有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： public void method(final StringBuffer param) { } 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(“a”); 20.java 中对象的创建方法有几种？通过new来创建 通过反射创建 通过复制创建 21.”==”和equals方法究竟有什么区别？ 如果是在object对象中，那么两者所表示的都是值是否相等（public boolean equals(Object obj){return (this==obj); }）,可以看到object的equals方法是使用的“==”比较。 一般而言，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符，也就是比较内存中所存储的两个变量的值是否相等。 举例：String a=new String(“foo”); String b=new String(“foo”);它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 在实际开发中，我们经常要比较传递进行来的字符串内容是否等，此时是使用的equals（）方法。 对于equals（）而言，默认情况是从object类继承的，当希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由自己写代码来决定在什么情况即可认为两个对象的内容是相同的。 22.静态变量和实例变量的区别？在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别： 实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。 静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。、 总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 23.是否可以从一个static方法内部发出对非static方法的调用？不可以。 对于static修饰的静态方法，是随着类的加载而加载，且调用的时可以不用创建对象而直接调用 非静态方法要与对象联系在一起，只有创建了对象了以后才能调用非静态方法，即当一个静态方法被调用的时候，有可能还没有创建任何实例对象。 24.Integer与int的区别int是java提供的8种原始数据类型之一，系统给的默认值为0。 Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。系统给的默认值为null。 25.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?Math类中提供了三个与取整有关的方法：ceil（向上取整）、floor（向下取整）、round（四舍五入） 举例： Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11 Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12 算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 28.Overload和Override的区别。Overload的方法是否可以改变返回值的类型?Overload:表示方法重载，表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数、类型、位置不同），通过定义不同的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行： 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 不能通过访问权限、返回类型、抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 Override：表示方法重写（覆盖），表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，当通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。 重写的方法的标志必须要和被重写的方法的标志完全匹配，才能达到重写的效果； 重写的方法的返回值必须和被重写的方法的返回一致； 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类（因为子类是解决父类的一些方法，不能比父类更多问题）； 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写(子类方法的访问权限只能比父类的更大，不能更小)。 如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关联。椅子与腿和背时组合关系。 31.序列化接口的id有什么用？对象经常要通过IO进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没有个统一的干法，于是，sun公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被sun的这种方案处理，必须实现Serializable接口。ObjectOutputStream.writeObject(obj);Object obj = ObjectInputStream.readObject(); 假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun的jdk就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错! 32.hashCode方法的作用？hashcode这个方法是用来鉴定2个对象是否相等的。 与equals（）方法的区别： 简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了 hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。 hashcode相当于是一个对象的编码，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。 33.构造器Constructor是否可被override?重写发生在继承过程中（子父类间），但是构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。 6.final, finally, finalize的区别。final：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承，内部类要访问局部变量，局部变量必须定义成final类型。 finally：是异常处理语句结构的一部分，表示总是执行，除非是遇到重大错误error，才不会执行finally。 finalize：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。 9.Java中的异常处理机制的简单原理和应用。 异常是指java程序运行时（非编译）所发生的非正常情况或错误，Java使用面向对象的方式来处理异常，它把程序中发生的每s个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。 所有异常的根类为java.lang.Throwable：Throwable下面又派生了两个子类：Error和Exception。 Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了（内存溢出和线程死锁等系统问题）。 Exception表示程序还能够克服和恢复的问题： 其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉。 普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。 java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。 提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。 10.Throwable：异常的父类。error :jvm严重错误，JVM无法继续，因此这是不可捕捉无法用程序去恢复的错误。 exception： 可以捕获到，可以恢复。 cheched exception：IO/SQL异常，JVM要求我们对出现的异常进行catch。 runtime exception：运行时异常，我们可以不处理，将其抛出最后可以抛给JVM处理，多线程由thread.run()抛出，单线程由main（）函数抛出。运行时异常也有一般异常的子类，可以被catch到，如果不对其处理，要么线程终止，要么主线程终止（异常的处理目标就是将异常程序恢复正常）。 11.请写出你最常见到的5个runtime exception。在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。 ArrayindexOfBoundsException：数组越界异常。 NullPointerException：空指针异常。 ClassCastException：类型转换异常。 ClassNotFoundException：指定类不存在。 ArithmeticException：数字运算异常。 ArrayStoreException：数组存储与声明类型不兼容。 numberFormatException：数字格式异常。 12.Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。 try：指定一块预防所有”异常”的程序。 cache：紧跟在try程序后面，用来指定想要捕捉的”异常”的类型。 throw：不处理异常，直接明确地抛出一个”异常”，给上一层处理。 finally：确保一段代码不管发生什么”异常”都被执行一段代码。 16.同步有几种实现方法?同步的实现方面有两种，分别是synchronized,wait与notify。 wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 17.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?其他方法前是否加了synchronized关键字，如果没加，则能。 如果这个方法内部调用了wait，则可以进入其他synchronized方法。 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。 19.简述synchronized和java.util.concurrent.locks.Lock的异同？主要相同点：Lock能完成synchronized所实现的所有功能。 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。 synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 3.Comparable和Comparator接口是干什么的。 Java提供了只包含一个compareTo()方法的Comparable接口。 这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 1.写clone()方法时，通常都有一行代码，是什么clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 2.面向对象的特征有哪些方面==封装==：将对象封装成独立的，高度自治的，相对封闭的模块，实现“高内聚，低耦合”，降低相互的依赖性，这个对象状态（属性）由这个对象自己的行为（方法）来读取和改变，将属性（变量）定位private，只有这个类自己的方法才可以访问到这些成员变量，一个原则是：让方法和它待在一起。 ==继承==：表示的是类与类的关系，是子类共享父类所有数据和方法的一种机制，可提高软件的可重用性和扩展性，缺点是加强了耦合性。 构造方法和private修饰的方法不可以被继承。 ==多态==：程序运行时的多种状态，增强了软件的灵活性和扩展性。 ==抽象==： 将事物的相似和共性之处，拿出来，然后将这些事物归为一个类，忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面，抽象包括行为抽象和状态抽象两个方面。 把握一个原则：当前系统需要什么就只考虑什么。 2.java中实现多态的机制是什么？靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 3.abstract class和interface有什么区别?抽象类：含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。 含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。 abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，==所以，不能有抽象构造方法或抽象静态方法==。 如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口：（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。 - 接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 ==语法区别==： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），==但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型==。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 一个类可以实现多个接口，但只能继承一个抽象类。 ==应用上的区别==： 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约 而抽象类在代码实现方面发挥作用，可以实现代码的重用 4.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。 例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk的源代码，可以发现FileOutputStream的open方法的定义如下：native void open(String name) throws FileNotFoundException;```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，==但需要在前面声明native==。**关于synchronized与abstract合用的问题，我觉得也不行，synchronized应该是作用在一个具体的方法上才有意义，而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。**### 5.什么是内部类？Static Nested Class 和 Inner Class的不同。首先内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。**内部类就是在一个类的内部定义的类，内部类中不能定义静态成员**（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中**在方法内部定义的内部类前面不能有访问类型修饰符，**### 6.内部类可以引用它的包含类的成员吗？有没有什么限制？一般而言是可以的。如果不是静态内部类，那没有什么限制！但是，如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员### 7.Anonymous Inner Class (匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?可以继承其他类或实现其他接口。不仅是可以，而是必须!### 9.jdk中哪些类是不能继承的？ **不能继承的是类是那些用final关键字修饰的类**。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中比如，System,String,StringBuffer等类型。### 10.String是最基本的数据类型吗?不是，**是属于引用类型**。引用类型还有数组，日期等类型，java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。基本数据类型包括byte、int、char、long、float、double、boolean和short。### 11.String s = &quot;Hello&quot;;s = s + &quot; world!&quot;;这两行代码执行后，原始的String对象中的内容到底变了没有？**没有。因为String由final修饰，被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。**如果要使用内容相同的字符串，不必每次都new一个String。比如下面的例子，在构造器中对一个叫S的string引用变量进行初始化，将其设置为初始值：应该如下这样做```java public class Demo &#123; private String s; ... public Demo &#123; s = &quot;Initial Value&quot;; &#125; ... &#125; 而不是==s = new String(“Initial Value”)==，因为这样每次都会掉用新的构造器，生成新的对象，性能低下的同时，内存开销大 12.是否可以继承String类?不能，String类是final类，故不可以继承。 13.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？两个 ”xyz”对应一个对象，这个对象放在==字符串常量缓冲区==，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。 New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象 如果以前就用过’xyz’，就不会创建”xyz”自己了，直接从缓冲区拿。 14.String 和StringBuffer的区别JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。 String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。 String类： 表示内容不可改变的字符串，string重写了equals（）方法，new String(“abc”).equals(new String(“abc”)的结果为true， StringBuffer类： 表示内容可以被修改的字符串，因此当你知道字符数据要改变的时候你就可以使用==StringBuffer==（比如：你可以使用StringBuffer来动态构造字符数据），StringBuffer并没有实现equals（）方法，故new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。 StringBuffer sbf = new StringBuffer(); for(int i=0;i&lt;100;i++){ sbf.append(i); } 上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。 String str = new String(); for(int i=0;i&lt;100;i++){ str = str + i; } 在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。 15.StringBuffer与StringBuilder的区别StringBuffer和StringBuilder类都表示内容可以被修改的字符串 StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。 如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。 16.如何把一段逗号分割的字符串转换成一个数组?用正则表达式，代码大概为：==String [] result = orgStr.split(“,”);== 用 StringTokenizer 代码为(麻烦)： 1234567891011String orgStr = "aa,aa,dd,d"; StringTokenizer tokener = new StringTokenizer(orgStr,","); String[] result = new String[tokener.countTokens()]; int i = 0; while(tokener.hasMoreElements())&#123; result[i++] = tokener.nextToken(); &#125; for (String s : result) &#123; System.out.println(s); &#125; \61. 为什么要使用克隆？想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。 \62. 如何实现对象克隆？有两种方式： 1). 实现Cloneable接口并重写Object类中的clone()方法； 2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 \63. 深拷贝和浅拷贝区别是什么？浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例:assign()） 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型） 集合12.Collection 和 Collections 有什么区别？java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。 13.List、Set、Map 之间的区别是什么？ 如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。 如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问, 如果经常添加删除元素的，那么肯定要选择LinkedList。 如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。 保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。 如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。 14.java的关键字（keyword）有多少个？ 51+2个保留字=53个关键字 (java的关键字都是小写的！！) 保留字:const goto 15.HashMap 和 Hashtable 有什么区别？hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。 hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。 hashMap允许空键值，而hashTable不允许。 16.如何决定使用 HashMap 还是 TreeMap？对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。 假如需要对一个有序的key集合进行遍历，TreeMap是更好的选择。 17.说一下 HashMap 的实现原理？HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键,无序 HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn) 18.说一下HashSet 的实现原理？HashSet底层由HashMap实现 HashSet的值存放于HashMap的key上 HashMap的value统一为PRESENT 19.ArrayList 和 LinkedList 的区别是什么？最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问， 而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。 使用下标访问一个元素，ArrayList 的时间复杂是 O(1)，而 LinkedList 是 O(n)。 20.如何实现数组和 List 之间的转换？List转换成为数组：调用ArrayList的toArray方法。 数组转换成为List：调用Arrays的asList方法。 21.ArrayList 和 Vector 的区别是什么？Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 ArrayList比Vector快，它因为有同步，不会过载。 ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。 22.Array 和 ArrayList 有何区别？Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 Array是指定大小的，而ArrayList大小是固定的。 Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。 23.在 Queue 中 poll()和 remove()有什么区别？poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 24.哪些集合类是线程安全的？vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用. enumeration：枚举，相当于迭代器。 statck：堆栈类，先进后出。(hashtable的子类) hashtable：就比hashmap多了个线程安全。 \31. 迭代器 Iterator 是什么？迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 \32. Iterator 怎么使用？有什么特点？Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。 (2) 使用next()获得序列中的下一个元素。 (3) 使用hasNext()检查序列中是否还有元素。 (4) 使用remove()将迭代器新返回的元素删除。 Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。 \33. Iterator 和 ListIterator 有什么区别？Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 8.ArrayList和Vector的区别。这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，数据是允许重复的. ArrayList与Vector的区别，这主要包括两个方面。 数据增长： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次增加多个存储单元，增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。 Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 同步性： Vector是线程安全的，而ArrayList是线程序不安全的 对于Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。 9.能创建 volatile 数组吗？可以，但是创建的对象或数组的地址具有可见性，里面的数据是不可见的。 10.去掉一个Vector集合中重复的元素。方法一：HashSet set = new HashSet(vector); 方法二： Vector newVector = new Vector(); for (int i=0;i&lt;vector.size();i++) { Object obj = vector.get(i); if(!newVector.contains(obj); //不包含 newVector.add(obj); } 11.说出ArrayList,Vector, LinkedList的存储性能和特性。ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。 而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 13.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。 Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 equals()和==方法决定引用值是否指向同一对象，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 14.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对? 对。 如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。 如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的。 例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。 15.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！ 当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的。 实验代码 public class Parent implements Comparable { private int age = 0; public Parent(int age){ this.age = age; } public int compareTo(Object o) { System.out.println(“method of parent”); Parent o1 = (Parent)o; return age&gt;o1.age?1:age&lt;o1.age?-1:0; } } public class Child extends Parent { public Child(){ super(3); } public int compareTo(Object o) { System.out.println(“method of child”); return 1; } } public class TreeSetTest { public static void main(String[] args) { TreeSet set = new TreeSet(); set.add(new Parent(3)); set.add(new Child()); set.add(new Parent(4)); System.out.println(set.size()); } } 16.快速失败(fail-.fast)和安全失败(fail-.safe)的区别是什么？Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。 java.util 包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 20.HashMap什么时候进行扩容呢？HashMap的一些重要的特性是它的容量 (capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 ​ 当HshMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75， 也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍， 然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。 22.CorrentHashMap的工作原理?在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。 HashMap的底层实现，之后会问ConcurrentHashMap的底层实现 HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。允许使用null值和null键。 ConcurrentHashMap基于双数组和链表的Map接口的同步实现 ConcurrentHashMap中元素的key是唯一的、value值可重复 ConcurrentHashMap不允许使用null值和null键 ConcurrentHashMap是无序的 23.LinkedHashMap的实现原理?LinkedHashMap也是基于HashMap实现的 LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。 26.为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。 因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。 多线程\35. 并行和并发有什么区别？并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 \36. 线程和进程的区别？简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。 线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。 同一进程中的多个线程之间可以并发执行。 37.守护线程是什么？守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。 \38. 创建线程有哪几种方式？①. 继承Thread类创建线程类定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 ②. 通过Runnable接口创建线程类定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 ③. 通过Callable和Future创建线程创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 \39. 说一下 runnable 和 callable 有什么区别？Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已； Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 \41. sleep() 和 wait() 有什么区别？sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。 wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程 \42. notify()和 notifyAll()有什么区别？如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 \43. 线程的 run()和 start()有什么区别？每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。 start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。 \44. 创建线程池有哪几种方式？①. newFixedThreadPool(int nThreads)创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。 ②. newCachedThreadPool()创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。 ③. newSingleThreadExecutor()这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。 ④. newScheduledThreadPool(int corePoolSize)创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。 \45. 线程池都有哪些状态？线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。 \46. 线程池中 submit()和 execute()方法有什么区别？接收的参数不一样 submit有返回值，而execute没有 submit方便Exception处理 \47. 在 java 程序中怎么保证多线程的运行安全？线程安全在三个方面体现： 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）； 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）； 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。 \48. 多线程锁的升级原理是什么？在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。 \49. 什么是死锁？死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称. \50. 怎么防止死锁？死锁的四个必要条件： 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 \51. ThreadLocal 是什么？有哪些使用场景？线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。 Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。 但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 synchronized 底层实现原理？synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 \53. synchronized 和 volatile 的区别是什么？volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 \54. synchronized 和 Lock 有什么区别？首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)， Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）； Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 \55. synchronized 和 ReentrantLock 区别是什么？synchronized是和if、else、for、while一样的关键字， ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中markword。 \56. atomic 的原理？Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。 我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。 反射\57. 什么是反射？反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 Java反射： 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法。对于任意一个对象，能否调用它的任意一个方法 Java反射机制主要提供了以下功能： 在运行时构造任意一个类的对象。 在运行时判断任意一个对象所属的类。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 \58. 什么是 java 序列化？什么情况下需要序列化？简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 什么情况下需要序列化： a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； \59. 动态代理是什么？有哪些应用？动态代理： 当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。 动态代理的应用： Spring的AOP, 加事务, 加权限, 加日志 \60. 怎么实现动态代理？首先必须定义一个接口，还要有一个InvocationHandler (将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。 面向对象设计原则1.单一职责原则- 在面向对象设计中，分工理论就是单一职责原则(Single Pesponsibility Prineiple, SRP) - 两个含义 - 避免相同的职责分散到不同的类中 - 避免一个类承担太多职责 - 为什么要遵循单一设计原则 - 可以减少类之间的耦合：当需求变化时，只修改一个类，从而隔离了变化。 - 提高类的复用性 - 单一职责使得组件可以方便的拆卸和组装 - 应用：用工厂模式来实现不同数据库操作类。 2.接口隔离原则：- 接口隔离原则(Interface Segregation Principle, ISP): 客户端不应该被强迫实现不会使用的接口 - 接口隔离原则的主要观点 - 一个类对另外一个类的依赖性应当是建立在最小的接口上 - ISP 可以达到不强迫客户依赖于他们不使用的方法，接口的实现类应该只呈现为单一职责的角色(遵守SRP原则)。 - ISP 还可降低客户端之间的相互影响——当某个客户程序要求提供新的职责(需求变更)而迫使接口发生改变时，影响到其他客户程序的可能性会是最小的。 - 客户端程序不应该依赖它不需要的接口方法 - ISP强调的是接口对客户端的承诺越少越好，并且要做到专一。 - 接口污染：过于臃肿的接口设计是对接口的污染。接口污染就是为接口添加不必要的职责，如果开发人员在接口中增加一个新功能的主要目的只是减少接口实现类的数目，则此设计导致接口被不断的“污染” 并 “变胖” 3.开放 - 封闭原则： - 开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。 - 关闭：在模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。 - 一个模块在扩展性方面应该是开放的，在更改性方面应该是封闭的。 - 该原则的核心是想是对抽象编程，而不是具体编程，因为抽象相对稳定。 让类依赖于固定的抽象，这样的修改就是封闭的，通过面向对象的继承和多态机制，可以实现对抽象体的继承， 通过覆写其方法改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。 - 在设计方面充分应用 抽象 和 封装 的思想。 - 在系统功能编程实现方面应用面向接口的编程。 4.替换原则 ：里氏替换原则(Liskov Substiution Principle, LSP)定义以及主要思想：子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。 - 父类的方法都要在子类中实现或者重写, 派生类只实现其抽象类中声明的方法, 而不应当给出多余的方法定义或实现。 - 在客户端程序中只应该出现父类对象，而不是直接使用子类对象, 这样可以实现运行期绑定(多态绑定)。 5.依赖倒置原则：依赖倒置的核心原则是解耦，如果脱离这个最原始的原则，那就是本末倒置。 - 将依赖关系倒置为依赖接口: - 上层模块不应该依赖下层模块, 它们共同依赖于一个抽象。 - 抽象不能依赖于具体, 具体应该要依赖于抽象 - IOC(Inversion of Control) 是依赖倒置原则(Dependence Inversion Principle, DIP)的同义词。 - DI: 依赖注入 - DS: 依赖查找 - 如何满足DIP: - 每个较高层次类都为它所需要的服务提出一个接口声明, 较低层次实现这个接口 - 每个高层类都通过该抽象接口使用服务]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级_注解]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E9%AB%98%E7%BA%A7-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@SafeVarargs 挺有意思的一个注解 @SafeVarargs 这是1.7 之后新加入的基本注解. 如例所示，当使用可变数量的参数的时候，而参数的类型又是泛型T的话，就会出现警告。 这个时候，就使用@SafeVarargs来去掉这个警告 @SafeVarargs注解只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。一个方法使用@SafeVarargs注解的前提是，开发人员必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题。 1234567public class User &#123; @SafeVarargs public static &lt;T&gt; T getData(T... ds) &#123; return ds.length &gt; 0 ? (T) ds[0] : null; &#125;&#125; 自定义注解创建1234567@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface MyNote &#123; String name() default "zhw";&#125; 使用自定义注解1234567891011121314151617@MyNote(name = "zhwzhw")class Util &#123;&#125;public class NoteTest &#123; public static void main(String[] args) &#123; test1(); &#125; public static void test1() &#123; //反射获取注解 MyNote myNote = Util.class.getAnnotation(MyNote.class); // 获取方法 String name = myNote.name(); System.out.println(name); &#125;&#125; 结果: zhwzhw 相信刚刚接触的人一定很茫然 那么接下来讲解一下其中的元注解 元注解 元注解 @Target@Retention@Inherited@Documented@Repeatable (java1.8 新增) 有这么五种 @Target @Target 表示这个注解能放在什么位置上 12345678910111213141516171819@Target(&#123; // 能修饰包 ElementType.PACKAGE, // 能修饰类、接口或枚举类型 ElementType.TYPE, ElementType.TYPE_USE, ElementType.TYPE_PARAMETER, // 能修饰构造器 ElementType.CONSTRUCTOR, // 能修饰方法 ElementType.METHOD, // 能修饰成员变量 ElementType.FIELD, // 能修饰局部变量 ElementType.LOCAL_VARIABLE, // 能修饰参数 ElementType.PARAMETER, // 能修饰注解 ElementType.ANNOTATION_TYPE&#125;) @Retention 表示生命周期 只能选择一个生命周期 下面是错误的写法,只是方便说明而已 1234567@Retention(&#123; // 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了 RetentionPolicy.CLASS, // 注解在运行起来之后依然存在，程序可以通过反射获取这些信息 RetentionPolicy.RUNTIME, // 注解只在源代码中存在，编译成class之后，就没了 RetentionPolicy.SOURCE&#125;) @Inherited 表示该类有继承性 @Documented 在用javadoc命令生成API文档后，该文档里会出现该注解说明 @Repeatable 当没有@Repeatable修饰的时候，注解在同一个位置，只能出现一次 1234567891011121314151617181920212223@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Names &#123; FileType[] value();&#125;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@Repeatable(Names.class)public @interface FileType &#123; String value();&#125;@FileType( ".java" ) @FileType( ".html" ) @FileType( ".css" ) @FileType( ".js" ) public void work()&#123; &#125; 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java高级_注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级_反射机制]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E9%AB%98%E7%BA%A7-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类对象获取 先创建对象类 123456789101112131415161718192021222324class User &#123; public String name; private String sex; static String str; static &#123; str = "已经初始化!"; System.out.println("初始化..." + str); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "User [name=" + name + ", sex=" + sex + "]"; &#125;&#125; 有三种方式获取 1234567891011121314public static void test1() throws Exception &#123; // 初始化类静态属性 Class c1 = Class.forName("zhw.base.User"); System.out.println(c1); // 不会初始化类静态属性 Class c2 = User.class; System.out.println(c2); // 初始化类静态属性 Class c3 = new User().getClass(); System.out.println(c3); &#125; 通过反射创建对象12345678public static void test2() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); &#125; 通过反射修改对象属性值 getField只能获取public属性,包括继承的属性 getDeclaredField可以获取本类所有属性 12345678910111213141516171819public static void test3() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); // 获取对象属性 // getField只能获取public属性,包括继承的属性 Field f1 = cci.getClass().getField("name"); // getDeclaredField可以获取本类所有属性 Field f2 = cci.getClass().getDeclaredField("sex"); f2.setAccessible(true); // 设置值 f1.set(cci, "zhw"); f2.set(cci, "man"); System.out.println(cci); &#125; 通过反射调用对象方法123456789101112131415public static void test4() throws Exception &#123; // 获取类对象 Class c1 = Class.forName("zhw.base.User"); // 通过类对象获取对象构造器 Constructor cc = c1.getConstructor(); // 通过构造器实例化对象 User cci = (User) cc.newInstance(); // 反射获取对象方法 Method m = cci.getClass().getMethod("setName", String.class); // 调用方法 m.invoke(cci, "zhw"); System.out.println(cci.getName()); &#125; 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java高级_反射机制</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_Lamda-Stream]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-Lamda-Stream%2F</url>
    <content type="text"><![CDATA[Lamda规则: 接口必须是函数式接口---@FunctionalInterface 接口里面只能够存在一个抽象方法 java8还有个特性就是如果你的接口中没有抽象方法，但有个默认(default)方法，它也是函数式接口 语法: - 简写模式: (参数列表）-&gt; 方法主体 -无参模式: () -&gt; 方法主体 - 非简写模式：（参数列表）-&gt; {方法主体;} Stream三步骤:创建流 - 中间操作 - 最终操作 创建流流的创建有两种方式。 如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。 如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流； 123456789101112131415161718192021public static void test1() &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); ls.add("zz"); ls.add("aa"); ls.add("bb"); System.out.println(ls); List&lt;String&gt; bs = Arrays.asList("bb","cc","dd"); System.out.println(bs); // 集合直接使用stream()方法创建流 Stream&lt;String&gt; stream = ls.stream(); bs.stream(); // 数组 // 使用Arrays工具类stream()方法创建 String[] js = &#123;"aa","cc","bb"&#125;; Stream&lt;String&gt; stream2 = Arrays.stream(js); // 使用Stream类of()方法创建 Stream&lt;String&gt; stream3 = Stream.of("aa","bb","cc"); &#125; 中间操作 filter (过滤) map (映射) sorted (排序) distinct (去重) limit / skip (限制) filter (过滤) 根据判断条件过滤元素 123List&lt;UserDO&gt; resultList = userList.stream() .filter(user -&gt; user.id != 0) .collect(Collectors.toList()); map (映射) 映射每个元素到对应的方法 123List&lt;String&gt; bs = Arrays.asList("bb","cc","dd","cc"); System.out.println("map=========="); bs.stream().map(i -&gt; i+"未知数").forEach(System.out::println); 结果: map= = = = = = =bb未知数cc未知数dd未知数cc未知数 sorted (排序) 按条件进行排序 123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1);System.out.println("sorted==========");ls.stream().sorted().forEach(System.out::println); 结果: sorted= = = = = = = = = =135 distinct (去重) 去除集合或者数组中重复得数据 12Stream&lt;String&gt; s3 = Stream.of("aa","bb","cc" ,"cc");s3.distinct().forEach(System.out::println); 结果: aabbcc limit/skip limit 返回 Stream 的前面 n 个元素； skip 则是扔掉前 n 个元素。 limit123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1);System.out.println("limit==========");ls.stream().limit(1).forEach(System.out::println); 结果: limit = = = = = = = = = =3 skip123456List&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();ls.add(3);ls.add(5);ls.add(1); System.out.println("skip= = = = = = = = = =");ls.stream().skip(1).forEach(System.out::println); 结果 skip= = = = = = = = = =51 最终操作 匹配 anyMatch() - - 根据条件返回是否有匹配的结果 allMatch() – 只要有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回true。 noneMatch() – 只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。 组合 reduce() - -把元素组合起来 计数 count() max() min() 迭代 forEach() 汇总 collect() –将流中的元素汇总 匹配1boolean isFound = userList.stream() .anyMatch(user -&gt; Objects.equals(user.getId(), userId)); 组合123List&lt;Integer&gt; nums = Arrays.asList(1, 2, 5, 4); int result = nums.stream().reduce(10,(a, c) -&gt; a + c); System.out.println(result); 结果:22 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java中级_lamda-stream</category>
      </categories>
      <tags>
        <tag>lamda</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_网络编程]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[OSI与TCP/IP体系模型OSI体系结构 OSI体系结构 7.应用层 6.表示层 5.会话层 4.传输层 3.网络层 2.数据链路层 1.物理层 TCP/IP体系结构 TCP/IP体系结构 4.应用层(协议:Telnet,FTP,SMTP…) 3.传输层(TCP/UDP) 2.网际层IP 1.网络接口层 TCP是 Tranfer Control Protocol 的简称; 是一种面向连接的保证可靠传输的协议. UDP是 User Datagram Protocol 的简称 是一种无连接的协议. TCP/UDP比较：UDP： 每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。 UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。 TCP： 面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。 TCP传输数据大小没有限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。 TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。 TCP/UDP应用：TCP: 远程连接,文件传输… TCP传输没有UDP快 UDP: 音视频传输… Socket12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; try &#123; Socket s = new Socket("127.0.0.1", 9999); //打开字节流输出流 OutputStream os = s.getOutputStream(); //封装字节流-数据流 DataOutputStream dos = new DataOutputStream(os); //读取控制台数据 Scanner scanner = new Scanner(System.in); String data = scanner.next(); //发送数据到服务端 dos.writeUTF(data); os.close(); s.close();// // 启动发送信息线程// new SendThread(s).start();// // 启动接收信息线程// new RecieveThread(s).start(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; ServerSocket12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; try &#123; // 服务器端打开端口9999 ServerSocket ss = new ServerSocket(9999); // 在9999端口监听 System.out.println("正在监听9999"); Socket s = ss.accept(); System.out.println("请求连接:" + s); // 打开字节流输入流 InputStream is = s.getInputStream(); //封装字节流-数据流 DataInputStream dis = new DataInputStream(is); // 读取客户端发送过来的数据 String readUTF = dis.readUTF(); System.out.println("客户端:"+readUTF); is.close(); s.close(); ss.close();// // 启动发送信息线程// new SendThread(s).start();// // 启动接收信息线程// new RecieveThread(s).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 多线程交互 发送信息线程 1234567891011121314151617181920212223242526272829303132333435/** * * @ClassName: SendThread * @Description: 发送信息线程 * @author zhouhongwei * */public class SendThread extends Thread &#123; private Socket s; public SendThread(Socket s) &#123; this.s = s; &#125; public void run() &#123; try &#123; // 打开字节流输出流 OutputStream os = s.getOutputStream(); // 封装字节流-数据流 DataOutputStream dos = new DataOutputStream(os); while (true) &#123; // 读取控制台数据 Scanner scanner = new Scanner(System.in); String data = scanner.next(); // 发送数据到服务端 dos.writeUTF(data); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 接收信息线程 123456789101112131415161718192021222324252627282930313233/** * * @ClassName: RecieveThread * @Description: 接收信息线程 * @author zhouhongwei * */public class RecieveThread extends Thread &#123; private Socket s; public RecieveThread(Socket s) &#123; this.s = s; &#125; public void run() &#123; try &#123; // 打开字节流输入流 InputStream is = s.getInputStream(); // 封装字节流-数据流 DataInputStream dis = new DataInputStream(is); while (true) &#123; // 读取客户端发送过来的数据 String readUTF = dis.readUTF(); System.out.println(readUTF); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 服务器端 123456789101112131415161718public static void main(String[] args) &#123; try &#123; // 服务器端打开端口9999 ServerSocket ss = new ServerSocket(9999); // 在9999端口监听 System.out.println("正在监听9999"); Socket s = ss.accept(); // 启动发送信息线程 new SendThread(s).start(); // 启动接收信息线程 new RecieveThread(s).start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 客户端 12345678910111213141516public static void main(String[] args) &#123; try &#123; Socket s = new Socket("127.0.0.1", 9999); // 启动发送信息线程 new SendThread(s).start(); // 启动接收信息线程 new RecieveThread(s).start(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 说一下,网络编程,有 NIO,也有Netty框架 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java中级-网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_集合]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[总框架 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类 Collection Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支 List List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。 List 有序,可重复 List的实现类有LinkedList, ArrayList, Vector, Stack。 List接口提供了一个特殊的迭代器，称为ListIterator，其允许元件插入和更换，并且除了该Iterator接口提供正常操作的双向访问。 提供了一种方法来获取从列表中的指定位置开始的列表迭代器。 ArrayList ArrayList擅长于随机访问。同时ArrayList是非同步的。 优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高 Vector Vector是线程安全的动态数组 优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低 LinkedList LinkedList不能随机访问,也是非同步的 优点: 底层数据结构是双向链表，查询慢，增删快。缺点: 线程不安全，效率高 ArrayList-LinkedList-异同点 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 Set Set是一个不允许有重复元素的集合,无序，Set最多有一个null元素。 虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 Set的实现类有HashSet和TreeSet,LinkHashSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 HashSet 没有重复元素的集合 是由HashMap实现的 不保证元素的顺序 是非同步的 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。 LinkedHashSet 底层是基于LinkedHashMap来实现的 有序，非同步。 根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序 当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 TreeSet 一个有序集合，其底层是基于TreeMap实现的，非线程安全 TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式 TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 HashSet、LinkedHashSet、TreeSet比较 Set接口Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。 Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。 HashSetHashSet有以下特点： 不能保证元素的排列顺序，顺序有可能发生变化。 不是同步的。 集合元素可以是null，但只能放入一个null。 当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。 注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 TreeSet类TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。 TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。 Map Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口 不能存在相同的key值，当然value值可以相同。 HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的， 是一个单链表结构 非线程安全 LinkHashMap LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序 双重链接列表 非线程安全 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能 但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 TreeMap TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点 排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 HashTable与HashMap的异同点 相同点： 都实现了Map、Cloneable、java.io.Serializable接口。 都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点： （1）历史原因：HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。 （2）同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。 （3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。 （4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。 (5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 HashMap、Hashtable、LinkedHashMap和TreeMap比较 Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 Hashtable 与 HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。 TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。 TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 Iterator 它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的 12345678910public interface Iterator&lt;E&gt; &#123; //判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 boolean hasNext(); //返回集合里下一个元素。 E next(); //删除集合里上一次next方法返回的元素。 default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125;&#125; 操作一下Iterator的这三个方法 123456789101112131415public static void Test1() &#123; List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String t = it.next(); if ("bbb".equals(t)) &#123; it.remove(); &#125; &#125; System.out.println("After iterate : " + a);&#125; 结果为: Before iterate : [aaa, bbb, ccc]After iterate : [aaa, ccc] ListIterator 针对List集合 12345678910111213141516171819202122232425public static void Test2() &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) &#123; System.out.println("it.next() : " +it.next() + " ,前位置: " + it.previousIndex() + ",后位置: " + it.nextIndex()); &#125; while (it.hasPrevious()) &#123; System.out.println("it.previous() : "+it.previous()); &#125; it = a.listIterator(1); while (it.hasNext()) &#123; String t = it.next(); System.out.println("t:" + t); if ("ccc".equals(t)) &#123; it.set("nnn"); &#125; else &#123; it.add("kkk"); &#125; &#125; System.out.println("After iterate : " + a);&#125; 结果: Before iterate : [aaa, bbb, ccc]it.next() : aaa ,前位置: 0,后位置: 1it.next() : bbb ,前位置: 1,后位置: 2it.next() : ccc ,前位置: 2,后位置: 3it.previous() : cccit.previous() : bbbit.previous() : aaat:bbbt:cccAfter iterate : [aaa, bbb, kkk, nnn] Enumeration 作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。只提供了遍历Vector和HashTable类型集合元素的功能，不支持元素的移除操作 用法和Iterator类似,该接口有2个方法 1234boolean hasMoreElements() 测试此枚举是否包含更多元素。 E nextElement() 如果此枚举对象至少有一个要提供的元素，则返回此枚举的下一个元素. 操作Enumeration方法 123456789101112public static void Test3() &#123; Vector&lt;String&gt; v = new Vector&lt;String&gt;(); v.addElement("Lisa"); v.addElement("Billy"); v.addElement("Mr Brown"); System.out.println("Enumeration前"+v); Enumeration&lt;String&gt; e = v.elements();//返回Enumeration对象 while(e.hasMoreElements())&#123; String value = (String)e.nextElement();//调用nextElement方法获得元素 System.out.println(value); &#125; &#125; 结果: Enumeration前[Lisa, Billy, Mr Brown]LisaBillyMr Brown 工具类Collections 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java中级_集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E4%B8%AD%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Java中级1.异常1.分类 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 123456789101112131415异常的体系结构 * java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。 * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked)不会生成字节码文件 * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException//空指针异常 * |-----ArrayIndexOutOfBoundsException//数组角标越界 * |-----ClassCastException//类型转化异常 * |-----NumberFormatException//编码格式异常 * |-----InputMismatchException//输入不匹配 * |-----ArithmeticException//算术异常 2.处理异常方式 throws try-catch-finally finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 3.自定义异常12345678910public class MyException extends Exception&#123; private static final long serialVersionUID = 1L; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 2.JDBC1.定义 JDBC的全称是java数据库链接（Java Data Base Connect），它是用于执行SQL语句的java代码，应用程序可以通过JDBC链接到数据库，并使用SQL语句来完成对数据库中数据的新增、查询、删除和更新等操作 PreparedStatement的优点-防止SQL注入式攻击 PreparedStatement有预编译机制，性能比Statement更快 PreparedStatement 使用参数设置，可读性好，不易犯错 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Connection c = null; Statement s = null; try &#123; // 初始化驱动 Class.forName("com.mysql.jdbc.Driver"); // 建立与数据库的Connection连接 c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/a?characterEncoding=UTF-8", "root", "admin"); // 创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql); // SQL语句 String sql = "insert into cc values(?,?)"; ps.setString(1, "aaa"); ps.setString(1, "bbb"); // 执行SQL ps.execute(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯 // 先关闭PreparedStatement if (ps != null) try &#123; ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 后关闭Connection if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 3.I/O 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 所有的IO操作都在java.io包之中进行定义，而且整个java.io包实际上就是五个类和一个接口：（1）五个类：File、InputStream、OutputStream、Reader、Wirter；（2）一个接口：Serializable。 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 1.File 没啥好补充的 2.字节流与字符流 （1）字节操作流：OutputStream、InputStream；（2）字符操作流：Writer、Reader。 字节流 OutputStream和InputStream是字节流的两个顶层父类。让他们提供了输出流类和输入流类通用API，字节流一般用于读写二进制数据，如图像和声音数据。 OutputStream12345678910111213141516171819202122232425public static void Test2() throws IOException &#123; System.out.println("开始创建文件..."); // 定义文件路径 File file = new File("D:" + File.separator + "java" + File.separator + "test" + File.separator + UUID.randomUUID().toString() + ".txt"); // 判断路径存在? if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; // 文件存在? if (file.exists()) &#123; // 文件存在 file.delete(); // 删除文件 &#125; else &#123; // 文件不存在 file.createNewFile(); // 创建新文件 &#125; // 实例化输出 FileOutputStream fos = new FileOutputStream(file); String data = "哈哈哈哈哈哈哈哈哈"; System.out.println("开始生成数据源..." + file.getAbsolutePath()); // 输出数据 转化为字节数组输出 fos.write(data.getBytes()); // 关闭资源 fos.close(); System.out.println("输出流演示完成!"); &#125; InputStream字符流字符输入流writer 由于软件问题，这部分内容被软件吞了，后面从新来写 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java中级</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
        <tag>JDBC</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2020%2F06%2F12%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一.八种基本数据类型 byte 8位 默认值为0 short 16位 默认值0 int 32位 默认值0 long 64位 默认值0L float 32位 默认值 0.0F double 64位 默认值0.0D char 16位 默认值 空 boolean 8位 默认值 false 二.String-字符串1.String 字符串不变; 它们的值在创建后不能被更改。 字符串缓冲区(StringBuffer,StringBuilder)支持可变字符串。 因为String对象是不可变的，它们可以被共享 传递null参数到此类中的构造函数或方法将导致抛出NullPointerException 。 1234 String str = "abc";// 相当于 char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data); compareTo 12public int compareTo(String anotherString)//按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值 isEmpty() 12public boolean isEmpty()//true如果，只有 length()是 0 。 切割字符串 split() 12public String[] split(String regex)//该方法的工作原理是通过使用给定表达式和限制参数为零调用双参数split方法。 因此，尾随的空字符串不会包含在结果数组中。 substring() 12public String substring(int beginIndex)//返回一个字符串，该字符串是此字符串的子字符串 charAt() 12public char charAt(int index)//返回char指定索引处的值。 指数范围为0至length() - 1 。 该序列的第一个char值在索引0 ，下一个索引为1 ，依此类推，与数组索引一样。 2.StringBuffer 一个可变的字符序列 线程不安全 在可能的情况下，建议使用这个类别优先于StringBuilder ，因为它在大多数实现中将更快。 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 3.StringBuilder 可变的字符序列 线程安全 将null参数传递给null中的构造函数或方法将导致抛出NullPointerException 三.位运算 与（&amp;）、非（~）、或（|）、异或（^） 1.与 &amp; 两个操作数中位都为1，结果才为1，否则结果为0 2.非 ~ 如果位为0，结果是1，如果位为1，结果是0 3.或 | 两个位只要有一个为1，那么结果就是1，否则就为0 4.异或 ^ 两个操作数的位中，相同则结果为0，不同则结果为1 5.十进制-二进制 二进制: 0 1 1 1 1 1 1 1 1 1 二进制 128 64 32 16 8 4 2 1 十进制 十进制整数转换成二进制采用“除2倒取余”，十进制小数转换成二进制小数采用“乘2取整”。 6.十进制-八进制 八进制：它的基数是8，总共有8个数字符号(0，1，2，3，4，5，6，7)， 十进制整数转换成八进制采用“除8倒取余”，十进制小数转换成二进制小数采用“乘8取整”。 7.十进制-十六进制 十六进制：它的基数是16，总共有16个数字符号(0，1，2，3，4，5，6，7，8，9， ​ A[表示10]，B[表示11]，C[表示12]，D[表示13]，E[表示14]，F[表示15])， 十进制整数转换成十六进制采用“除16倒取余”，十进制小数转换成十六进制小数采用“乘16取整”。 8.二进制-八进制-十六进制 为什么有八进制,十六进制?因为其是2的倍数,方便运算 因为8=2^3^ 16=2^4^ 二进制-八进制 二进制转换成八进制的时候，只要将二进制的表示从右往左开始，每三位二进制数为1组 八进制转换为二进制只需要将八进制的每一个数用三位二进制表示，然后相连既可以。 二进制(0011 0101)B转换为八进制第一组:101 第二组:011 第三组:00第一组计算过程是:1 20+0 21+1 22=5；第二组计算过程是:0 20+1 21+1 22=6；所以最后的结果是65。也就是用6和5直接相连，而不是相加，这里还要注意一下相连的顺序问题，是6–5的方向。 二进制-十六进制二进制转换为十六进制就是将二进制每四位二进制为一组 十六进制转换为二进制只要需要将十六进制的每一个数用四位二进制表示，然后相连即可。 四.接口 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 一个类只由抽象方法和全局常量组成 1.很干净的接口123public interface TestInterface &#123;&#125; 2.概念而言,接口可以放的东西 JDK 1.8 以后，接口里可以有静态方法和方法体了 12345678910111213public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract //（只能是 public abstract，其他修饰符都会报错） public String SIX = ""; // 方法 public abstract int getData(); //接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量 //（并且只能是 public，用 private 修饰会报编译错误）。 int getDataa();&#125; 但是,也可以放普通内部类,抽象内部类,内部接口 1234567891011121314public interface TestInterface &#123; // 全局变量 public static final String NAME = "ZHOU"; // 方法 public abstract int getData(); // 普通内部类 class AA&#123;&#125; // 抽象内部类 abstract class BB&#123;&#125; // 内部接口 interface CC &#123;&#125; // 外部接口 static interface DD&#123;&#125;&#125; 3.接口与类的区别 不能实例化对象 没有构造方法 方法必须是抽象方法 只有用 static 和 final修饰的变量 不能被继承,而是要被类实现 支持多继承 4.接口的应用1.Factory工厂设计模式使用工厂设计模式，解耦 12345678&gt; // 没有使用工厂模式 &gt; public static void main(String[] args) &#123;&gt; //Fruit f = new Apple();&gt; Fruit f = new Orange();&gt; f.eat();&gt; &gt; &#125;&gt; 1234567891011121314151617181920&gt; // 创建工厂类&gt; class Factory&#123;&gt; public static Fruit getInstance(String className)&#123;&gt; if("apple".equals(className))&#123;&gt; return new Apple();&gt; &#125;else if("orange".equals(className))&#123;&gt; return new Orange();&gt; &#125;else&#123;&gt; return null;&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; // 使用工厂模式&gt; public static void main(String[] args) &#123;&gt; Fruit f = Factory.getInstance("apple");&gt; f.eat();&gt; &gt; &#125;&gt; 2.Proxy代理设计模式 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 抽象对象角色 目标对象角色 代理对象角色 1234// 抽象对象角色public interface SourceObj &#123; public void doSomethings();&#125; 12345678// 目标对象角色public class RealObj implements SourceObj&#123; @Override public void doSomethings() &#123; System.out.println("do somethings"); &#125;&#125; 1234567891011121314151617// 代理对象角色public class ProxyObj implements SourceObj&#123; //创建目标对象 RealObj realObj = new RealObj(); @Override public void doSomethings() &#123; // 添加新的方法 System.out.println("before do somethings"); realObj.doSomethings(); // 添加新的方法 System.out.println("end do somethings"); &#125;&#125; 五.抽象方法1.定义抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 抽象类定义： 1.抽象方法必须为 public 或 protected, 2.不能被实例化，采用向上转型处理 3.必须有子类 一个子类只能继承一个抽象类 4.子类不是抽象方法，则需要全部重写父类的抽象方法 123456789101112public abstract class C &#123; //构造方法 public C()&#123; System.out.println("C类的构造方法"); &#125; //普遍方法 public void a() &#123; System.out.println("有方法体"); &#125; // 抽象方法 public abstract void b();&#125; 有构造方法，总是先执行父类的构造，再去执行子类的构造方法 1234567891011public class D extends C &#123; // 构造方法 public D() &#123; System.out.println("D类的构造方法"); &#125; @Override public void b() &#123; System.out.println("d-c.b"); &#125;&#125; 1234public static void StringTest() &#123; D d = new D(); d.b();&#125; 结果：总是先执行父类的构造，再去执行子类的构造方法C类的构造方法D类的构造方法d-c.b 允许内部抽象类 使用static声明外部抽象类 123456abstract class A&#123;//定义一个抽象类 这里不允许使用static声明 static abstract class B&#123;//static定义的内部类属于外部类 public abstract void print(); &#125;&#125; 2.抽象类的应用Template 模板设计模式 模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 这种类型的设计模式属于行为型模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板模式主要由抽象模板(Abstract Template)角色和具体模板(Concrete Template)角色组成 123456789101112131415// 抽象模板角色abstract class Game&#123; //启动游戏 protected abstract void runGame(); //结束游戏 protected abstract void endPlayGame(); //模板方法 public final void play() &#123; runGame(); endPlayGame(); &#125; &#125; 12345678910111213// 具体模板角色class ContraGame extends Game&#123; @Override protected void runGame() &#123; System.out.println("启动aa游戏..."); &#125; @Override protected void endPlayGame() &#123; System.out.println("角色死亡，aa游戏结束！"); &#125;&#125; 123456//测试public static void main(String[] args) &#123; Game game = new ContraGame(); game.play(); System.out.println();&#125; 结果： 启动aa游戏… 角色死亡，aa游戏结束！ 优点 扩展性好，对不变的代码进行封装，对可变的进行扩展；可维护性好，因为将公共代码进行了提取，使用的时候直接调用即可； 缺点 因为每一个不同的实现都需要一个子类来实现，导致类的个数增加，会使系统变得复杂； 使用场景 有多个子类共有逻辑相同的方法；重要的、复杂的方法，可以考虑作为模板方法。 注意事项 为防止恶意操作，一般模板方法都加上 final 关键词！防止修改 六.重写与重载1.区别 区别 重写 重载 1 英文 Override OverLoading 2 定义 方法名相同，参数类型及参数个数不同， 方法名，参数类型，参数个数，返回值完全相同 3 权限 没有权限要求 子类的重写父类的方法，该方法不能拥有比父类更严格的访问控制权限 4 范围 发生在一个类中 发生在继承关系类中 2.this与super 区别 this super 1 定义 表示本类对象 表示父类对象 2 使用 this.属性，this.方法，this(); super.属性，super.方法(),super() 3 构造方法 放在首行 放在首行 4 查找范围 先从本类查找，找不到去父类找 直接找父类 5 特殊 表示当前对象 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基本类型</tag>
        <tag>String</tag>
        <tag>位运算</tag>
        <tag>接口</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中级_多线程]]></title>
    <url>%2F2020%2F05%2F12%2FJava%E4%B8%AD%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程 线程是进程中的一个实体 是被系统独立调度和分配的基本单位 一个标准的线程: 线程ID, 当前指令指针(PC) 寄存器集合 堆栈 Java默认线程有两个: main()主线程 GC线程 线程状态 之前线程的状态 （1）新建状态（New）：当线程对象对创建后，即进入了新建状态 （2）就绪状态（Runnable）：当调用线程对象的start()方法,线程即进入就绪状态 （3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行,,执行run()方法 (4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行 （5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 在Java中 在Thread.state源码来看 线程状态有6种 1234567891011121314public enum State &#123;状态 // 新生 NEW, // 运行状态 RUNNABLE, // 阻塞状态 BLOCKED, // 等待----一直等 WAITING, // 超时等待---过时不候 TIMED_WAITING, // 终止 TERMINATED; &#125; 1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 2.运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池 中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU 时间片后变为运行中状态（running）。3.阻塞(BLOCKED)：表示线程阻塞于锁。4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 6.终止(TERMINATED)：表示该线程已经执行完毕。 Java无法开启一个线程: 通过调用本地方法来开启的 1private native void start0(); 多线程 实现Runnable接口,实现Callable和继承Thread可以得到一个线程类 为什么使用多线程? 为了解决负载均衡问题,充分利用单核的CPU资源.为了提高CPU的使用率, 继承Thread方式1234567891011121314class ThreadTest extends Thread &#123; // 线程主体 private String title; public ThreadTest(String title) &#123; this.title = title; &#125; @Override public void run() &#123; // 线程主方法 for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--继承Thread类似创建线程"); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; // Thread ThreadTest t1 = new ThreadTest("线程A"); ThreadTest t2 = new ThreadTest("线程B"); ThreadTest t3 = new ThreadTest("线程C"); t1.start(); // 在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的 t2.start(); t3.start(); &#125; 结果: 线程A–继承Thread类似创建线程线程B–继承Thread类似创建线程线程C–继承Thread类似创建线程线程B–继承Thread类似创建线程线程A–继承Thread类似创建线程线程B–继承Thread类似创建线程线程C–继承Thread类似创建线程线程A–继承Thread类似创建线程线程C–继承Thread类似创建线程 实现Runable接口方式1234567891011121314class RunableTest implements Runnable &#123;// 线程主体 private String title; public RunableTest(String title) &#123;// 线程主方法 this.title = title; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--实现Runable类似创建线程"); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; // Runable RunableTest ta = new RunableTest("Runable-aa"); RunableTest tb = new RunableTest("Runable-bb"); RunableTest tc = new RunableTest("Runable-cc"); new Thread(ta).start(); // 借助Thread类的构造方法启动线程 new Thread(tb).start(); new Thread(tc).start(); &#125; 结果: Runable-aa–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-aa–实现Runable类似创建线程Runable-cc–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-bb–实现Runable类似创建线程Runable-aa–实现Runable类似创建线程 实现Callable方式 123456789101112class CallableTest implements Callable&lt;String&gt; &#123; private String name; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 3; i++) &#123; name = "" + i; System.out.println("name:" + name); &#125; return "测试结束"; &#125;&#125; 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; // Callable CallableTest c1 = new CallableTest(); CallableTest c2 = new CallableTest(); CallableTest c3 = new CallableTest(); //FutureTask是Runnable接口的子类，可以使用Thread类的构造来接收task对象 FutureTask&lt;String&gt; ft1 = new FutureTask&lt;String&gt;(c1); FutureTask&lt;String&gt; ft2 = new FutureTask&lt;String&gt;(c2); FutureTask&lt;String&gt; ft3 = new FutureTask&lt;String&gt;(c3); new Thread(ft1).start(); new Thread(ft2).start(); new Thread(ft3).start(); //多线程执行完毕后，可以使用FutureTask的父接口Future中的get()方法取得执行结果 System.out.println("ft1:" + ft1.get()); System.out.println("ft2:" + ft2.get()); System.out.println("ft3:" + ft3.get()); &#125; 结果: name:0name:0name:0name:1name:1name:2name:1name:2name:2ft1:测试结束ft2:测试结束ft3:测试结束 Runable与Callable区别:不同点Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果 Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛 注：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。 关键字Sleep Thread.sleep(2000); 表示当前线程暂停1000毫秒 ，其他线程不受影响Thread.sleep(2000); 会抛出InterruptedException 中断异常 12345678910111213@Override public void run() &#123; // 线程主方法 try &#123; Thread.sleep(2000); System.out.println("...暂停了2秒才开始输出"); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(title + "--继承Thread类似创建线程"); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Join t3.join(3000); 3秒 把某一下线程加入到主线程,表示只有等该线程执行完成才继续运行其他线程 1234567891011public static void main(String[] args) throws Exception &#123; // Thread ThreadTest t1 = new ThreadTest(&quot;线程A&quot;); ThreadTest t2 = new ThreadTest(&quot;线程B&quot;); ThreadTest t3 = new ThreadTest(&quot;线程C&quot;); t1.start(); // 在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的 t2.start(); t3.start(); //把t3线程加入到主线程 3秒 t3.join(3000);&#125; setPriority 线程优先级 12345678// 优先级最高t1.setPriority(Thread.MAX_PRIORITY);// 正常t2.setPriority(Thread.NORM_PRIORITY);// 优先级最低t3.setPriority(Thread.MIN_PRIORITY);// 可以使用数字t4.setPriority(10); yield 临时暂停 1t3.yield(); setDaemon 守护线程 t1.setDaemon(true);设置当前线程为守护进程 1t1.setDaemon(true); 小唠嗑： 想更加深入的了解多线程的使用,进看《Java中级_多线程二》篇 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>java中级_多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java测试]]></title>
    <url>%2F2019%2F07%2F11%2Fjava%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[您好 123public void test()&#123;&#125; 小唠嗑： 本章到这里就结束了，谢谢耐心看到这里的各位Boss,如果觉得有哪里说的不好的地方，还请高抬贵手多多原谅，不惜指教。 最后，谢谢！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blogs-Introduce]]></title>
    <url>%2F2019%2F05%2F12%2FBlogs-Introduce%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo github 搭建博客]]></title>
    <url>%2F2019%2F05%2F12%2Fhexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一，创建本地博客 安装软件 Node.js Git 安装hexo（以后的命令，均可以在鼠标右键Git Bash Here） 1$ npm install -g hexo-cli 建立一个Hexo文件夹，用于存放博客 在Hexo目录下，初始化Hexo文件 1Hexo init 在Hexo目录下安装hexo扩展插件 1npm install 在Hexo目录下安装git插件: 1npm install hexo-deployer-git --save 在Hexo目录下生成静态页面: 1hexo generate 在Hexo目录下启动本地服务器: 1hexo server 浏览器输入:http://localhost:4000 二, 部署到github 设置user.name和user.email: git config –global user.name “你的GitHub用户名” 注意global前面是两个双杠【-】 git config –global user.email “你的GitHub注册邮箱” 生成ssh密匙: ssh-keygen -t rsa -C “你的GitHub注册邮箱” ​ 【按需一般需要三次回车】确定 (此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 把id_rsa.pub的内容复制到GitHub账号:用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮,Title随便写. 修改目录配置文件: 1234deploy: type: git repo: git@github.com:oldzhoua/oldzhoua.github.io.git branch: master 清空静态页面: hexo clean 生成静态页面: hexo generate 部署到GitHub: hexo deploy 过程会让你输入g’ithub账号和密码 浏览器输入: oldzhoua.github.io 使用自己的域名 购买域名之后 在域名解析那里填写两个CNAME和A 类型: CNAME&gt;主机记录填写:www CNAME&gt;记录值填写: oldzhoua.github.io A&gt;主机记录填写:@ A&gt;主机值填写:( ping oldzhoua.github.io 会得到的IP值) 在Blogs文件夹下的source目录目录下建立一个没有后缀名的文件,写入,www.oldzhou.top,保存. 在GitHub自己的库中Settings 下的Github Page下填写域名. 在命令行输入: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入自己的域名访问&gt;完成 三，安装NexT主题 安装NexT 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 站点配置文件找到theme 12Hexo/_config.ymltheme: next 更改主题和验证主题之间，我们最好使用hexo clean清理Hexo的缓存 在Hexo目录下检查安装 1hexo s --debug 你可以打开http://localhost:4000在浏览器中，并检查站点是否正确工作 四，个性化设置 现在NexT外观，编辑更改方案主题配置文件，搜索scheme关键字 next主题有四种方案: Muse→默认方案。使用黑白色调，主要看上去干净。 Mist→具有整洁的单列视图。 Pisces→双页面计划布局。 Gemini→有不同的带阴影的列块来显示视图。 12345Next/_config.yml#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 编辑站点配置文件，设置language你需要的语言 12HEXO/config.ymllanguage: zh-CN 配置菜单项，默认情况下，Next提供home和archives页面。其他不提供 12345678910Next/_config.ymlmenu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 刚添加完菜单项的是无法打开的,需要在站点文件下创建相应的路径文件: 在站点文件下了输入以下命令: 1234hexo new page categorieshexo new page tagshexo new page abouthexo new page archives 默认情况下，Next显示没有徽章的菜单项的图标 12345Next/_config.ymlmenu_settings: icons: true # 显示计数 badges: true 配置网站标签页图标，放在Hexo\themes\next\source\images 123456789HEXO/_config.ymlfavicon: #一张16*16，32*32的图片 small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml 配置头像, 编辑主题配置文件 123456Next/_config.ymlavatar: url: /images/avatar.gif rounded: true rotated: true opacity: 1 配置作者，编辑站点配置文件的值，并设置author你的昵称 123HEXO/_config.yml# Siteauthor: xxx 配置描述，编辑站点配置文件的值，并设置description可以是你喜欢的句子 123HEXO/_config.yml# Sitedescription: xxxxxxx 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 配置头像: 在主题文件中: 1avatar: /images/touxiang.jpg 可以检查一下效果: 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器输入: http://localhost:4000/ 设置动态背景: 在主题配置文件中: 12# Canvas-nestcanvas_nest: true 修改文章超链接样式: 在Blogs/themes/next/source/css/_common/components/post/post.styl 文件中添加css: 12345678.post-body p a&#123; color: #FF0000; border-bottom: 2px solid #FF0000; &amp;:hover &#123; color: #4DFFFF; border-bottom: 2px solid #4DFFFF; &#125;&#125; 在文章末尾添加文章结束标记: 在 Blogs\themes\next\layout_macro 下打开命令行新建 passage-end-tag.swig 文件: 1touch passage-end-tag.swig 在新建文件中添加: 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #fc6423;font-size:16px;&quot;&gt;---本文结束&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;感谢您的阅读!---&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 在 Blogs\themes\next\layout_macro\post.swig 中的如下面位置添加: 12345678 &#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件添加: 12passage_end_tag: enabled: true 设置头像及样式: 1avatar: 头像地址 设置头像圆角:在Blogs/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 添加: 12345.site-author-image &#123; border-radius: 70px; -webkit-border-radius: 70px; -moz-border-radius: 70px;&#125; 侧栏社交图标: 在主题配置文件搜索social 去掉#选择 123456789social: Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype || xxx,xxx表示图标,在Font Awesome Icon 网站找然后复制下来 文章添加阴影效果: 在Blogs\themes\next\source\css_custom\custom.styl下添加: 12345.post &#123; box-shadow: 0 0 10px rgba(255, 0, 0, .8); -webkit-box-shadow: 0 0 10px rgba(255, 0, 0, .8); -moz-box-shadow: 0 0 10px rgba(255, 0, 0, .8); &#125; 文件上传的方法 在站点文件下打开命令行安装插件: 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 在站点配置文件修改如下: 1post_asset_folder: true 在 hexo new “标题” 的时候,会在同级目录下生成多一个同名的文件夹(用于放图片)格式如下: 1![](标题\图片名.png) 需要注意的是,如果是以选择的方式添加的,可以选择把多余的路径删掉, 比如: 1![](E:\Blogs\source\_posts\标题\图片名.png) 1![](标题\图片名.png) 然后重新部署一下就可以看到图片了 设置底部添加访问量: 使用busuanzi: 在 Blogs/themes/next/layout/_partials/footer.swig 文件中顶部添加: 1234567&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 设置网站底部字数统计 在站点目录下安装插件 1npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig 文件中添加: 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 设置文章统计功能 安装插件 1npm install hexo-wordcount --save 修改主题配置文件: 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 设置网页进度条 在主题配置文件搜索pace:值改为 true,去掉#选择款式 1234567# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shoppace_theme: pace-theme-minimal 设置网站标签页图标 在图标网站, 比如: 阿里巴巴矢量图标库 ,下载一张16x16,32x32的图 在Blogs/themes/next/source/images 中,替换默认的两张图片 如果修改了名字侧需要在主题配置文件中搜索favicon 12345# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png 隐藏底部标记 在Blogs/themes/next/layout/_partials/footer.swig 中,用注释掉相应的代码 设置博文置顶 在Blogs/node_modules/hexo-generator-index/lib/generator.js 的代码改为: 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章头添加top: xx,值越大越靠前显示: 1234567title: next主题优化系列二date: 2019-01-18 14:21:49tags:- next- 优化categories: nexttop: 88 设置侧栏推荐阅读 修改主题配置文件搜索,Blog rolls: 1234567# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Title: http://example.com/ 增加版权信息 在Blogs/themes/next/layout/_macro/ 添加 my-copyright.swig文件 1touch my-copyright.swig my-copyright.swig代码: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在Blogs/themes/next/source/css/_common/components/post/添加 my-copyright.styl文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 在Blogs/themes/next/layout/_macro/post.swig 文件中如下位置添加代码: 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 如: 12345678910111213141516&#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在Blogs/themes/next/source/css/_common/components/post/post.styl文件最后添加: 1@import &quot;my-post-copyright&quot; 在文章头添加:copyright : true 123456tags: - next - 优化 categories: next copyright: true top: 配置站点配置文件: 123456# URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://oldzhoua.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: 重新部署就可以看见效果了 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
