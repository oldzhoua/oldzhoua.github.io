<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/blue/pace-theme-minimal.css">



  
  
    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css">



  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">











  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/css/jquery.fancybox.min.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1. JDK 和 JRE 有什么区别？">
<meta name="keywords" content="面试,Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="面试_Java基础">
<meta property="og:url" content="http://oldzhoua.github.io/2020/06/14/面试-Java基础/index.html">
<meta property="og:site_name" content="周宏伟的个人博客">
<meta property="og:description" content="1. JDK 和 JRE 有什么区别？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-14T03:16:18.705Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试_Java基础">
<meta name="twitter:description" content="1. JDK 和 JRE 有什么区别？">





  
  
  <link rel="canonical" href="http://oldzhoua.github.io/2020/06/14/面试-Java基础/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试_Java基础 | 周宏伟的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">周宏伟的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-java">

    
    
    
      
    

    
      
    

    <a href="/categories/java/" rel="section"><i class="menu-item-icon fa fa-fw fa-paper-plane"></i> <br>java</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-javaweb">

    
    
    
      
    

    
      
    

    <a href="/categories/javaweb/" rel="section"><i class="menu-item-icon fa fa-fw fa-cloud"></i> <br>javaweb</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-mybatis">

    
    
    
      
    

    
      
    

    <a href="/categories/mybatis/" rel="section"><i class="menu-item-icon fa fa-fw fa-medium"></i> <br>mybatis</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-spring">

    
    
    
      
    

    
      
    

    <a href="/categories/spring/" rel="section"><i class="menu-item-icon fa fa-fw fa-strikethrough"></i> <br>spring</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-springmvc">

    
    
    
      
    

    
      
    

    <a href="/categories/springmvc/" rel="section"><i class="menu-item-icon fa fa-fw fa-stumbleupon"></i> <br>springmvc</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-springboot2">

    
    
    
      
    

    
      
    

    <a href="/categories/springboot2/" rel="section"><i class="menu-item-icon fa fa-fw fa-bold"></i> <br>springboot2</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-其他技术">

    
    
    
      
    

    
      
    

    <a href="/categories/其他技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-strikethrough"></i> <br>其他技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-问题">

    
    
    
      
    

    
      
    

    <a href="/categories/面试/" rel="section"><i class="menu-item-icon fa fa-fw fa-question"></i> <br>问题</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">19</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">12</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">14</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></span>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oldzhoua.github.io/2020/06/14/面试-Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周宏伟">
      <meta itemprop="description" content="我喜欢的都很贵，所以我才要努力争取">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周宏伟的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">面试_Java基础

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 11:02:05 / 修改时间：11:16:18" itemprop="dateCreated datePublished" datetime="2020-06-14T11:02:05+08:00">2020-06-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">62k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">56 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p><strong>1. JDK</strong> <strong>和</strong> <strong>JRE</strong> <strong>有什么区别？</strong> <a id="more"></a></p>
<p><strong>JDK</strong>：<strong>Java Development Kit</strong> <strong>的简称， </strong>开发工具包，提供了 <strong>java</strong> <strong>的开发环境和运行环境。</strong></p>
<p><strong>JRE**</strong>：<strong>Java Runtime Environment</strong> <strong>的简称，</strong>java <strong>运行环境，为</strong> <strong>java</strong> <strong>的运行提供了所需环境。</strong></p>
<p><strong>具体来说</strong> <strong>JDK</strong> <strong>其实包含了</strong> <strong>JRE**</strong>，同时还包含了编译<strong> </strong>java<strong> </strong>源码的编译器<strong> </strong>javac<strong>**，还包含了很多</strong> <strong>java</strong> <strong>程序调试和分析的工具。简单来说：如果你需要运行</strong> <strong>java</strong> <strong>程序，只需安装</strong> <strong>JRE</strong> <strong>就可以了，如果你需要编写</strong> <strong>java</strong> <strong>程序，需要安装</strong> <strong>JDK**</strong>。**</p>
<p><strong>3.</strong> <strong>两个对象的</strong> <strong>hashCode()**</strong>相同，则<strong> </strong>equals()<strong>**也一定为</strong> <strong>true**</strong>，对吗？**</p>
<p><strong>equals</strong></p>
<p><code>equals()</code>方法是用来判断其他的对象是否和该对象相等，它的性质有：</p>
<p>自反性（reflexive）。对于任意不为<code>null</code>的引用值x，<code>x.equals(x)</code>一定是<code>true</code>。</p>
<p>对称性（symmetric）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>是<code>true</code>时，<code>y.equals(x)</code>也是<code>true</code>。</p>
<p>传递性（transitive）。对于任意不为<code>null</code>的引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>是<code>true</code>，同时<code>y.equals(z)</code>是<code>true</code>，那么<code>x.equals(z)</code>一定是<code>true</code>。</p>
<p>一致性（consistent）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，如果用于equals比较的对象信息没有被修改的话，多次调用时<code>x.equals(y)</code>要么一致地返回<code>true</code>要么一致地返回<code>false</code>。</p>
<p>对于任意不为<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>返回<code>false</code>。</p>
<p><strong>hashCode</strong></p>
<p><code>hashCode()</code>方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。</p>
<p>它的性质是：</p>
<p>在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用<code>hashCode()</code>方法，该方法必须始终如一返回同一个integer。</p>
<p>如果两个对象根据<code>equals(Object)</code>方法是相等的，那么调用二者各自的<code>hashCode()</code>方法必须产生同一个integer结果。</p>
<p>并不要求根据<code>equals(java.lang.Object)</code>方法不相等的两个对象，调用二者各自的<code>hashCode()</code>方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。</p>
<p>大量的实践表明，由<code>Object</code>类定义的<code>hashCode()</code>方法对于不同的对象返回不同的integer。</p>
<p>在每个改写了equals()方法的类中，必须要改写hashCode()方法。如果不这样做，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于hash的集合类结合在一起正常运作，这样的集合类包括HashMap、HashSet和HashTable。</p>
<p>需要注意的是: 这个hashCode()方法是合法的，因为相等的对象总是具有同样的散列码.</p>
<table>
<thead>
<tr>
<th>1  2  3</th>
<th>public int hashCode() {      return 0;  }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>但是它使得每一个对象都具有同样的散列码。因此，每个对象都被映射到同一个散列桶中，从而散列表被退化为链表。对于规模很大的散列表而言，这关系到散列表能否正常工作。</p>
<p>一个好的散列函数通常倾向于“7为不相等的对象产生不相等的散列码”。</p>
<p>如果一个类是非可变的，并且计算散列码的代价也比较大，那么你应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。</p>
<p>不要试图从散列码计算中排除掉一个对象的关键部分以提高性能</p>
<p><strong>不对，两个对象的</strong> <strong>hashCode()**</strong>相同，<strong><strong>equals()</strong></strong>不一定<strong> </strong>true<strong><strong>。</strong></strong>(<strong>两本书有着同样的书名和作者，但是它们是两本“不同”的书。</strong>)**</p>
<p><strong>代码解读：很显然**</strong>“<strong><strong>通话</strong></strong>”<strong><strong>和</strong></strong>“<strong><strong>重地</strong></strong>”<strong>**的</strong> <strong>hashCode()</strong> <strong>相同，然而</strong> <strong>equals()</strong> <strong>则为</strong> <strong>false**</strong>，因为在散列表中，<strong><strong>hashCode()</strong></strong>相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。**</p>
<p><strong>4. final</strong> <strong>在</strong> <strong>java</strong> <strong>中有什么作用？</strong></p>
<p><strong>final</strong> <strong>修饰的类叫最终**</strong>类<strong><strong>，该类</strong></strong>不能被继承<strong>**。</strong></p>
<p><strong>final</strong> <strong>修饰的**</strong>方法不能被重写<strong>**。</strong></p>
<p><strong>final</strong> <strong>修饰的变量叫常量，**</strong>常量必须初始化<strong>**，初始化之后值就不能被修改。</strong></p>
<p><strong>8. String str=”i”**</strong>与<strong> </strong>String str=new String(“i”)<strong>**一样吗？</strong></p>
<p><strong>不一样，因为内存的分配方式不一样。**</strong>String str=”i”<strong><strong>的方式，</strong></strong>(JVM java va)java<strong> </strong>虚拟机会将其分配到<strong><strong>常量池</strong></strong>-&gt;<strong><strong>方法区</strong></strong>中；而<strong> </strong>String str=new String(“i”)<strong> </strong>则会被分到<strong><strong>堆内存</strong></strong>中。**</p>
<p><strong>9.</strong> <strong>如何将字符串反转？</strong></p>
<p><strong>使用</strong> <strong>StringBuilder</strong> <strong>或者</strong> <strong>stringBuffer</strong> <strong>的</strong> <strong>reverse()</strong> <strong>方法。</strong></p>
<p><strong>10. String</strong> <strong>类的常用方法都有那些？</strong></p>
<p><strong>indexOf**</strong>()<strong>**：返回指定字符的索引。</strong></p>
<p><strong>charAt**</strong>()<strong>**：返回指定索引处的字符。</strong></p>
<p><strong>replace**</strong>()<strong>**：字符串替换。</strong></p>
<p><strong>trim**</strong>()<strong>**：去除字符串两端空白。</strong></p>
<p><strong>split**</strong>()<strong>**：分割字符串，返回一个分割后的字符串数组。</strong></p>
<p><strong>getBytes()**</strong>：返回字符串的<strong> </strong>byte<strong> </strong>类型数组。**</p>
<p><strong>length**</strong>()<strong>**：返回字符串长度。</strong></p>
<p><strong>toLowerCase()**</strong>：将字符串转成小写字母。**</p>
<p><strong>toUpperCase()**</strong>：将字符串转成大写字符。**</p>
<p><strong>substring()**</strong>：截取字符串。**</p>
<p><strong>equals**</strong>()<strong>**：字符串比较。</strong></p>
<p><strong>11.</strong> <strong>抽象类必须要有抽象方法吗？</strong></p>
<p>在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧</p>
<p><strong>不需要，抽象类不一定非要有抽象方法。</strong></p>
<p><strong>12.</strong> <strong>普通类和抽象类有哪些区别？</strong></p>
<p>1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<p>　　2）抽象类不能用来创建对象；</p>
<p>　　3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
<p>　　在其他方面，抽象类和普通的类并没有区别。</p>
<p><strong>普通类不能包含**</strong>抽象方法<strong>**，抽象类可以包含抽象方法。</strong></p>
<p><strong>抽象类不能直接实例化，普通类可以直接实例化。</strong></p>
<p><strong>15. java</strong> <strong>中</strong> <strong>IO</strong> <strong>流分为几种？</strong></p>
<p><strong>按功能来分：**</strong>输入流<strong><strong>（</strong></strong>input<strong><strong>）、</strong></strong>输出流<strong><strong>（</strong></strong>output<strong>**）。</strong></p>
<p><strong>按类型来分：**</strong>字节流和字符流<strong>**。</strong></p>
<p><strong>字节流和字符流的区别是：字节流按</strong> <strong>8</strong> <strong>位传输以字节为单位输入输出数据，字符流按</strong> <strong>16</strong> <strong>位传输以字符为单位输入输出数据。</strong></p>
<p><strong>16. BIO**</strong>、<strong><strong>NIO</strong></strong>、<strong>**AIO</strong> <strong>有什么区别？</strong></p>
<p><strong>BIO**</strong>：<strong>**Block IO</strong> <strong>同步阻塞式</strong> <strong>IO**</strong>，就是我们平常使用的传统<strong> </strong>IO<strong>**，它的特点是模式简单使用方便，并发处理能力低。</strong></p>
<p><strong>NIO**</strong>：<strong>**New IO</strong> <strong>同步非阻塞</strong> <strong>IO**</strong>，是传统<strong> </strong>IO<strong> </strong>的升级，客户端和服务器端通过<strong> </strong>Channel<strong><strong>（通道）通讯，实现了</strong></strong>多路复用<strong>**。</strong></p>
<p><strong>AIO**</strong>：<strong>**Asynchronous IO</strong> <strong>是</strong> <strong>NIO</strong> <strong>的升级，也叫</strong> <strong>NIO2**</strong>，实现了异步非堵塞<strong> </strong>IO<strong> </strong>，异步<strong> </strong>IO<strong> </strong>的操作<strong><strong>基于事件和回调机制</strong></strong>。**</p>
<p><strong>17. Files**</strong>的常用方法都有哪些？**</p>
<p><strong>Files.exists()**</strong>：检测文件路径是否存在。**</p>
<p><strong>Files.createFile()**</strong>：创建文件。**</p>
<p><strong>Files.createDirectory()**</strong>：创建文件夹。**</p>
<p><strong>Files.delete()**</strong>：删除一个文件或目录。**</p>
<p><strong>Files.copy()**</strong>：复制文件。**</p>
<p><strong>Files.move()**</strong>：移动文件。**</p>
<p><strong>Files.size()**</strong>：查看文件个数。**</p>
<p><strong>Files.read()**</strong>：读取文件。**</p>
<p><strong>Files.write()**</strong>：写入文件。**</p>
<p>容器</p>
<p><strong>18. java</strong> <strong>容器都有哪些？</strong></p>
<p>常用容器的图录：                               </p>
<p><strong>Collection</strong> <strong>和</strong> <strong>Collections</strong> <strong>有什么区别？</strong></p>
<p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p>  Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<p><strong>20. List**</strong>、<strong><strong>Set</strong></strong>、<strong>**Map</strong> <strong>之间的区别是什么？</strong></p>
<p>java的关键字（keyword）有多少个？</p>
<p>  51+2个保留字=53个关键字(java的关键字都是小写的！！)</p>
<p><strong>21. HashMap</strong> <strong>和</strong> <strong>Hashtable</strong> <strong>有什么区别？</strong></p>
<p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</p>
<p>hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。</p>
<p>hashMap允许空键值，而hashTable不允许。</p>
<p><strong>22.</strong> <strong>如何决定使用</strong> <strong>HashMap</strong> <strong>还是</strong> <strong>TreeMap**</strong>？**</p>
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>
<p><strong>23.</strong> <strong>说一下</strong> <strong>HashMap</strong> <strong>的实现原理？</strong></p>
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </p>
<p>HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p>
<p><strong>24.</strong> <strong>说一下**</strong>HashSet<strong> </strong>的实现原理？**</p>
<p>HashSet底层由HashMap实现</p>
<p>HashSet的值存放于HashMap的key上</p>
<p>HashMap的value统一为PRESENT present</p>
<p><strong>25. ArrayList</strong> <strong>和</strong> <strong>LinkedList</strong> <strong>的区别是什么？</strong></p>
<p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂是 O(1)，而 LinkedList 是 O(n)。</p>
<p><strong>26.</strong> <strong>如何实现数组和</strong> <strong>List</strong> <strong>之间的转换？</strong></p>
<p>List转换成为数组：调用ArrayList的toArray方法。</p>
<p>数组转换成为List：调用Arrays的asList方法。</p>
<p><strong>27. ArrayList</strong> <strong>和</strong> <strong>Vector</strong> <strong>的区别是什么？</strong></p>
<p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 </p>
<p>ArrayList比Vector快，它因为有同步，不会过载。 </p>
<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<p><strong>28. Array</strong> <strong>和</strong> <strong>ArrayList</strong> <strong>有何区别？</strong></p>
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 </p>
<p>Array是指定大小的，而ArrayList大小是固定的。 </p>
<p>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>
<p><strong>29.</strong> <strong>在</strong> <strong>Queue</strong> <strong>中</strong> <strong>poll()**</strong>和<strong> </strong>remove()<strong>**有什么区别？</strong></p>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<p><strong>30.</strong> <strong>哪些集合类是线程安全的？</strong></p>
<p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</p>
<p>enumeration：枚举，相当于迭代器。</p>
<p>statck：堆栈类，先进后出。(hashtable的子类)</p>
<p>hashtable：就比hashmap多了个线程安全。</p>
<p><strong>31.</strong> <strong>迭代器</strong> <strong>Iterator</strong> <strong>是什么？</strong></p>
<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p>
<p><strong>32. Iterator</strong> <strong>怎么使用？有什么特点？</strong></p>
<p>Java中的Iterator功能比较简单，并且只能单向移动：　　</p>
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。　　</p>
<p>(2) 使用next()获得序列中的下一个元素。　　</p>
<p>(3) 使用hasNext()检查序列中是否还有元素。　　</p>
<p>(4) 使用remove()将迭代器新返回的元素删除。</p>
<p>　　</p>
<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>
<p><strong>33. Iterator</strong> <strong>和</strong> <strong>ListIterator</strong> <strong>有什么区别？</strong></p>
<p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 </p>
<p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 </p>
<p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<p>多线程</p>
<p><strong>35.</strong> <strong>并行和并发有什么区别？</strong></p>
<p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</p>
<p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p>
<p>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</p>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<p><strong>36.</strong> <strong>线程和进程的区别？</strong></p>
<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<p><strong>守护线程是什么？</strong></p>
<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<p><strong>38.</strong> <strong>创建线程有哪几种方式？</strong></p>
<p>①. 继承Thread类创建线程类</p>
<p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</p>
<p>创建Thread子类的实例，即创建了线程对象。</p>
<p>调用线程对象的start()方法来启动该线程。</p>
<p>②. 通过Runnable接口创建线程类</p>
<p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p>
<p>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p>
<p>调用线程对象的start()方法来启动该线程。</p>
<p>③. 通过Callable和Future创建线程</p>
<p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值</p>
<p>使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
<p><strong>39.</strong> <strong>说一下</strong> <strong>runnable</strong> <strong>和</strong> <strong>callable</strong> <strong>有什么区别？</strong></p>
<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
<p>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<p><strong>40.</strong> <strong>线程有哪些状态？</strong></p>
<p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<p>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</p>
<p>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</p>
<p>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</p>
<p>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</p>
<p>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　</p>
<p><strong>41. sleep()</strong> <strong>和</strong> <strong>wait()</strong> <strong>有什么区别？</strong></p>
<p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
<p><strong>42. notify()**</strong>和<strong> </strong>notifyAll()<strong>**有什么区别？</strong></p>
<p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>
<p>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</p>
<p>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<p><strong>43.</strong> <strong>线程的</strong> <strong>run()**</strong>和<strong> </strong>start()<strong>**有什么区别？</strong></p>
<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<p><strong>44.</strong> <strong>创建线程池有哪几种方式？</strong></p>
<p>①. newFixedThreadPool(int nThreads)</p>
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p>②. newCachedThreadPool()</p>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<p>③. newSingleThreadExecutor()</p>
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<p>④. newScheduledThreadPool(int corePoolSize)</p>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<p><strong>45.</strong> <strong>线程池都有哪些状态？</strong></p>
<p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>
<p>  线程池各个状态切换框架图：</p>
<p><strong>46.</strong> <strong>线程池中</strong> <strong>submit()**</strong>和<strong> </strong>execute()<strong>**方法有什么区别？</strong></p>
<p>接收的参数不一样</p>
<p>submit有返回值，而execute没有</p>
<p>submit方便Exception处理</p>
<p><strong>47.</strong> <strong>在</strong> <strong>java</strong> <strong>程序中怎么保证多线程的运行安全？</strong></p>
<p>线程安全在三个方面体现：</p>
<p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p>
<p>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</p>
<p>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>
<p><strong>48.</strong> <strong>多线程锁的升级原理是什么？</strong></p>
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<p>​<br> 锁升级的图示过程： </p>
<p><strong>49.</strong> <strong>什么是死锁？</strong></p>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称.</p>
<p><strong>50.</strong> <strong>怎么防止死锁？</strong></p>
<p>死锁的四个必要条件：</p>
<p>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</p>
<p>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</p>
<p>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
<p>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p><strong>51. ThreadLocal</strong> <strong>是什么？有哪些使用场景？</strong></p>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p><strong>synchronized</strong> <strong>底层实现原理？</strong></p>
<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<p>普通同步方法，锁是当前实例对象</p>
<p>静态同步方法，锁是当前类的class对象</p>
<p>同步方法块，锁是括号里面的对象</p>
<p><strong><br> \53. synchronized</strong> <strong>和</strong> <strong>volatile</strong> <strong>的区别是什么？</strong></p>
<p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； </p>
<p>synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</p>
<p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p>
<p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p>
<p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<p><strong>54. synchronized</strong> <strong>和</strong> <strong>Lock</strong> <strong>有什么区别？</strong></p>
<p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p>
<p>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p>
<p>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p>
<p>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p>
<p>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</p>
<p>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p>
<p><strong>55. synchronized</strong> <strong>和</strong> <strong>ReentrantLock</strong> <strong>区别是什么？</strong></p>
<p>synchronized是和if、else、for、while一样的关键字，</p>
<p>ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： </p>
<p>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </p>
<p>ReentrantLock可以获取各种锁的信息</p>
<p>ReentrantLock可以灵活地实现多路通知 </p>
<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中markword。</p>
<p><strong>56. atomic</strong> <strong>的原理？</strong></p>
<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>
<p>反射</p>
<p><strong>57.</strong> <strong>什么是反射？</strong></p>
<p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<p>Java反射：</p>
<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法。对于任意一个对象，能否调用它的任意一个方法</p>
<p>Java反射机制主要提供了以下功能：</p>
<p>在运行时构造任意一个类的对象。</p>
<p>在运行时判断任意一个对象所属的类。</p>
<p>在运行时判断任意一个类所具有的成员变量和方法。</p>
<p>在运行时调用任意一个对象的方法。 </p>
<p><strong>58.</strong> <strong>什么是</strong> <strong>java</strong> <strong>序列化？什么情况下需要序列化？</strong></p>
<p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br> 什么情况下需要序列化：</p>
<p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br> b）当你想用套接字在网络上传送对象的时候；<br> c）当你想通过RMI传输对象的时候；</p>
<p><strong>59.</strong> <strong>动态代理是什么？有哪些应用？</strong></p>
<p>动态代理：</p>
<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>
<p>动态代理的应用：</p>
<p>Spring的AOP</p>
<p>加事务</p>
<p>加权限</p>
<p>加日志</p>
<p><strong>60.</strong> <strong>怎么实现动态代理？</strong></p>
<p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>
<p><strong>61.</strong> <strong>为什么要使用克隆？</strong></p>
<p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>
<p><strong>62.</strong> <strong>如何实现对象克隆？</strong></p>
<p>有两种方式：</p>
<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p>
<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：</p>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p>
<p><strong>63.</strong> <strong>深拷贝和浅拷贝区别是什么？</strong></p>
<p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例:assign()）</p>
<p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p>
<p><strong>1.**</strong>写<strong><strong>clone()</strong></strong>方法时，通常都有一行代码，是什么**</p>
<p>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。</p>
<p><strong>2.**</strong>面向对象的特征有哪些方面**</p>
<p>==封装==：将对象封装成独立的，高度自治的，相对封闭的模块，实现“高内聚，低耦合”，降低相互的依赖性，这个对象状态（属性）由这个对象自己的行为（方法）来读取和改变，将属性（变量）定位private，只有这个类自己的方法才可以访问到这些成员变量，一个原则是：让方法和它待在一起。</p>
<p>==继承==：表示的是类与类的关系，是子类共享父类所有数据和方法的一种机制，可提高软件的可重用性和扩展性，缺点是加强了耦合性。</p>
<p>构造方法和private修饰的方法不可以被继承。</p>
<p>==多态==：程序运行时的多种状态，增强了软件的灵活性和扩展性。</p>
<p>==抽象==： 将事物的相似和共性之处，拿出来，然后将这些事物归为一个类，忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面，抽象包括行为抽象和状态抽象两个方面。</p>
<p>把握一个原则：当前系统需要什么就只考虑什么。</p>
<p><strong>2.java**</strong>中实现多态的机制是什么？**</p>
<p>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才<strong><em>动态绑定\</em></strong>，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<p><strong>3.abstract class**</strong>和<strong><strong>interface</strong></strong>有什么区别<strong>**?</strong></p>
<p>抽象类：含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。</p>
<p>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。</p>
<p>abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，==所以，<em>不能有<strong>抽象</strong>构造方法或<strong>抽象</strong>静态方法**==</em>。</p>
<p><strong>如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为**</strong>abstract<strong>**类型。</strong></p>
<p>接口：（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。</p>
<p> - 接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p>
<p><strong>==**</strong>语法区别<strong><strong>==</strong></strong>：**</p>
<p>抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），==但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型==。</p>
<p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
<p>一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p><strong>==**</strong>应用上的区别<strong>**==</strong>：</p>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约</p>
<p>而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。</p>
<p>//父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。</p>
<p><strong>4.abstract**</strong>的<strong><strong>method</strong></strong>是否可同时是<strong><strong>static,</strong></strong>是否可同时是<strong><strong>native</strong></strong>，是否可同时是<strong>**synchronized?</strong></p>
<p>abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</p>
<p>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。</p>
<p>例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk的源代码，可以发现FileOutputStream的open方法的定义如下：<figure class="highlight plain"><figcaption><span>native void open(String name) throws FileNotFoundException;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，==但需要在前面声明native==。</span><br><span class="line"></span><br><span class="line">关于synchronized与abstract合用的问题，我觉得也不行，synchronized应该是作用在一个具体的方法上才有意义，而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。</span><br><span class="line"></span><br><span class="line">**5.****什么是内部类？****Static Nested Class** **和** **Inner Class****的不同。**</span><br><span class="line"></span><br><span class="line">首先内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</span><br><span class="line"></span><br><span class="line">内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已</span><br><span class="line"></span><br><span class="line">内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在方法内部定义的内部类前面不能有访问类型修饰符，</span><br><span class="line"></span><br><span class="line">**6.****内部类可以引用它的包含类的成员吗？有没有什么限制？**</span><br><span class="line"></span><br><span class="line">一般而言是可以的。如果不是静态内部类，那没有什么限制！</span><br><span class="line"></span><br><span class="line">但是，如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员</span><br><span class="line"></span><br><span class="line">**7.Anonymous Inner Class (****匿名内部类****)****是否可以****extends(****继承****)****其它类，是否可以****implements(****实现****)interface(****接口****)?**</span><br><span class="line"></span><br><span class="line">可以继承其他类或实现其他接口。不仅是可以，而是必须!</span><br><span class="line"></span><br><span class="line">**8.super.getClass()****方法调用**</span><br><span class="line"></span><br><span class="line">  import java.util.Date;</span><br><span class="line">   public class Test extends Date&#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">       new Test().test();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public void test()&#123;</span><br><span class="line">       System.out.println(super.getClass().getName());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果是Test,</span><br><span class="line">  在test方法中，直接调用getClass().getName()方法，返回的是Test类名,由于getClass()在Object类中定义成了final，子类不能覆盖该方法。</span><br><span class="line">  所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法。</span><br><span class="line">  所以，super.getClass().getName()方法返回的也应该是Test，如果想得到父类的名称，应该用如下代码：getClass().getSuperClass().getName();</span><br><span class="line"></span><br><span class="line">**9.jdk****中哪些类是不能继承的？**   </span><br><span class="line"></span><br><span class="line">不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中比如，System,String,StringBuffer等类型。</span><br><span class="line"></span><br><span class="line">**10.String****是最基本的数据类型吗****?**</span><br><span class="line"></span><br><span class="line">不是，是属于引用类型。引用类型还有数组，日期等类型，java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</span><br><span class="line"></span><br><span class="line">基本数据类型包括byte、int、char、long、float、double、boolean和short。</span><br><span class="line"></span><br><span class="line">**11.String s = &quot;Hello&quot;;s = s + &quot; world!&quot;;****这两行代码执行后，原始的****String****对象中的内容到底变了没有？**</span><br><span class="line"></span><br><span class="line">没有。因为String由final修饰，被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。</span><br><span class="line"></span><br><span class="line">如果要使用内容相同的字符串，不必每次都new一个String。比如下面的例子，在构造器中对一个叫S的string引用变量进行初始化，将其设置为初始值：应该如下这样做</span><br><span class="line"></span><br><span class="line"> public class Demo &#123;</span><br><span class="line">   private String s;</span><br><span class="line">   ...</span><br><span class="line">   public Demo &#123;</span><br><span class="line">   s = &quot;Initial Value&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">而不是==s = new String(&quot;Initial Value&quot;)==，因为这样每次都会掉用新的构造器，生成新的对象，性能低下的同时，内存开销大</span><br><span class="line"></span><br><span class="line">**12.****是否可以继承****String****类****?**</span><br><span class="line"></span><br><span class="line">不能，String类是final类，故不可以继承。</span><br><span class="line"></span><br><span class="line">**13.String s = new String(&quot;xyz&quot;);****创建了几个****String Object?** **二者之间有什么区别？**   </span><br><span class="line"></span><br><span class="line">两个或者一个对象。</span><br><span class="line"></span><br><span class="line">”xyz”对应一个对象，这个对象放在==字符串常量缓冲区==，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。</span><br><span class="line"></span><br><span class="line">New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象，如果以前就用过’xyz’，就不会创建”xyz”自己了，直接从缓冲区拿。</span><br><span class="line"></span><br><span class="line">**14.String** **和****StringBuffer****的区别**</span><br><span class="line"></span><br><span class="line">JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。</span><br><span class="line"></span><br><span class="line">String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。</span><br><span class="line"></span><br><span class="line">String类： 表示内容不可改变的字符串，string重写了equals（）方法，new String(“abc”).equals(new String(“abc”)的结果为true，</span><br><span class="line"></span><br><span class="line">StringBuffer类： 表示内容可以被修改的字符串，因此当你知道字符数据要改变的时候你就可以使用==StringBuffer==（比如：你可以使用StringBuffer来动态构造字符数据），StringBuffer并没有实现equals（）方法，故new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</span><br><span class="line"></span><br><span class="line"> StringBuffer sbf = new StringBuffer(); </span><br><span class="line">  for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">   sbf.append(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。</span><br><span class="line"> String str = new String();  </span><br><span class="line"> for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">   str = str + i;</span><br><span class="line"> &#125;</span><br><span class="line"> 在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。</span><br><span class="line"></span><br><span class="line">**15.StringBuffer****与****StringBuilder****的区别**</span><br><span class="line"></span><br><span class="line">StringBuffer和StringBuilder类都表示内容可以被修改的字符串</span><br><span class="line"></span><br><span class="line">StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。</span><br><span class="line"></span><br><span class="line">如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</span><br><span class="line"></span><br><span class="line">**16.****如何把一段逗号分割的字符串转换成一个数组****?**   </span><br><span class="line"></span><br><span class="line">用正则表达式，代码大概为：==String [] result = orgStr.split(“,”);==</span><br><span class="line"></span><br><span class="line">用 StringTokenizer 代码为（高逼格）：</span><br></pre></td></tr></table></figure></p>
<p>String orgStr = “aa,aa,dd,d”;<br>StringTokenizer tokener = new StringTokenizer(orgStr,”,”);<br>String[] result = new String[tokener.countTokens()];<br>int i = 0;<br>while(tokener.hasMoreElements()){<br>    result[i++] = tokener.nextToken();<br>}<br>for (String s : result) {<br>    System.out.println(s);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">面向对象设计原则</span><br><span class="line"></span><br><span class="line">**1.****单一职责原则**</span><br><span class="line"></span><br><span class="line">\- 在面向对象设计中，分工理论就是单一职责原则(Single Pesponsibility Prineiple, SRP)</span><br><span class="line"> \- 两个含义</span><br><span class="line">  \- 避免相同的职责分散到不同的类中</span><br><span class="line">  \- 避免一个类承担太多职责</span><br><span class="line"> \- 为什么要遵循单一设计原则</span><br><span class="line">  \- 可以减少类之间的耦合：当需求变化时，只修改一个类，从而隔离了变化。</span><br><span class="line">  \- 提高类的复用性</span><br><span class="line">  \- 单一职责使得组件可以方便的拆卸和组装</span><br><span class="line"> \- 应用：用工厂模式来实现不同数据库操作类。</span><br><span class="line"></span><br><span class="line">**2.****接口隔离原则：**</span><br><span class="line"></span><br><span class="line">\- 接口隔离原则(Interface Segregation Principle, ISP): 客户端不应该被强迫实现不会使用的接口</span><br><span class="line"></span><br><span class="line">\- 接口隔离原则的主要观点 </span><br><span class="line"></span><br><span class="line">\- 一个类对另外一个类的依赖性应当是建立在最小的接口上</span><br><span class="line"> \- ISP 可以达到不强迫客户依赖于他们不使用的方法，接口的实现类应该只呈现为单一职责的角色(遵守SRP原则)。</span><br><span class="line"> \- ISP 还可降低客户端之间的相互影响——当某个客户程序要求提供新的职责(需求变更)而迫使接口发生改变时，影响到其他客户程序的可能性会是最小的。</span><br><span class="line"> \- 客户端程序不应该依赖它不需要的接口方法</span><br><span class="line"> \- ISP强调的是接口对客户端的承诺越少越好，并且要做到专一。</span><br><span class="line"> \- 接口污染：过于臃肿的接口设计是对接口的污染。接口污染就是为接口添加不必要的职责，如果开发人员在接口中增加一个新功能的主要目的只是减少接口实现类的数目，则此设计导致接口被不断的“污染” 并 “变胖” </span><br><span class="line"></span><br><span class="line">**3.****开放** **-** **封闭原则：**</span><br><span class="line"></span><br><span class="line"> \- 开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。</span><br><span class="line"> \- 关闭：在模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。</span><br><span class="line"> \- 一个模块在扩展性方面应该是开放的，在更改性方面应该是封闭的。</span><br><span class="line"> \- 该原则的**核心是想是对抽象编程，而不是具体编程**，因为抽象相对稳定。</span><br><span class="line">  让类依赖于固定的抽象，这样的修改就是封闭的，通过面向对象的继承和多态机制，可以实现对抽象体的继承，</span><br><span class="line">  通过覆写其方法改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。</span><br><span class="line"> \- 在设计方面充分应用 抽象 和 封装 的思想。</span><br><span class="line"> \- 在系统功能编程实现方面应用面向接口的编程。</span><br><span class="line"></span><br><span class="line">**4.****替换原则** **：里氏替换原则****(Liskov Substiution Principle, LSP)****定义以及主要思想：子类型必须能够替换掉它们的父类型、**并出现在父类能够出现的任何地方。</span><br><span class="line">    \- 父类的方法都要在子类中实现或者重写, 派生类只实现其抽象类中声明的方法, 而不应当给出多余的方法定义或实现。</span><br><span class="line">    \- 在客户端程序中只应该出现父类对象，而不是直接使用子类对象, 这样可以实现运行期绑定(多态绑定)。</span><br><span class="line"></span><br><span class="line">**5.****依赖倒置原则：依赖倒置的核心原则是解耦，如果脱离这个最原始的原则，那就是本末倒置。**</span><br><span class="line"></span><br><span class="line">\- 将依赖关系倒置为依赖接口:</span><br><span class="line">  \- 上层模块不应该依赖下层模块, 它们共同依赖于一个抽象。</span><br><span class="line">  \- 抽象不能依赖于具体, 具体应该要依赖于抽象</span><br><span class="line"> \- IOC(Inversion of Control) 是依赖倒置原则(Dependence Inversion Principle, DIP)的同义词。</span><br><span class="line">  \- DI: 依赖注入</span><br><span class="line">  \- DS: 依赖查找</span><br><span class="line"> \- 如何满足DIP:</span><br><span class="line">  \- 每个较高层次类都为它所需要的服务提出一个接口声明, 较低层次实现这个接口</span><br><span class="line">  \- 每个高层类都通过该抽象接口使用服务</span><br><span class="line"></span><br><span class="line">**6.****深拷贝和浅拷贝：**</span><br><span class="line"></span><br><span class="line">  简单来讲就是复制、克隆；Person p=new Person(“张三”);</span><br><span class="line"></span><br><span class="line">  浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错</span><br><span class="line"></span><br><span class="line">  深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间</span><br><span class="line"></span><br><span class="line">**7.****值传递和引用传递：**</span><br><span class="line"></span><br><span class="line">  值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量</span><br><span class="line"></span><br><span class="line">  引用传递：就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改</span><br><span class="line"></span><br><span class="line">**8.web** **容器功能：**</span><br><span class="line"></span><br><span class="line">  通信支持、管理Servlet生命周期，多线程、将jsp转换成java等等</span><br><span class="line"></span><br><span class="line">**9.java****内存分配**</span><br><span class="line"></span><br><span class="line">  寄存器：我们无法控制</span><br><span class="line"></span><br><span class="line">  静态域：static定义的静态成员</span><br><span class="line"></span><br><span class="line">  常量池：编译时被确定并保存在.class文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）</span><br><span class="line"></span><br><span class="line">  非ram存储：硬盘等永久存储空间</span><br><span class="line"></span><br><span class="line">  堆内存：new创建的对象和数组，由java虚拟机自动垃圾回收器管理,存取速度慢</span><br><span class="line"></span><br><span class="line">  栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性</span><br><span class="line"></span><br><span class="line">**11.****一个****&quot;.java&quot;****源文件中是否可以包括多个类（不是内部类）？有什么限制？**</span><br><span class="line"></span><br><span class="line">可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</span><br><span class="line"></span><br><span class="line">13.简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。</span><br><span class="line"></span><br><span class="line">  条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型</span><br><span class="line"></span><br><span class="line">  逻辑操作不会产生短路.</span><br><span class="line"></span><br><span class="line">  使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算</span><br><span class="line"></span><br><span class="line">**14.****说说****&amp;****和****&amp;&amp;****的区别。**</span><br><span class="line"></span><br><span class="line">==相同点==：&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</span><br><span class="line"></span><br><span class="line">==&amp;&amp;具有短路功能==：即如果第一个表达式为false，则不再计算第二个表达式。</span><br><span class="line"></span><br><span class="line">举个列子1：对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException；如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。</span><br><span class="line"></span><br><span class="line">**15.switch****语句能否作用在****byte****上，能否作用在****long****上，能否作用在****String****上****?**</span><br><span class="line"></span><br><span class="line">在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。long不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它不能作用于swtich语句中。</span><br><span class="line"></span><br><span class="line">对于string而言：JDK1.7以前是不能作为switch的，以后即可以作用于switch中。</span><br><span class="line"></span><br><span class="line">**17.char****型变量中能不能存贮一个中文汉字****?****为什么****?**</span><br><span class="line"></span><br><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字。</span><br><span class="line"></span><br><span class="line">不过要注意的是：</span><br><span class="line"></span><br><span class="line">如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字</span><br><span class="line"></span><br><span class="line">unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</span><br><span class="line"></span><br><span class="line">**18.****用最有效率的方法算出****2****乘以****8****等於几****?**</span><br><span class="line"></span><br><span class="line">方法：将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8（2的3次方），只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是将2左移3位，即2 &lt;&lt; 3。</span><br><span class="line"></span><br><span class="line">**19.****使用****final****关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？**</span><br><span class="line"></span><br><span class="line">使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：final StringBuffer a=new StringBuffer(&quot;immutable&quot;);</span><br><span class="line"></span><br><span class="line">执行如下语句将报告编译期错误：a=new StringBuffer(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">但是，执行如下语句则可以通过编译：a.append(&quot; broken!&quot;);</span><br><span class="line"></span><br><span class="line">java有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：   </span><br><span class="line"></span><br><span class="line">public void method(final  StringBuffer  param)  &#123;  &#125;   </span><br><span class="line"></span><br><span class="line">实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：    param.append(&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">**20.java** **中对象的创建方法有几种？**</span><br><span class="line"></span><br><span class="line">通过new来创建</span><br><span class="line"></span><br><span class="line">通过反射创建</span><br><span class="line"></span><br><span class="line">通过复制创建</span><br><span class="line"></span><br><span class="line">**21.&quot;==&quot;****和****equals****方法究竟有什么区别？**</span><br><span class="line"></span><br><span class="line">如果是在object对象中，那么两者所表示的都是值是否相等（public boolean equals(Object obj)&#123;return (this==obj); &#125;）,可以看到object的equals方法是使用的“==”比较。</span><br><span class="line"></span><br><span class="line">一般而言，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符，也就是比较内存中所存储的两个变量的值是否相等。</span><br><span class="line"></span><br><span class="line">举例：String a=new String(&quot;foo&quot;); String b=new String(&quot;foo&quot;);它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。</span><br><span class="line"></span><br><span class="line">在实际开发中，我们经常要比较传递进行来的字符串内容是否等，此时是使用的equals（）方法。</span><br><span class="line"></span><br><span class="line">对于equals（）而言，默认情况是从object类继承的，当希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由自己写代码来决定在什么情况即可认为两个对象的内容是相同的。</span><br><span class="line"></span><br><span class="line">**22.****静态变量和实例变量的区别？**</span><br><span class="line"></span><br><span class="line">在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</span><br><span class="line"></span><br><span class="line">在程序运行时的区别：</span><br><span class="line"></span><br><span class="line">实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。</span><br><span class="line"></span><br><span class="line">静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。、</span><br><span class="line"></span><br><span class="line">总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">java  对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。</span><br></pre></td></tr></table></figure>
<p>public static void main(String[] args) {<br>    public static int staticVar = 0;<br>    public int instanceVar = 0;<br>    public VariantTest() {<br>        staticVar++;<br>        instanceVar++;<br>        System.out.println(“staticVar =” + staticVar + ”,instanceVar =”+instanceVar);<br>    }<br>}<br><code>`</code></p>
<p><strong>23.**</strong>是否可以从一个<strong><strong>static</strong></strong>方法内部发出对非<strong><strong>static</strong></strong>方法的调用？**</p>
<p>不可以。</p>
<p>对于static修饰的静态方法，是随着类的加载而加载，且调用的时可以不用创建对象而直接调用</p>
<p>非静态方法要与对象联系在一起，只有创建了对象了以后才能调用非静态方法，即当一个静态方法被调用的时候，有可能还没有创建任何实例对象。</p>
<p><strong>24.Integer**</strong>与<strong><strong>int</strong></strong>的区别**</p>
<p>int是java提供的8种原始数据类型之一，系统给的默认值为0。</p>
<p>Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。系统给的默认值为null。</p>
<p>即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况：</p>
<p>在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p>
<p>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<p><strong>25.Math.round(11.5)**</strong>等於多少<strong><strong>? Math.round(-11.5)</strong></strong>等於多少<strong>**?</strong></p>
<p>Math类中提供了三个与取整有关的方法：ceil（向上取整）、floor（向下取整）、round（四舍五入）</p>
<p>举例：</p>
<p>Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11</p>
<p>Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12</p>
<p>算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</p>
<p><strong>26.**</strong>下面的代码有什么不妥之处<strong>**?</strong></p>
<p>\1. if(username.equals(“zxx”){}； 2.int  x = 1; return x==1?true:false;</p>
<p>答：第一个问题少了一个右括号;第二个问题没有错误</p>
<p><strong>28.Overload**</strong>和<strong><strong>Override</strong></strong>的区别。<strong><strong>Overload</strong></strong>的方法是否可以改变返回值的类型<strong>**?</strong></p>
<p>Overload:表示方法重载，表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数、类型、位置不同），通过定义不同的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行：</p>
<p>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；</p>
<p>不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>方法的异常类型和数目不会对重载造成影响；</p>
<p>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
<p>Override：表示方法重写（覆盖），表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，当通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。</p>
<p>重写的方法的标志必须要和被重写的方法的标志完全匹配，才能达到重写的效果；</p>
<p>重写的方法的返回值必须和被重写的方法的返回一致；</p>
<p>重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类（因为子类是解决父类的一些方法，不能比父类更多问题）；</p>
<p>被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写(子类方法的访问权限只能比父类的更大，不能更小)。</p>
<p><strong>29.ClassLoader**</strong>如何加载<strong>**class</strong> <strong>。</strong></p>
<p>jvm里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap类加载负责加载jre/lib/rt.jar中的类， 我们平时用的jdk中的类都位于rt.jar中。extclassloader负责加载jar/lib/ext/*.jar中的类，appclassloader负责classpath指定的目录或jar中的类。除了bootstrap之外，其他的类加载器本身也都是java类，它们的父类是ClassLoader。</p>
<p>一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？</p>
<p>如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关联。椅子与腿和背时组合关系。</p>
<p>说说has a与is a的区别</p>
<p>is-a表示的是属于继承关系，比如兔子属于一种动物（继承关系）。has-a表示组合，包含关系，比如兔子包含有腿，头等组件；</p>
<p>Servlet的生命周期： init、 service、 destroy。</p>
<p><strong>30.**</strong>分层设计的好处**</p>
<p>把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合,不会出现牵一发而动全身的问题了</p>
<p>分层的好处：</p>
<p>实现了软件之间的解耦；</p>
<p>便于进行分工</p>
<p>便于维护</p>
<p>提高软件组件的重用</p>
<p>便于替换某种产品，比如持久层用的是hibernate,需要更换产品用toplink，就不用该其他业务代码，直接把配置一改。</p>
<p>便于产品功能的扩展。</p>
<p>便于适用用户需求的不断变化</p>
<p><strong>31.**</strong>序列化接口的<strong><strong>id</strong></strong>有什么用？**</p>
<p>对象经常要通过IO进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没有个统一的干法，于是，sun公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被sun的这种方案处理，必须实现Serializable接口。ObjectOutputStream.writeObject(obj);<br>Object obj = ObjectInputStream.readObject();</p>
<p>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun的jdk就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错!</p>
<p><strong>32.hashCode**</strong>方法的作用？**</p>
<p>hashcode这个方法是用来鉴定2个对象是否相等的。</p>
<p>与equals（）方法的区别：</p>
<p>简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了</p>
<p>hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。</p>
<p>hashcode相当于是一个对象的编码，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。</p>
<p>==举例==：有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这2个对象是相等的。如果姓名和性别相等就算2个对象相等的话，那么hashcode的方法也要返回姓名的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。++要从物理上判断2个对象是否相等，用==就可以了。++</p>
<p><strong>33.**</strong>构造器<strong><strong>Constructor</strong></strong>是否可被<strong>**override?</strong></p>
<p>重写发生在继承过程中（子父类间），但是构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。</p>
<p><strong>34.**</strong>接口是否可继承接口<strong>**?</strong> <strong>抽象类是否可实现**</strong>(implements)<strong><strong>接口</strong></strong>?<strong> </strong>抽象类是否可继承具体类<strong>**(concrete class)?</strong> <strong>抽象类中是否可以有静态的**</strong>main<strong>**方法？</strong></p>
<p>接口是特殊的抽象类，他是多态的经典体现。</p>
<p>抽象类是指具有抽象方法的类，该类中出了有抽象方法外，其他普通方法具有的属性抽象方法都有。他们的唯一区别就是不能创建实例对象和允许有abstract方法；</p>
<p>因此：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类。抽象类中可以有静态的main方法。<br> 题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串<br> 所以，上面的代码应该只创建了一个String对象(编译优化后的结果)。写如下两行代码，最终打印的结果应该为true。<br> String s = “a” + “b” + “c” + “d”;<br> System.out.println(s == “abcd”);</p>
<p><strong>结论：**</strong>finally<strong><strong>中的代码比</strong></strong>return<strong> </strong>和<strong><strong>break</strong></strong>语句后执行，只要<strong><strong>JVM</strong></strong>中没有遇到<strong><strong>system.exition</strong></strong>的异常，是<strong><strong>JVM</strong></strong>直接退出，那么<strong><strong>finally</strong></strong>都会被执行**。</p>
<p><strong>6.final, finally, finalize**</strong>的区别。**</p>
<p>final：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承，内部类要访问局部变量，局部变量必须定义成final类型。</p>
<p>finally：是异常处理语句结构的一部分，表示总是执行，除非是遇到重大错误error，才不会执行finally。</p>
<p>finalize：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。</p>
<p><strong>7.**</strong>运行时异常与一般异常有何异同？**</p>
<p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常（程序在虚拟机上运行时发生的非正常状态），是一种常见运行错误。</p>
<p>java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<p><strong>8.error**</strong>和<strong><strong>exception</strong></strong>有什么区别<strong>**?</strong>   </p>
<p>error：表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。</p>
<p>exception： 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<p><strong>9.Java**</strong>中的异常处理机制的简单原理和应用。**</p>
<p>异常是指java程序运行时（非编译）所发生的非正常情况或错误，Java使用面向对象的方式来处理异常，它把程序中发生的每s个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。</p>
<p>所有异常的根类为java.lang.Throwable：<strong>Throwable</strong>下面又派生了两个子类：<strong>Error</strong>和<strong>Exception</strong>。</p>
<p>Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了（内存溢出和线程死锁等系统问题）。</p>
<p>Exception表示程序还能够克服和恢复的问题：</p>
<p>其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉。</p>
<p>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p>
<p>java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。</p>
<p>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。</p>
<p><strong>10.Throwable**</strong>：异常的父类。**</p>
<p>error :jvm严重错误，JVM无法继续，因此这是不可捕捉无法用程序去恢复的错误。</p>
<p>exception： 可以捕获到，可以恢复。</p>
<p>cheched exception：IO/SQL异常，JVM要求我们对出现的异常进行catch。</p>
<p>runtime exception：运行时异常，我们可以不处理，将其抛出最后可以抛给JVM处理，多线程由thread.run()抛出，单线程由main（）函数抛出。运行时异常也有一般异常的子类，可以被catch到，如果不对其处理，要么线程终止，要么主线程终止（异常的处理目标就是将异常程序恢复正常）。</p>
<p><strong>11.**</strong>请写出你最常见到的<strong><strong>5</strong></strong>个<strong><strong>runtime exception</strong></strong>。**</p>
<p>在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。</p>
<p>ArrayindexOfBoundsException：数组越界异常。</p>
<p>NullPointerException：空指针异常。</p>
<p>ClassCastException：类型转换异常。</p>
<p>ClassNotFoundException：指定类不存在。</p>
<p>ArithmeticException：数字运算异常。</p>
<p>ArrayStoreException：数组存储与声明类型不兼容。</p>
<p>numberFormatException：数字格式异常。</p>
<p><strong>12.Java**</strong>语言如何进行异常处理，关键字：<strong><strong>throws,throw,try,catch,finally</strong></strong>分别代表什么意义？在<strong><strong>try</strong></strong>块中可以抛出异常吗？**</p>
<p>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。</p>
<p>try：指定一块预防所有”异常”的程序。</p>
<p>cache：紧跟在try程序后面，用来指定想要捕捉的”异常”的类型。</p>
<p>throw：不处理异常，直接明确地抛出一个”异常”，给上一层处理。</p>
<p>finally：确保一段代码不管发生什么”异常”都被执行一段代码。</p>
<p><strong>13.java**</strong>中有几种方法可以实现一个线程？用什么关键字修饰同步方法<strong><strong>? stop()</strong></strong>和<strong><strong>suspend()</strong></strong>方法为何不推荐使用？**</p>
<p>java5以前，有如下两种：</p>
<p>第一种(继承)：<br> new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：<br> new Thread(){<br>   public void run(){<br>   }<br> }.start();</p>
<p> 第二种（实现接口）：<br> new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：<br> new Thread(new Runnable(){<br>       public void run(){<br>     }<br>   }<br> ).start();</p>
<p>从java5开始，还有如下一些线程池创建多线程的方式：</p>
<p>ExecutorService pool = Executors.newFixedThreadPool(3)<br> for(int i=0;i&lt;10;i++){<br> pool.execute(new Runable(){<br> public void run(){<br>  }<br>  });<br> }<br> Executors.newCachedThreadPool().execute(new Runable(){<br> public void run(){<br> }<br> });<br> Executors.newSingleThreadExecutor().execute(new Runable(){<br> public void run(){<br> }<br> });</p>
<p>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</p>
<p>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。</p>
<p>对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<p>用synchronized关键字修饰同步方法。</p>
<p><strong>14.sleep()</strong> <strong>和</strong> <strong>wait()</strong> <strong>有什么区别**</strong>?**</p>
<p>sleep:</p>
<p>就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行。</p>
<p>如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</p>
<p>wait:</p>
<p>是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行。</p>
<p>只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。</p>
<p>如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</p>
<p><strong>15.**</strong>同步和异步有何异同，在什么情况下分别使用他们？举例说明。**</p>
<p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<p><strong>16.**</strong>同步有几种实现方法<strong>**?</strong></p>
<p>同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</p>
<p>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<p><strong>17.**</strong>当一个线程进入一个对象的一个<strong><strong>synchronized</strong></strong>方法后，其它线程是否可进入此对象的其它方法<strong>**?</strong></p>
<p>其他方法前是否加了synchronized关键字，如果没加，则能。</p>
<p>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</p>
<p>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</p>
<p><strong>18.**</strong>线程的基本概念、线程的基本状态以及状态之间的关系。**</p>
<p>好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。</p>
<p>状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。</p>
<p><strong>19.**</strong>简述<strong><strong>synchronized</strong></strong>和<strong><strong>java.util.concurrent.locks.Lock</strong></strong>的异同？**   </p>
<p>主要相同点：Lock能完成synchronized所实现的所有功能。</p>
<p>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。</p>
<p>举例说明（对下面的题用lock进行了改写）：</p>
<p>package com.huawei.interview;<br> import java.util.concurrent.locks.Lock;<br> import java.util.concurrent.locks.ReentrantLock;<br> public class ThreadTest {<br>   private int j;<br>   private Lock lock = new ReentrantLock();<br>   public static void main(String[] args) {<br>     // TODO Auto-generated method stub<br>     ThreadTest tt = new ThreadTest();<br>     for(int i=0;i&lt;2;i++)<br>     {<br>       new Thread(tt.new Adder()).start();<br>       new Thread(tt.new Subtractor()).start();<br>     }<br>   }<br>   private class Subtractor implements Runnable<br>   {<br>     @Override<br>     public void run() {<br>       // TODO Auto-generated method stub<br>       while(true)<br>       {<br>         lock.lock();<br>         try<br>         {<br>           System.out.println(“j–=” + j–);<br>         }finally<br>         {<br>           lock.unlock();<br>         }<br>       }<br>     }<br>   }<br>   private class Adder implements Runnable<br>   {</p>
<p>  @Override<br>   public void run() {<br>     while(true)<br>     {<br>       /<em>synchronized (ThreadTest.this) {<br>       System.out.println(“j++=” + j++);<br>       }</em>/<br>       lock.lock();<br>       try<br>       {<br>         System.out.println(“j++=” + j++);<br>       }finally<br>       {<br>         lock.unlock();<br>       }<br>     }<br>   }<br> }</p>
<p>}</p>
<p><strong>1.**</strong>你所知道的集合类都有哪些？主要方法？**</p>
<p>最常用的集合类是 List 和 Map。</p>
<p>List 的具体实现包括 ArrayList 和 Vector，适用于按数值索引访问元素的情形。</p>
<p>Map 提供了一个更通用的元素存储方法。</p>
<p>List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。</p>
<p>List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。</p>
<p>map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，</p>
<p>map也有get方法，参数是key，返回值是key对应的value。</p>
<p><strong>2.**</strong>介绍<strong><strong>Collection</strong></strong>框架的结构。**   </p>
<p>集合框架(Collection Framework)泛指java.util包的若干个类和接口。如Collection，List，ArrayList，LinkedList，Vector(自动增长数组),HashSet,HashMap等。</p>
<p>集合框架中的类主要封装的是典型的数据结构,如动态数组,链表,堆栈,集合，哈希表等。</p>
<p>集合框架类似编程中经常用到的工具类，使得编码这专注于业务层的实现，不需要从底层实现相关细节—“数据结构的封装”和”典型算法的实现”。</p>
<p><strong>3.Comparable**</strong>和<strong><strong>Comparator</strong></strong>接口是干什么的。**</p>
<p>Java提供了只包含一个compareTo()方法的Comparable接口。</p>
<p>这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口。</p>
<p>compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。</p>
<p>equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。</p>
<p>只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时 候，这个方法才返回true。</p>
<p><strong>4.Collection**</strong>框架中实现比较要实现什么接口。**</p>
<p>SortedSet和SortedMap接口对元素按指定规则排序。</p>
<p>SortedMap是对key列进行排序要实现 comparable 接口,把你的自定义类实现以上接口，实现 compareTo方法就OK了。</p>
<p><strong>5.comparable/comparator**</strong>区别。<strong>**
</strong> 用Comparable简单,只要实现Comparable接口的对象直接就成为一个可以比较的对象但是需要修改源代码。<br> 用Comparator的好处是不需要修改源代码,而是另外实现一个比较器,当某个自定义的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。</p>
<p><strong>6.List</strong> <strong>和</strong> <strong>Map</strong> <strong>区别**</strong>?**</p>
<p>List：是存储单列数据的集合，List中存储的数据是有顺序，并且允许重复。</p>
<p>Map：是存储键和值这样的双列数据的集合；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</p>
<p><strong>7.List**</strong>、<strong><strong>Map</strong></strong>、<strong><strong>Set</strong></strong>三个接口，存取元素时，各有什么特点？**   </p>
<p>List与Set都是单列元素的集合，它们有一个共同的父接口Collection。</p>
<p>List 以特定次序来持有元素，可有重复元素。</p>
<p>Set 无法拥有重复元素,内部排序.</p>
<p>Map 保存key-value值，value可多值。</p>
<p>Set里面不允许有重复的元素。</p>
<p>存元素：add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true；当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。</p>
<p>取元素：没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。</p>
<p>List表示有先后顺序的集合。</p>
<p>存元素：多次调用add(Object)方法时，每次加入的对象按先来后到的顺序排序，也可以插队，即调用add(int index,Object)方法，就可以指定当前对象在集合中的存放位置。</p>
<p>取元素：方法1：Iterator接口取得所有，逐一遍历各个元素。</p>
<p>Map是双列的集合。</p>
<p>Map是双列的集合，存放用put方法:put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。</p>
<p>取元素：用get(Object key)方法根据key获得相应的value。也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获得key和value组合成的Map.Entry对象的集合。</p>
<p>注意：</p>
<p>HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65在hashSet中的存储顺序不是62,65,78，LinkedHashSet按插入的顺序存储。</p>
<p>那被存储对象的hashcode方法还有什么作用呢？hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。</p>
<p>同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。</p>
<p><strong>8.ArrayList**</strong>和<strong><strong>Vector</strong></strong>的区别。**   </p>
<p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，数据是允许重复的.</p>
<p>这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList与Vector的区别，这主要包括两个方面。</p>
<p>数据增长：</p>
<p>同步性：</p>
<p>ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次增加多个存储单元，增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。</p>
<p>Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。</p>
<p>Vector是线程安全的，而ArrayList是线程序不安全的</p>
<p>对于Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。</p>
<p><strong>9.**</strong>能创建<strong> </strong>volatile<strong> </strong>数组吗？**</p>
<p>可以，但是创建的对象或数组的地址具有可见性，里面的数据是不可见的。</p>
<p><strong>10.**</strong>去掉一个<strong><strong>Vector</strong></strong>集合中重复的元素。**   </p>
<p>方法一：HashSet set = new HashSet(vector);</p>
<p>方法二：</p>
<p>Vector newVector = new  Vector();<br> for (int i=0;i&lt;vector.size();i++)<br> {<br> Object obj = vector.get(i);<br>   if(!newVector.contains(obj); //不包含<br>     newVector.add(obj);<br> }</p>
<p><strong>11.**</strong>说出<strong><strong>ArrayList,Vector, LinkedList</strong></strong>的存储性能和特性。**   </p>
<p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>
<p>Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。</p>
<p>而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。</p>
<p><strong>12.Collection</strong> <strong>和</strong> <strong>Collections**</strong>的区别。**</p>
<p>Collection是集合类的上级接口，继..承于他的接口主要有Set 和List。</p>
<p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<p><strong>13.Set**</strong>里的元素是不能重复的，那么用什么方法来区分重复与否呢<strong>**?</strong> <strong>是用**</strong>==<strong><strong>还是</strong></strong>equals()?<strong> </strong>它们有何区别<strong>**?</strong></p>
<p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。</p>
<p>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</p>
<p>equals()和==方法决定引用值是否指向同一对象，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<p>14.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?  </p>
<p>对。</p>
<p>如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。</p>
<p>如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的。</p>
<p>例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。</p>
<p><strong>15.TreeSet**</strong>里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的<strong><strong>compareTo</strong></strong>方法，还是使用的子类的<strong><strong>compareTo</strong></strong>方法，还是抛异常！**   </p>
<p>当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的。</p>
<p>实验代码<br> public class Parent implements Comparable {<br>   private int age = 0;<br>   public Parent(int age){<br>     this.age = age;<br>   }<br>   public int compareTo(Object o) {<br>     System.out.println(“method of parent”);<br>     Parent o1 = (Parent)o;<br>     return age&gt;o1.age?1:age&lt;o1.age?-1:0;<br>   }<br> }<br> public class Child extends Parent {<br>   public Child(){<br>     super(3);<br>   }<br>   public int compareTo(Object o) {<br>       System.out.println(“method of child”);<br>       return 1;</p>
<p>}</p>
<p>}<br> public class TreeSetTest {<br>   public static void main(String[] args) {<br>     TreeSet set = new TreeSet();<br>     set.add(new Parent(3));<br>     set.add(new Child());<br>     set.add(new Parent(4));<br>     System.out.println(set.size());<br>   }<br> }</p>
<p><strong>16.**</strong>快速失败<strong><strong>(fail-.fast)</strong></strong>和安全失败<strong><strong>(fail-.safe)</strong></strong>的区别是什么？**</p>
<p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p>
<p>java.util 包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。</p>
<p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<p><strong>17.HashMap**</strong>和<strong><strong>Hashtable</strong></strong>的区别。**</p>
<p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。</p>
<p>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p>
<p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</p>
<p>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</p>
<p>最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p>
<p>Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p>
<p>就HashMap与Hashtable主要从三方面来说。</p>
<p>历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。</p>
<p>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。</p>
<p>值：只有HashMap可以让你将空值作为一个表的条目的key或value。</p>
<p><strong>18.HashMap**</strong>的数据结构。**</p>
<p>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）。</p>
<p>所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。</p>
<p>Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“）。</p>
<p><strong>19.HashMap**</strong>的工作原理是什么<strong>**?</strong></p>
<p>Java中的HashMap是以键值对(key-.value)的形式存储元素的。</p>
<p>HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。</p>
<p>当调用put() 方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。</p>
<p>如果key已经存在了，value会被更新成新值。</p>
<p>HashMap的一些重要的特性是它的容量 (capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<p><strong>20.HashMap**</strong>什么时候进行扩容呢？**</p>
<p>java 当HshMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75， 也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为2<em>16=32，即扩大一倍， 然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。 比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的， 因为0.75</em>1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>
<p><strong>21.HashSet**</strong>的底层实现是什么<strong>**?</strong></p>
<p>通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。</p>
<p>在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。</p>
<p><strong>22.CorrentHashMap**</strong>的工作原理<strong>**?</strong></p>
<p>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p>
<p><strong>23.LinkedHashMap**</strong>的实现原理<strong>**?</strong></p>
<p>LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。</p>
<p>LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</p>
<p>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。</p>
<p>一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<p><strong>24.**</strong>数组<strong><strong>(Array)</strong></strong>和列表<strong><strong>(ArrayList)</strong></strong>有什么区别？什么时候应该使用<strong><strong>Array</strong></strong>而不是<strong> </strong>ArrayList<strong>**？</strong></p>
<p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p>
<p>Array大小是固定的，ArrayList的大小是动态变化的。</p>
<p>ArrayList处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<p><strong>25.Java**</strong>集合类框架的最佳实践有哪些？**</p>
<p>假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。</p>
<p>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。</p>
<p>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。</p>
<p>使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现 hashCode()和equals()方法。</p>
<p>编程的时候接口优于实现。</p>
<p>底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。</p>
<p><strong>26.**</strong>为什么集合类没有实现<strong><strong>Cloneable</strong></strong>和<strong><strong>Serializable</strong></strong>接口？**</p>
<p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。</p>
<p>因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。</p>
<p><strong>28.Iterator**</strong>和<strong><strong>ListIterator</strong></strong>的区别是什么？**</p>
<p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</p>
<p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p>
<p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<p><strong>2**</strong>）<strong><strong>HashMap</strong></strong>的底层实现，之后会问<strong><strong>ConcurrentHashMap</strong></strong>的底层实现**</p>
<p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。允许使用null值和null键。</p>
<p>ConcurrentHashMap基于双数组和链表的Map接口的同步实现<br> ConcurrentHashMap中元素的key是唯一的、value值可重复<br> ConcurrentHashMap不允许使用null值和null键<br> ConcurrentHashMap是无序的</p>
<p>为什么使用ConcurrentHashMap：<br> 我们都知道HashMap是非线程安全的，当我们只有一个线程在使用HashMap的时候，自然不会有问题，但如果涉及到多个线程，并且有读有写的过程中，HashMap就会fail-fast。要解决HashMap同步的问题，我们的解决方案有:Hashtable 、Collections.synchronizedMap(hashMap)<br> 这两种方式基本都是对整个hash表结构加上同步锁，这样在锁表的期间，别的线程就需要等待了，无疑性能不高，所以我们引入ConcurrentHashMap，既能同步又能多线程访问<br> ConcurrentHashMap的数据结构：<br> ConcurrentHashMap的数据结构为一个Segment数组，Segment的数据结构为HashEntry的数组，而HashEntry存的是我们的键值对，可以构成链表。可以简单的理解为数组里装的是HashMap</p>
<p><strong>6**</strong>）<strong><strong>wait</strong></strong>和<strong><strong>sleep</strong></strong>的区别，必须理解**</p>
<p>sleep方法属于线程，wait方法属于对象<br> sleep休眠当前线程，不会释放对象锁，wait使当前线程进入等待状态，释放对象锁，只有针对此对象调用notify()方法（且共享对象资源释放）后本线程才会继续执行</p>
<p><strong>7**</strong>）<strong><strong>JVM</strong></strong>的内存结构，<strong><strong>JVM</strong></strong>的算法**</p>
<p>JVM内存结构主要有三大块：堆内存、方法区和栈，几乎所有的对象实例都存放在堆里，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。<br> 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br> 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<br> 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</p>
<p><strong>15**</strong>）说说<strong><strong>http,https</strong></strong>协议**</p>
<p>http是一种超文本协议，默认端口80，以明文传输。<br> https是http协议的安全版，安全基础是SSL，以密文传输</p>
<p><strong>16**</strong>）<strong><strong>osi</strong></strong>五层网络协议**</p>
<p>应用层、传输层、网络层、数据链路层、物理层</p>
<p><strong>18**</strong>）说说<strong><strong>tcp</strong></strong>三次握手，四次挥手**</p>
<p>1.客户端向服务器发送一个syn包，进入发送状态<br> 2.服务器收到syn包，确认客户的syn，并向客户端发送syn+ack包，进入接受状态<br> 3.客户端接受的来自服务的的syn包信息，向服务的发出ack包，次数两者进入tcp连接成功状态</p>
<p><strong>21**</strong>）请写一段栈溢出、堆溢出的代码**</p>
<p>堆溢出，死循环存值，JVM就会抛出OutOfMemoryError:java heap space异常</p>
<p>  public static void main(String[] args) {<br>     List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();<br>     int i=0;<br>     while(true){<br>       list.add(new byte[5<em>1024</em>1024]);<br>       System.out.println(“分配次数：”+(++i));<br>     }<br>   }</p>
<p>栈溢出，栈空间不足——StackOverflowError实例</p>
<p>  public class StackSOFTest {<br>     int depth = 0;<br>     public void sofMethod(){<br>       depth ++ ;<br>       sofMethod();<br>     }<br>     public static void main(String[] args) {<br>       StackSOFTest test = null;<br>       try {<br>         test = new StackSOFTest();<br>         test.sofMethod();<br>       } finally {<br>         System.out.println(“递归次数：”+test.depth);<br>       }<br>     }<br>   }</p>
<p><strong>29.**</strong>说出一些常用的类，包，接口，请各举<strong><strong>5</strong></strong>个。**   </p>
<p>注意：要让人家感觉你对java ee开发很熟，java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。</p>
<p>常用的类：</p>
<p>BufferedReader</p>
<p>BufferedWriter</p>
<p>FileReader</p>
<p>FileWirter</p>
<p>String</p>
<p>Integer</p>
<p>java.util.Date</p>
<p>System</p>
<p>Class</p>
<p>List</p>
<p>HashMap</p>
<p>常用的包：</p>
<p>java.lang</p>
<p>java.io</p>
<p>java.util</p>
<p>java.sql</p>
<p>javax.servlet</p>
<p>org.apache.strtuts.action</p>
<p>org.hibernate</p>
<p>常用的接口：</p>
<p>Remote</p>
<p>List</p>
<p>Map</p>
<p>Document</p>
<p>NodeList</p>
<p>Servlet</p>
<p>HttpServletRequest</p>
<p>HttpServletResponse</p>
<p>Transaction(Hibernate)</p>
<p>Session(Hibernate)</p>
<p>HttpSession</p>
<p><strong>30.java**</strong>中有几种类型的流？<strong><strong>JDK</strong></strong>为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？**</p>
<p>字节流，字符流。</p>
<p>字节流继承于InputStream OutputStream。</p>
<p>OutputStream提供的方法：</p>
<p>void write(int b):写入一个字节的数据。</p>
<p>void write(byte[] buffer):将数组buffer的数据写入流。</p>
<p>void write(byte[] buffer,int offset,int len):从buffer[offset]开始，写入len个字节的数据。</p>
<p>void flush():强制将buffer内的数据写入流。</p>
<p>void close():关闭流。</p>
<p>InputStream提供的方法：</p>
<p>int read():读出一个字节的数据，如果已达文件的末端，返回值为－1。</p>
<p>int read(byte[] buffer):读出buffer大小的数据，返回值为实际所读出的字节数。</p>
<p>int read(byte[] buffer,int offset,int len)。</p>
<p>int available():返回流内可供读取的字节数目。</p>
<p>long skip(long n):跳过n个字节的数据，返回值为实际所跳过的数据数。</p>
<p>void close():关闭流。</p>
<p>字符流继承于InputStreamReader OutputStreamWriter。</p>
<p>在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<p><strong>31.**</strong>字节流与字符流的区别。**</p>
<p>IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>计算机中的一切最终都是二进制的字节形式存在，对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，java提供了字符流的包装类。</p>
<p>底层设备永远只接受字节数据， </p>
<p><strong>32.**</strong>什么是<strong><strong>java</strong></strong>序列化，如何实现<strong><strong>java</strong></strong>序列化？或者请解释<strong><strong>Serializable</strong></strong>接口的作用。**</p>
<p>有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，（例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输），但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。</p>
<p>需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。</p>
<p>例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。</p>
<p><strong>33.**</strong>描述一下<strong><strong>JVM</strong></strong>加载<strong><strong>class</strong></strong>文件的原理机制<strong>**?</strong>   </p>
<p>Java语言是一种具有动态性的解释型语言，类（class）只有被加载到JVM后才能运行。当运行指定程序时，JVM会将编译生成的.class文件按照需求和一定的规则加载到内存中，并组织成为一个完整的Java应用程序，这个加载过程是由类加载器完成。</p>
<p>具体来说，就是由ClassLoader和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。</p>
<p>类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用new等方式创建对象时，会隐式地调用类的加载器把对应的类加载到JVM中。显示加载指的是通过直接调用class.forName()方法来把所需的类加载到JVM中。</p>
<p>任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到JVM中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。</p>
<p>此外，在Java语言中，每个类或接口都对应一个.class文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。</p>
<p>在Java语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到JVM中，至于其他类，则在需要的时候才加载：下面是加载的步骤：</p>
<p>初始化。对静态变量和静态代码块执行初始化工作。</p>
<p>装载。根据查找路径找到相应的class文件，然后导入。</p>
<p>链接。链接又可分为3个小步：</p>
<p>检查，检查待加载的class文件的正确性。</p>
<p>准备，给类中的静态变量分配存储空间。</p>
<p>解析，将符号引用转换为直接引用（这一步可选）。</p>
<p>方法中的局部变量使用final修饰后，放在堆中，而不是栈</p>
<p><strong>35.**</strong>堆和栈的区别，有一个<strong><strong>64k</strong></strong>的字符串，是放到堆上，还是放到栈上，为什么？**</p>
<p>堆栈都是内存的可用区域，但是堆的速度慢容量大，栈的速度快容量小。一个64K的字符串，自然放在堆。栈的内存是很宝贵的。</p>
<p>只有<strong>引用及基本数据类型</strong>是直接存在栈上。<strong>对象类型</strong>可能是在堆、方法区、常量池中；放到堆中还是放到栈中，jvm会根据你的数据类型决定。</p>
<p>栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>堆区（heap） ：一般由程序员分配释放， 若程序员不释放，程序结束时可能由GC回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
<p><strong>36.GC**</strong>是什么<strong>**?</strong> <strong>为什么要有**</strong>GC?**</p>
<p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃。</p>
<p>Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p>
<p><strong>37.**</strong>垃圾回收的优点和原理。并考虑<strong><strong>2</strong></strong>种回收机制。**</p>
<p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。</p>
<p><strong>优点：</strong></p>
<p>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。</p>
<p>垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不用实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p>
<p>回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p>
<p><strong>38.**</strong>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**   </p>
<p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>不过垃圾回收机制的回收是不确定的，不一定会马上回收内存。</p>
<p>可以主动通知虚拟机进行垃圾回收：程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。实际上GC是一个守护线程(守护线程的作用是为其他线程提供服务)。</p>
<p><strong>39.**</strong>什么时候用<strong><strong>assert</strong></strong>？**  </p>
<p>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<p>在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。</p>
<p>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。</p>
<p>public class AssertTest {<br> public static void main(String[] args) {<br>   int i = 0;<br>   for(i=0;i&lt;5;i++)<br>   {<br>     System.out.println(i);<br>   }<br>   //假设程序不小心多了一句–i;<br>   –i;<br>   assert i==5;<br>  }<br> }</p>
<p><strong>40.java**</strong>中会存在内存泄漏吗，请简单描述。**   </p>
<p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。</p>
<p>由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：</p>
<p>java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景(通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的）。</p>
<p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p>
<p>检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。</p>
<p>内存泄露的另外一种情况：当一个对象<strong>被存储进**</strong>HashSet<strong>**集合</strong>中以后，就<strong>不能修改</strong>这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。</p>
<p>java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</p>
<p><strong>41.**</strong>能不能自己写个类，也叫<strong><strong>java.lang.String</strong></strong>？**</p>
<p>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。</p>
<p>但是在实际应用中，这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。</p>
<p>虽然java提供了endorsed技术，可以覆盖jdk中的某些类。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类。</p>
<p>package java.lang;<br> public class String {<br>   public static void main(String[] args) {<br>     System.out.println(“string”);<br>   }<br> }<br> 报告的错误如下：<br> java.lang.NoSuchMethodError: main<br> Exception in thread “main”<br> 这是因为加载了jre自带的java.lang.String，而该类中没有main方法。</p>
<p><strong>194.</strong>说一下 jvm 的主要组成部分？及其作用？</p>
<p>类加载器（ClassLoader）<br> 运行时数据区（Runtime Data Area）<br> 执行引擎（Execution Engine）<br> 本地库接口（Native Interface）</p>
<p>组件的作用: 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。<br> <strong>195.</strong> 说一下 jvm 运行时数据区？</p>
<p>程序计数器<br> 虚拟机栈<br> 本地方法栈<br> 堆<br> 方法区</p>
<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>
<p>196.说一下堆栈的区别？</p>
<p>栈内存存储的是局部变量而堆内存存储的是实体；</p>
<p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>
<p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>
<p>197.队列和栈是什么？有什么区别？</p>
<p>队列和栈都是被用来预存储数据的。<br> 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br> 栈和队列很相似，但它运行对元素进行后进先出进行检索。<br> 198.什么是双亲委派模型？</p>
<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br> 其他类加载器：<br> 扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=“box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;”&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt;<br> 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br> \199. 说一下类加载的执行过程？</p>
<p>类加载分为以下 5 个步骤：</p>
<p>加载：根据查找路径找到相应的 class 文件然后导入；<br> 检查：检查加载的 class 文件的正确性；<br> 准备：给类中的静态变量分配内存空间；<br> 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br> 初始化：对静态变量和静态代码块执行初始化工作。<br> 200.怎么判断对象是否可以被回收？</p>
<p>一般有两种方法来判断：</p>
<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br> 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。<br> <strong>201. java</strong> <strong>中都有哪些引用类型？</strong></p>
<p>强引用<br> 软引用<br> 弱引用<br> 虚引用<br> <strong>202.</strong> <strong>说一下 jvm 有哪些垃圾回收算法？</strong></p>
<p>标记-清除算法<br> 标记-整理算法<br> 复制算法<br> 分代算法<br> <strong>203.**</strong>说一下 jvm 有哪些垃圾回收器？**</p>
<p>Serial：最早的单线程串行垃圾回收器。<br> Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br> ParNew：是 Serial 的多线程版本。<br> Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br> Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br> CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br> G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。<br> <strong>204.**</strong>详细介绍一下 CMS 垃圾回收器？**</p>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。<br> <strong>205.**</strong>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？**</p>
<p>新生代回收器：Serial、ParNew、Parallel Scavenge<br> 老年代回收器：Serial Old、Parallel Old、CMS<br> 整堆回收器：G1</p>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。<br> <strong>206.</strong> <strong>简述分代垃圾回收器是怎么工作的？</strong></p>
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br> 清空 Eden 和 From Survivor 分区；<br> From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。<br> <strong>207.**</strong>说一下 jvm 调优的工具？**</p>
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br> jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。<br> \208. 常用的 jvm 调优的参数都有哪些？</p>
<p>-Xms2g：初始化推大小为 2g；<br> -Xmx2g：堆最大内存为 2g；<br> -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br> -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br> –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br> -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br> -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br> -XX:+PrintGC：开启打印 gc 信息；<br> -XX:+PrintGCDetails：打印 gc 详细信息。</p>
<p><strong>2.**</strong>你所知道网络协议有那些？**</p>
<p>HTTP：超文本传输协议</p>
<p>FTP：文件传输协议</p>
<p>SMPT：简单邮件协议</p>
<p>TELNET：远程终端协议</p>
<p>POP3：邮件读取协议</p>
<p><strong>3.Java**</strong>都有那些开发平台？**</p>
<p>JAVA SE：主要用在客户端开发</p>
<p>JAVA EE：主要用在web应用程序开发</p>
<p>JAVA ME：主要用在嵌入式应用程序开发</p>
<p><strong>4.**</strong>什么是JVM？java虚拟机包括什么？**</p>
<p>JVM：java虚拟机，运用硬件或软件手段实现的虚拟的计算机，Java虚拟机包括：寄存器，堆栈，处理器</p>
<p><strong>5.Java**</strong>是否需要开发人员回收内存垃圾吗？**</p>
<p>大多情况下是不需要的。Java提供了一个系统级的线程来跟踪内存分配，不再使用的内存区将会自动回收</p>
<p><strong>7.**</strong>什么是数据结构？**</p>
<p>计算机保存，组织数据的方式</p>
<p><strong>8.Java**</strong>的数据结构有那些？**</p>
<p>线性表（ArrayList）</p>
<p>链表（LinkedList）</p>
<p>栈（Stack）</p>
<p>队列（Queue）</p>
<p>图（Map）</p>
<p>树（Tree）</p>
<p><strong>9.**</strong>什么是OOP?**</p>
<p>面向对象编程</p>
<p><strong>10.**</strong>什么是面向对象？**</p>
<p>世间万物都可以看成一个对象。每个物体包括动态的行为和静态的属性，这些就构成了一个对象。</p>
<p><strong>11.**</strong>类与对象的关系?**</p>
<p>类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例</p>
<p><strong>12.Java**</strong>中有几种数据类型**</p>
<p>整形：byte,short,int,long</p>
<p>浮点型：float,double</p>
<p>字符型：char</p>
<p>布尔型：boolean</p>
<p><strong>13.**</strong>什么是隐式转换，什么是显式转换**</p>
<p>显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。</p>
<p><strong>14.Char**</strong>类型能不能转成int类型？能不能转化成string类型，能不能转成double类型**</p>
<p>Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；Char&lt;int&lt;long&lt;float&lt;double；Char类型可以隐式转成int,double类型，但是不能隐式转换成string；如果char类型转成byte，short类型的时候，需要强转。</p>
<p><strong>15.**</strong>什么是拆装箱？**</p>
<p>拆箱：把包装类型转成基本数据类型</p>
<p>装箱：把基本数据类型转成包装类型</p>
<p><strong>16.Java**</strong>中的包装类都是那些？**</p>
<p>byte：Byte </p>
<p>short：Short </p>
<p>int：Integer </p>
<p>long：Long </p>
<p>float：Float </p>
<p>double：Double </p>
<p>char：Character </p>
<p>boolean：Boolean</p>
<p><strong>17.**</strong>一个java类中包含那些内容？**</p>
<p>属性、方法、内部类、构造方法、代码块。</p>
<p><strong>18.**</strong>例如： if(a+1.0=4.0)，这样做好吗？**</p>
<p>不好，因为计算机在浮点型数据运算的时候，会有<strong>误差</strong>，尽量在布尔表达式中不使用浮点型数据(if,while,switch中判断条件不使用浮点型)</p>
<p><strong>19.**</strong>那针对浮点型数据运算出现的误差的问题，你怎么解决？**</p>
<p>使用Bigdecimal类进行浮点型数据的运算</p>
<p><strong>20.++i**</strong>与i++的区别**</p>
<p>++i：先赋值，后计算</p>
<p>i++：先计算，后赋值</p>
<p><strong>21.**</strong>程序的结构有那些？**</p>
<p>顺序结构</p>
<p>选择结构</p>
<p>循环结构</p>
<p><strong>22.**</strong>数组实例化有几种方式？**</p>
<p>静态实例化：创建数组的时候已经指定数组中的元素,</p>
<p>int[] a=new int[]{1,3,3}</p>
<p>动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值</p>
<p><strong>23.Java**</strong>中各种数据默认值**</p>
<p>Byte,short,int,long默认是都是0</p>
<p>Boolean默认值是false</p>
<p>Char类型的默认值是’’</p>
<p>Float与double类型的默认是0.0</p>
<p>对象类型的默认值是null</p>
<p><strong>24.Java**</strong>常用包有那些？**</p>
<p>Java.lang</p>
<p>Java.io</p>
<p>Java.sql</p>
<p>Java.util</p>
<p>Java.awt</p>
<p>Java.net</p>
<p>Java.math</p>
<p><strong>25.Java**</strong>最顶级的父类是哪个？**</p>
<p>Object</p>
<p><strong>26.Object**</strong>类常用方法有那些？**</p>
<p>Equals</p>
<p>Hashcode</p>
<p>toString</p>
<p>wait</p>
<p>notify</p>
<p>clone</p>
<p><em>getClass</em></p>
<p><strong>28.java**</strong>中是值传递引用传递？**</p>
<p>理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。</p>
<p><strong>29.**</strong>假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？**</p>
<p>改变了，因为传递是对象的引用，操作的是引用所指向的对象</p>
<p><strong>30.**</strong>实例化数组后，能不能改变数组长度呢？**</p>
<p>不能，数组一旦实例化，它的长度就是固定的</p>
<p><strong>31.**</strong>假设数组内有5个元素，如果对数组进行反序，该如何做？**</p>
<p>创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中</p>
<p><strong>32.**</strong>形参与实参**</p>
<p>形参：全称为“形式参数”，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值；</p>
<p>实参：全称为“实际参数”，是在调用方法时传递给该方法的实际值。</p>
<p><strong>33.**</strong>构造方法能不能显式调用？**</p>
<p>不能 构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用</p>
<p><strong>36.**</strong>内部类与静态内部类的区别？**</p>
<p>静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法；</p>
<p>普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。</p>
<p>如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象</p>
<p><strong>37.Static**</strong>关键字有什么作用？**</p>
<p>Static可以修饰内部类、方法、变量、代码块</p>
<p>Static修饰的类是静态内部类</p>
<p>Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。</p>
<p>Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。</p>
<p>Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。</p>
<p><strong>38.Final**</strong>在java中的作用**</p>
<p>Final可以修饰类，修饰方法，修饰变量。</p>
<p>修饰的类叫最终类。该类不能被继承。</p>
<p>修饰的方法不能被重写。</p>
<p>修饰的变量叫常量，常量必须初始化，一旦初始化后，常量的值不能发生改变。</p>
<p><strong>39.Java**</strong>中操作字符串使用哪个类？**</p>
<p>String，StringBuffer，StringBuilder</p>
<p><strong>42.String str=”aa”,String s=”bb”,String aa=aa+s;**</strong>一种创建了几个对象？**</p>
<p>一共有两个引用，三个对象。因为”aa”与”bb”都是常量，常量的值不能改变，当执行字符串拼接时候，<em>会创建一个新的常量是” aabbb”,有将其存到常量池中。</em></p>
<p><strong>43.**</strong>将下java中的math类有那些常用方法？**</p>
<p>Pow()：幂运算</p>
<p>Sqrt()：平方根</p>
<p>Round()：四舍五入</p>
<p>Abs()：求绝对值</p>
<p>Random()：生成一个0-1的随机数，包括0不包括1</p>
<p><strong>46.==**</strong>与equlas有什么区别？**</p>
<p>==可以判断基本数据类型值是否相等，也可以判断两个对象指向的内存地址是否相同，也就是说判断两个对象是否是同一个对象，Equlas通常用来做字符串比较。</p>
<p><strong>53.**</strong>创建一个子类对象的时候，那么父类的构造方法会执行吗？**</p>
<p>会执行。当创建一个子类对象，调用子类构造方法的时候，子类构造方法会默认调用父类的构造方法。</p>
<p><strong>54.**</strong>什么是父类引用指向子类对象？**</p>
<p>是java多态一种特殊的表现形式。创建父类引用，让该引用指向一个子类的对象</p>
<p><strong>55.**</strong>当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？**</p>
<p>子类重写了父类方法和属性，访问的是父类的属性，调用的是子类的方法</p>
<p><strong>60.**</strong>抽象类可以使用final修饰吗？**</p>
<p>不可以。定义抽象类就是让其他继承的，而final修饰类表示该类不能被继承，与抽象类的理念违背了</p>
<p><strong>61.**</strong>普通类与抽象类有什么区别？**</p>
<p>普通类不能包含抽象方法，抽象类可以包含抽象方法</p>
<p>抽象类不能直接实例化，普通类可以直接实例化</p>
<p><strong>63.JAVA**</strong>为什么需要接口？**</p>
<p>接口弥补了java单继承的缺点</p>
<p><strong>64.**</strong>接口有什么特点？**</p>
<p>接口中声明全是public static final修饰的常量</p>
<p>接口中所有方法都是抽象方法</p>
<p>接口是没有构造方法的</p>
<p>接口也不能直接实例化</p>
<p>接口可以多继承</p>
<p><strong>66.Java**</strong>中异常分为哪两种？**</p>
<p>编译时异常</p>
<p>运行时异常</p>
<p><strong>67.**</strong>说几个常见的编译时异常类？**</p>
<p>NullPointerException：空指针异常</p>
<p>ArrayIndexOutOfBoundsException：数组下标越界</p>
<p>NumberFormatException：数字转换异常</p>
<p>IllegalArgumentException：参数不匹配异常</p>
<p>InstantiationException：对象初始化异常</p>
<p>ArithmeticException：算术异常</p>
<p><strong>68.**</strong>异常的处理机制有几种？**</p>
<p>异常捕捉：try…catch…finally，异常抛出：throws。</p>
<p><strong>69.**</strong>如何自定义一个异常**</p>
<p>继承一个异常类，通常是RumtimeException或者Exception</p>
<p><strong>70.**</strong>在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？**</p>
<p>会执行，如果有finally，在finally之后被执行，如果没有finally，在catch之后被执行</p>
<p><strong>72.Thow**</strong>与thorws区别**</p>
<p>Throw写在代码块内，throws后面跟的是一个具体的异常实例</p>
<p>Throw写在方法前面后面，throws后面跟的是异常类，异常类可以出现多个</p>
<p><strong>74.**</strong>使用Log4j对程序有影响吗？**</p>
<p>有，log4j是用来日志记录的，记录一些关键敏感的信息，通常会将日志记录到本地文件或者数据库中。记录在本地文件中，会有频繁的io操作，会耗费一些系统资源。记录在数据库中，会频繁地操作数据库表，对系统性能也有一定的影响。但是为了程序安全以及数据的恢复或者bug的跟踪，这点资源消耗是可以承受的。</p>
<p><strong>75.Log4j**</strong>日志有几个级别？**</p>
<p>由低到高：debug、info、wran、error</p>
<p><strong>77.Java**</strong>反射创建对象效率高还是通过new创建对象的效率高？**</p>
<p>通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低</p>
<p><strong>79.Collection**</strong>接口下有那些集合框架？**</p>
<p>List：线性表、Set：无序集合。</p>
<p><strong>85.JDBC**</strong>操作的步骤**</p>
<p>加载数据库驱动类</p>
<p>打开数据库连接</p>
<p>执行sql语句</p>
<p>处理返回结果</p>
<p>关闭资源</p>
<p><strong>86.**</strong>在使用jdbc的时候，如何防止出现sql注入的问题。**</p>
<p>使用PreparedStatement类，而不是使用Statement类</p>
<p><strong>87.**</strong>怎么在JDBC内调用一个存储过程**</p>
<p>使用CallableStatement</p>
<p><strong>88.**</strong>是否了解连接池，使用连接池有什么好处？**</p>
<p>数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。</p>
<p><strong>89.**</strong>你所了解的数据源技术有那些？使用数据源有什么好处？**</p>
<p>Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全；通过配置文件的形式来维护数据库信息，而不是通过硬编码。当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据库信息的更新。</p>
<p><strong>91.**</strong>常用io类有那些？**</p>
<p>File</p>
<p>FileInputSteam，FileOutputStream</p>
<p>BufferInputStream，BufferedOutputSream</p>
<p>Print Write</p>
<p>FileReader，FileWriter</p>
<p>BufferReader，BufferedWriter</p>
<p>ObjectInputStream，ObjectOutputSream</p>
<p><strong>92.**</strong>字节流与字符流的区别**</p>
<p>以字节为单位输入输出数据，字节流按照8位传输</p>
<p>以字符为单位输入输出数据，字符流按照16位传输</p>
<p><strong>93.final**</strong>、finalize()、finally**</p>
<p>性质不同</p>
<p>final为关键字；</p>
<p>finalize()为方法；</p>
<p>finally为区块标志，用于try语句中；</p>
<p>作用</p>
<p>final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；</p>
<p>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；</p>
<p>finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行；</p>
<p><strong>99.**</strong>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？**</p>
<p>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p>
<p>3、什么是单例模式？实现步骤？</p>
<p>单例模式保证了对象唯一。分为懒汉式（在类加载时不初始化）和饿汉式（在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快）。</p>
<p>实现步骤：私有化构造函数、创建一个静态的私有对象、提供公共的访问方法。</p>
<p>10、什么是 ThreadLocal？ThreadLocal 和 Synchonized 的区别？</p>
<p>线程局部变量。是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。</p>
<p>synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而 ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</p>

      
    </div>

    

    
    
    
	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #fc6423;font-size:16px;">---本文结束<i class="fa fa-heart"></i>感谢您的阅读!---</div>
    
</div>
  
</div>

<div>
     
       
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2020/06/14/面试-Java基础/">面试_Java基础</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 周宏伟 的个人博客">周宏伟</a></p>
  <p><span>发布时间:</span>2020年06月14日 - 11:06</p>
  <p><span>最后更新:</span>2020年06月14日 - 11:06</p>
  <p><span>原始链接:</span><a href="/2020/06/14/面试-Java基础/" title="面试_Java基础">http://oldzhoua.github.io/2020/06/14/面试-Java基础/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://oldzhoua.github.io/2020/06/14/面试-Java基础/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>

     
     </div>



    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
            <a href="/tags/Java基础/" rel="tag"># Java基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/12/Java高级-注解/" rel="next" title="Java高级_注解">
                <i class="fa fa-chevron-left"></i> Java高级_注解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="周宏伟">
            
              <p class="site-author-name" itemprop="name">周宏伟</p>
              <div class="site-description motion-element" itemprop="description">我喜欢的都很贵，所以我才要努力争取</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29sZHpob3VhL29sZHpob3VhLmdpdGh1Yi5pby5naXQ=" title="GitHub &rarr; https://github.com/oldzhoua/oldzhoua.github.io.git"><i class="fa fa-fw fa-github"></i>GitHub</span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="bWFpbHRvOm9sZHpob3VhQDE2My5jb20=" title="E-Mail &rarr; mailto:oldzhoua@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29sZHpob3VhL29sZHpob3VhLmdpdGh1Yi5pby5naXQ=" title="https://github.com/oldzhoua/oldzhoua.github.io.git">github的文章</span>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周宏伟</span>
  
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">111k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">1:41</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  



  
    
    
      
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js"></script>











  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/jquery_lazyload@1.9.3/jquery.lazyload.min.js"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="//cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/js/jquery.fancybox.pack.js"></script>

  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1.1/reading_progress.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  
  <script src="/js/js.cookie.js?v=7.1.0"></script>
  <script src="/js/scroll-cookie.js?v=7.1.0"></script>


  
  <script src="/js/exturl.js?v=7.1.0"></script>


  
  
  
    
  

  

  
  
  


  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  
  
  
    
  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1.0.0/bookmark.min.js"></script>
  <script>
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  

  

  

</body>
</html>
