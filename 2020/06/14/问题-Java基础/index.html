<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/blue/pace-theme-minimal.css">



  
  
    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css">



  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">











  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/css/jquery.fancybox.min.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="乱七八糟1.JDK 和 JRE 有什么区别？JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 ja">
<meta name="keywords" content="问题,Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="问题_Java基础">
<meta property="og:url" content="http://oldzhoua.github.io/2020/06/14/问题-Java基础/index.html">
<meta property="og:site_name" content="周宏伟的个人博客">
<meta property="og:description" content="乱七八糟1.JDK 和 JRE 有什么区别？JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 ja">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-14T10:50:31.205Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="问题_Java基础">
<meta name="twitter:description" content="乱七八糟1.JDK 和 JRE 有什么区别？JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 ja">





  
  
  <link rel="canonical" href="http://oldzhoua.github.io/2020/06/14/问题-Java基础/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>问题_Java基础 | 周宏伟的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">周宏伟的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-java">

    
    
    
      
    

    
      
    

    <a href="/categories/java/" rel="section"><i class="menu-item-icon fa fa-fw fa-paper-plane"></i> <br>java</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-javaweb">

    
    
    
      
    

    
      
    

    <a href="/categories/javaweb/" rel="section"><i class="menu-item-icon fa fa-fw fa-cloud"></i> <br>javaweb</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-mybatis">

    
    
    
      
    

    
      
    

    <a href="/categories/mybatis/" rel="section"><i class="menu-item-icon fa fa-fw fa-medium"></i> <br>mybatis</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-spring">

    
    
    
      
    

    
      
    

    <a href="/categories/spring/" rel="section"><i class="menu-item-icon fa fa-fw fa-strikethrough"></i> <br>spring</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-springmvc">

    
    
    
      
    

    
      
    

    <a href="/categories/springmvc/" rel="section"><i class="menu-item-icon fa fa-fw fa-stumbleupon"></i> <br>springmvc</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-springboot2">

    
    
    
      
    

    
      
    

    <a href="/categories/springboot2/" rel="section"><i class="menu-item-icon fa fa-fw fa-bold"></i> <br>springboot2</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-springcloud">

    
    
    
      
    

    
      
    

    <a href="/categories/springcloud/" rel="section"><i class="menu-item-icon fa fa-fw fa-cloud"></i> <br>springcloud</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-其他技术">

    
    
    
      
    

    
      
    

    <a href="/categories/其他技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-strikethrough"></i> <br>其他技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-问题">

    
    
    
      
    

    
      
    

    <a href="/categories/问题/" rel="section"><i class="menu-item-icon fa fa-fw fa-question"></i> <br>问题</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">25</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">12</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">22</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
   
 </header>
    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oldzhoua.github.io/2020/06/14/问题-Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周宏伟">
      <meta itemprop="description" content="我喜欢的都很贵，所以我才要努力争取">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周宏伟的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">问题_Java基础

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-14 11:02:05 / 修改时间：18:50:31" itemprop="dateCreated datePublished" datetime="2020-06-14T11:02:05+08:00">2020-06-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/问题/" itemprop="url" rel="index"><span itemprop="name">问题</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">45k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">41 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h2 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h2><h3 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h3><p>JDK：<strong>Java Development Kit</strong> 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</p>
<p>JRE：<strong>Java Runtime Environment</strong> 的简称，java 运行环境，为 java 的运行提供了所需环境。</p>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：<strong>如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK</strong>。</p>
  <a id="more"></a>
<h3 id="2-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#2-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="2.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？"></a>2.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h3><blockquote>
<p>解答: </p>
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。(两本书有着同样的书名和作者，但是它们是两本“不同”的书。)</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
</blockquote>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><blockquote>
<p>equals()方法是用来判断其他的对象是否和该对象相等，它的性质有：</p>
</blockquote>
<p><strong>自反性（reflexive）</strong>。对于任意不为null的引用值x，x.equals(x)一定是true。</p>
<p><strong>对称性（symmetric）</strong>。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。</p>
<p><strong>传递性（transitive）</strong>。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。</p>
<p><strong>一致性（consistent）</strong>。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。</p>
<p>对于任意不为null的引用值x，x.equals(null)返回false。</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><blockquote>
<p>hashCode()方法给对象返回一个hash code值。这个方法被用于HashTable，HashMap。</p>
</blockquote>
<p>它的性质是：</p>
<p>在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。</p>
<p>如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。</p>
<p>并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。</p>
<p>大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。</p>
<p><strong>在每个改写了equals()方法的类中，必须要改写hashCode()方法。如果不这样做，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于hash的集合类结合在一起正常运作，这样的集合类包括HashMap、HashSet和HashTable。</strong></p>
<blockquote>
<p>需要注意的是: 这个hashCode()方法是合法的，因为相等的对象总是具有同样的散列码.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="number">0</span>;  &#125;</span><br></pre></td></tr></table></figure>
<p>但是它使得每一个对象都具有同样的散列码。因此，每个对象都被映射到同一个散列桶中，从而散列表被退化为链表。对于规模很大的散列表而言，这关系到散列表能否正常工作。</p>
<p>一个好的散列函数通常倾向于“7为不相等的对象产生不相等的散列码”。</p>
<p>如果一个类是非可变的，并且计算散列码的代价也比较大，那么你应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。</p>
<p>不要试图从散列码计算中排除掉一个对象的关键部分以提高性能</p>
<h3 id="3-final-在-java-中有什么作用？"><a href="#3-final-在-java-中有什么作用？" class="headerlink" title="3.final 在 java 中有什么作用？"></a>3.final 在 java 中有什么作用？</h3><blockquote>
<p>final 修饰的类叫最终类，该类不能被继承。</p>
<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<p>final 修饰的方法不能被重写。</p>
</blockquote>
<h3 id="4-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#4-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="4.String str=”i”与 String str=new String(“i”)一样吗？"></a>4.String str=”i”与 String str=new String(“i”)一样吗？</h3><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，(JVM java va)java 虚拟机会将其分配到常量池-&gt;方法区中；</p>
<p>而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h3 id="5-如何将字符串反转？"><a href="#5-如何将字符串反转？" class="headerlink" title="5.如何将字符串反转？"></a>5.如何将字符串反转？</h3><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<h3 id="6-String-类的常用方法都有那些？"><a href="#6-String-类的常用方法都有那些？" class="headerlink" title="6.String 类的常用方法都有那些？"></a>6.String 类的常用方法都有那些？</h3><p>indexOf()：返回指定字符的索引。</p>
<p>charAt()：返回指定索引处的字符。</p>
<p>replace()：字符串替换。</p>
<p>trim()：去除字符串两端空白。</p>
<p>split()：分割字符串，返回一个分割后的字符串数组。</p>
<p>getBytes()：返回字符串的 byte 类型数组。</p>
<p>length()：返回字符串长度。</p>
<p>toLowerCase()：将字符串转成小写字母。</p>
<p>toUpperCase()：将字符串转成大写字符。</p>
<p>substring()：截取字符串。</p>
<p>equals()：字符串比较。</p>
<h3 id="7-抽象类必须要有抽象方法吗？"><a href="#7-抽象类必须要有抽象方法吗？" class="headerlink" title="7.抽象类必须要有抽象方法吗？"></a>7.抽象类必须要有抽象方法吗？</h3><blockquote>
<p>不需要，抽象类不一定非要有抽象方法。</p>
</blockquote>
<p>在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧</p>
<h3 id="8-普通类和抽象类有哪些区别？"><a href="#8-普通类和抽象类有哪些区别？" class="headerlink" title="8.普通类和抽象类有哪些区别？"></a>8.普通类和抽象类有哪些区别？</h3><ol>
<li><p>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
</li>
<li><p>抽象类不能用来创建对象；</p>
</li>
<li><p>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
</li>
<li><p>在其他方面，抽象类和普通的类并没有区别。</p>
<p>普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
<p>抽象类不能直接实例化，普通类可以直接实例化。　　</p>
</li>
</ol>
<h3 id="9-java-中-IO-流分为几种？"><a href="#9-java-中-IO-流分为几种？" class="headerlink" title="9.java 中 IO 流分为几种？"></a>9.java 中 IO 流分为几种？</h3><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h3 id="10-BIO、NIO、AIO-有什么区别？"><a href="#10-BIO、NIO、AIO-有什么区别？" class="headerlink" title="10.BIO、NIO、AIO 有什么区别？"></a>10.BIO、NIO、AIO 有什么区别？</h3><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的<strong>传统 IO</strong>，它的特点是模式简单使用方便，并发处理能力低。</p>
<p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，<strong>客户端和服务器端通过 Channel（通道）通讯，实现了多路复用</strong>。</p>
<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，<strong>异步 IO 的操作基于事件和回调机制</strong>。</p>
<h3 id="11-Files的常用方法都有哪些？"><a href="#11-Files的常用方法都有哪些？" class="headerlink" title="11.Files的常用方法都有哪些？"></a>11.Files的常用方法都有哪些？</h3><p><strong>Files.exists()：检测文件路径是否存在。</strong></p>
<p><strong>Files.delete()：删除一个文件或目录。</strong></p>
<p><strong>Files.read()：读取文件。</strong></p>
<p><strong>Files.write()：写入文件。</strong></p>
<h3 id="6）wait和sleep的区别，必须理解"><a href="#6）wait和sleep的区别，必须理解" class="headerlink" title="6）wait和sleep的区别，必须理解"></a>6）wait和sleep的区别，必须理解</h3><p>sleep方法属于线程，wait方法属于对象<br> sleep休眠当前线程，不会释放对象锁，wait使当前线程进入等待状态，释放对象锁，只有针对此对象调用notify()方法（且共享对象资源释放）后本线程才会继续执行</p>
<h3 id="7）JVM的内存结构，JVM的算法"><a href="#7）JVM的内存结构，JVM的算法" class="headerlink" title="7）JVM的内存结构，JVM的算法"></a>7）JVM的内存结构，JVM的算法</h3><p>JVM内存结构主要有三大块：<strong>堆内存、方法区和栈</strong>，</p>
<p><strong>几乎所有的对象实例都存放在堆里</strong>，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。<br> <strong>方法区用于存储已被虚拟机加载的类信息、常量、静态变量</strong>、即时编译器编译后的代码等数据，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br> 每个方法被执行的时候都会同时创建一个<strong>栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</strong>。<br> 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</p>
<h3 id="15）说说http-https协议"><a href="#15）说说http-https协议" class="headerlink" title="15）说说http,https协议"></a>15）说说http,https协议</h3><p>http是一种超文本协议，默认端口80，以明文传输。<br> https是http协议的安全版，安全基础是SSL，以密文传输</p>
<h3 id="16）osi五层网络协议"><a href="#16）osi五层网络协议" class="headerlink" title="16）osi五层网络协议"></a>16）osi五层网络协议</h3><p>应用层、传输层、网络层、数据链路层、物理层</p>
<h3 id="18）说说tcp三次握手，四次挥手"><a href="#18）说说tcp三次握手，四次挥手" class="headerlink" title="18）说说tcp三次握手，四次挥手"></a>18）说说tcp三次握手，四次挥手</h3><p>1.客户端向服务器<strong>发送</strong>一个syn包，进入发送状态<br> 2.服务器收到syn包，<strong>确认</strong>客户的syn，并向客户端<strong>发送</strong>syn+ack包，进入接受状态<br> 3.客户端接受的来自服务的的syn包信息，向服务的<strong>发出</strong>ack包，次数两者进入tcp连接成功状态</p>
<h4 id="21）请写一段栈溢出、堆溢出的代码"><a href="#21）请写一段栈溢出、堆溢出的代码" class="headerlink" title="21）请写一段栈溢出、堆溢出的代码"></a>21）请写一段栈溢出、堆溢出的代码</h4><p><strong>堆溢出，死循环存值</strong>，JVM就会抛出OutOfMemoryError:java heap space异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">       System.out.println(<span class="string">"分配次数："</span>+(++i));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;java</span><br></pre></td></tr></table></figure>
<p><strong>栈溢出，栈空间不足</strong>——StackOverflowError实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSOFTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sofMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">     depth ++ ;</span><br><span class="line">     **sofMethod();**</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     StackSOFTest test = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       test = <span class="keyword">new</span> StackSOFTest();</span><br><span class="line">       test.sofMethod();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">"递归次数："</span>+test.depth);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-说出一些常用的类，包，接口，请各举5个。"><a href="#29-说出一些常用的类，包，接口，请各举5个。" class="headerlink" title="29.说出一些常用的类，包，接口，请各举5个。"></a>29.说出一些常用的类，包，接口，请各举5个。</h3><p>注意：要让人家感觉你对java ee开发很熟，java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。</p>
<p>常用的类：</p>
<p>BufferedReader</p>
<p>BufferedWriter</p>
<p>FileReader</p>
<p>FileWirter</p>
<p>String</p>
<p>Integer</p>
<p>java.util.Date</p>
<p>System</p>
<p>Class</p>
<p>List</p>
<p>HashMap</p>
<p>常用的包：</p>
<p>java.lang</p>
<p>java.io</p>
<p>java.util</p>
<p>java.sql</p>
<p>javax.servlet</p>
<p>org.apache.strtuts.action</p>
<p>org.hibernate</p>
<p>常用的接口：</p>
<p>Remote</p>
<p>List</p>
<p>Map</p>
<p>Document</p>
<p>NodeList</p>
<p>Servlet</p>
<p>HttpServletRequest</p>
<p>HttpServletResponse</p>
<p>Transaction(Hibernate)</p>
<p>Session(Hibernate)</p>
<p>HttpSession</p>
<h3 id="33-描述一下JVM加载class文件的原理机制"><a href="#33-描述一下JVM加载class文件的原理机制" class="headerlink" title="33.描述一下JVM加载class文件的原理机制?"></a>33.描述一下JVM加载class文件的原理机制?</h3><p>Java语言是一种具有动态性的解释型语言，类（class）只有被加载到JVM后才能运行。当运行指定程序时，JVM会将编译生成的.class文件按照需求和一定的规则加载到内存中，并组织成为一个完整的Java应用程序，这个加载过程是由类加载器完成。</p>
<p>具体来说，就是由ClassLoader和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。</p>
<p><strong>类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用new等方式创建对象时，会隐式地调用类的加载器把对应的类加载到JVM中。显示加载指的是通过直接调用class.forName()方法来把所需的类加载到JVM中。</strong></p>
<p>任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到JVM中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。</p>
<p>此外，在Java语言中，每个类或接口都对应一个.class文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。</p>
<p>在Java语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到JVM中，至于其他类，则在需要的时候才加载：下面是加载的步骤：</p>
<p>初始化。对静态变量和静态代码块执行初始化工作。</p>
<p>装载。根据查找路径找到相应的class文件，然后导入。</p>
<p>链接。链接又可分为3个小步：</p>
<p>检查，检查待加载的class文件的正确性。</p>
<p>准备，给类中的静态变量分配存储空间。</p>
<p>解析，将符号引用转换为直接引用（这一步可选）。</p>
<p>方法中的局部变量使用final修饰后，放在堆中，而不是栈</p>
<h3 id="35-堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？"><a href="#35-堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？" class="headerlink" title="35.堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？"></a>35.堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？</h3><p><strong>堆栈都是内存的可用区域，但是堆的速度慢容量大，栈的速度快容量小。一个64K的字符串，自然放在堆</strong>。</p>
<p>栈的内存是很宝贵的。</p>
<p><strong>只有引用及基本数据类型是直接存在栈上</strong>。对象类型可能是在堆、方法区、常量池中；放到堆中还是放到栈中，jvm会根据你的数据类型决定。</p>
<p>栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p>堆区（heap） ：一般由程序员分配释放， 若程序员不释放，程序结束时可能由GC回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
<h3 id="36-GC是什么-为什么要有GC"><a href="#36-GC是什么-为什么要有GC" class="headerlink" title="36.GC是什么? 为什么要有GC?"></a>36.GC是什么? 为什么要有GC?</h3><p><strong>GC是垃圾收集的意思</strong>（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃。</p>
<p>Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p>
<h3 id="38-垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#38-垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="38.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>38.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>不过垃圾回收机制的回收是不确定的，不一定会马上回收内存。</p>
<p>可以主动通知虚拟机进行垃圾回收：<strong>程序员可以手动执行System.gc()</strong>，通知GC运行，但是Java语言规范并不保证GC一定会执行。实际上GC是一个守护线程(守护线程的作用是为其他线程提供服务)。</p>
<h3 id="39-什么时候用assert？"><a href="#39-什么时候用assert？" class="headerlink" title="39.什么时候用assert？"></a>39.什么时候用assert？</h3><p>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<p>在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。</p>
<p>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssertTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">     System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//假设程序不小心多了一句--i;</span></span><br><span class="line">   --i;</span><br><span class="line">   <span class="keyword">assert</span> i==<span class="number">5</span>;    </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="40-java中会存在内存泄漏吗，请简单描述。"><a href="#40-java中会存在内存泄漏吗，请简单描述。" class="headerlink" title="40.java中会存在内存泄漏吗，请简单描述。"></a>40.java中会存在内存泄漏吗，请简单描述。</h3><p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。<strong>java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。</strong></p>
<p>由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：</p>
<p>java中的内存泄露的情况：<strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景(通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的）。</p>
<p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p>
<p>检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。</p>
<p>内存泄露的另外一种情况：<strong>当一个对象被存储进HashSet集合中以后</strong>，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。</p>
<p>java中可能出现内存泄露的情况，例如，<strong>缓存系统</strong>，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</p>
<h3 id="41-能不能自己写个类，也叫java-lang-String？"><a href="#41-能不能自己写个类，也叫java-lang-String？" class="headerlink" title="41.能不能自己写个类，也叫java.lang.String？"></a>41.能不能自己写个类，也叫java.lang.String？</h3><p><strong>可以，但在应用的时候，需要用自己的类加载器去加载</strong>，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。</p>
<h3 id="194-说一下-jvm-的主要组成部分？及其作用？"><a href="#194-说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="194.说一下 jvm 的主要组成部分？及其作用？"></a>194.说一下 jvm 的主要组成部分？及其作用？</h3><p>类加载器（ClassLoader）<br> 运行时数据区（Runtime Data Area）<br> 执行引擎（Execution Engine）<br> 本地库接口（Native Interface）</p>
<p>组件的作用: 首先通过<strong>类加载器</strong>（ClassLoader）会把 Java 代码<strong>转换成字节码</strong>，<strong>运行时数据区</strong>（Runtime Data Area）再把字节码<strong>加载到内存</strong>中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器<strong>执行引擎</strong>（Execution Engine），将字节码<strong>翻译成底层系统指令</strong>，再交由 CPU 去执行，而这个过程中需要调用其他语言的<strong>本地库接口</strong>（Native Interface）来实现整个程序的功能。</p>
<h3 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197.队列和栈是什么？有什么区别？"></a>197.队列和栈是什么？有什么区别？</h3><p><strong>队列和栈都是被用来预存储数据的。</strong></p>
<p> <strong>队列允许先进先出检索元素</strong>，但也有例外的情况，Deque 接口允许从两端检索元素。<br> <strong>栈对元素进行后进先出进行检索。</strong></p>
<h3 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198.什么是双亲委派模型？"></a>198.什么是双亲委派模型？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<p><strong>启动类加载器</strong>（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br> 其他类加载器：<br> <strong>扩展类加载器</strong>（Extension ClassLoader）：负责加载&lt;java_home style=“box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;”&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt;<br> <strong>应用程序类加载器</strong>（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>
<p>双亲委派模型：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</strong></p>
<h3 id="199-说一下类加载的执行过程？"><a href="#199-说一下类加载的执行过程？" class="headerlink" title="\199. 说一下类加载的执行过程？"></a>\199. 说一下类加载的执行过程？</h3><p>类加载分为以下 5 个步骤：</p>
<p>加载：根据查找路径找到相应的 class 文件然后导入；<br> 检查：检查加载的 class 文件的正确性；<br> 准备：给类中的静态变量分配内存空间；<br> 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br> 初始化：对静态变量和静态代码块执行初始化工作。</p>
<h3 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200.怎么判断对象是否可以被回收？"></a>200.怎么判断对象是否可以被回收？</h3><p>一般有两种方法来判断：</p>
<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br> 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
<h3 id="201-java-中都有哪些引用类型？"><a href="#201-java-中都有哪些引用类型？" class="headerlink" title="\201. java 中都有哪些引用类型？"></a>\201. java 中都有哪些引用类型？</h3><p>强引用<br> 软引用<br> 弱引用<br> 虚引用</p>
<h3 id="202-说一下-jvm-有哪些垃圾回收算法？"><a href="#202-说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="\202. 说一下 jvm 有哪些垃圾回收算法？"></a>\202. 说一下 jvm 有哪些垃圾回收算法？</h3><p>标记-清除算法<br> 标记-整理算法<br> 复制算法<br> 分代算法</p>
<h3 id="203-说一下-jvm-有哪些垃圾回收器？"><a href="#203-说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="203.说一下 jvm 有哪些垃圾回收器？"></a>203.说一下 jvm 有哪些垃圾回收器？</h3><p>Serial：最早的单线程串行垃圾回收器。<br> Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br> ParNew：是 Serial 的多线程版本。<br> Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br> Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br> <strong>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</strong><br> <strong>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</strong></p>
<h3 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204.详细介绍一下 CMS 垃圾回收器？"></a>204.详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 是英文 <strong>Concurrent Mark-Sweep</strong> 的简称，<strong>是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器</strong>。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p><strong>CMS 使用的是标记-清除的算法实现的</strong>，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><p><strong>新生代回收器：Serial、ParNew、Parallel Scavenge</strong><br> <strong>老年代回收器：Serial Old、Parallel Old、CMS</strong><br> <strong>整堆回收器：G1</strong></p>
<p><strong>新生代垃圾回收器一般采用的是复制算法</strong>，复制算法的优点是效率高，缺点是内存利用率低；</p>
<p><strong>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</strong></p>
<h3 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="\206. 简述分代垃圾回收器是怎么工作的？"></a>\206. 简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器有两个分区：<strong>老生代和新生代</strong>，新生代默认的空间占<strong>比总空间的 1/3</strong>，<strong>老生代的默认占比是 2/3</strong>。</p>
<p><strong>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1</strong>，它的执行流程如下：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br> 清空 Eden 和 From Survivor 分区；<br> From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p>
<p><strong>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</strong></p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h3 id="207-说一下-jvm-调优的工具？"><a href="#207-说一下-jvm-调优的工具？" class="headerlink" title="207.说一下 jvm 调优的工具？"></a>207.说一下 jvm 调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br> jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。<br> \208. 常用的 jvm 调优的参数都有哪些？</p>
<p>-Xms2g：初始化推大小为 2g；<br> -Xmx2g：堆最大内存为 2g；<br> -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br> -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br> –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br> -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br> -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br> -XX:+PrintGC：开启打印 gc 信息；<br> -XX:+PrintGCDetails：打印 gc 详细信息。</p>
<h3 id="2-你所知道网络协议有那些？"><a href="#2-你所知道网络协议有那些？" class="headerlink" title="2.你所知道网络协议有那些？"></a>2.你所知道网络协议有那些？</h3><p>HTTP：超文本传输协议</p>
<p>FTP：文件传输协议</p>
<p>SMPT：简单邮件协议</p>
<p>TELNET：远程终端协议</p>
<p>POP3：邮件读取协议</p>
<h3 id="3-Java都有那些开发平台？"><a href="#3-Java都有那些开发平台？" class="headerlink" title="3.Java都有那些开发平台？"></a>3.Java都有那些开发平台？</h3><p>JAVA SE：主要用在客户端开发</p>
<p>JAVA EE：主要用在web应用程序开发</p>
<p>JAVA ME：主要用在嵌入式应用程序开发</p>
<p>5.Java是否需要开发人员回收内存垃圾吗？</p>
<p>大多情况下是不需要的。<strong>Java提供了一个系统级的线程来跟踪内存分配</strong>，<strong>不再使用的内存区将会自动回收</strong></p>
<h3 id="8-Java的数据结构有那些？"><a href="#8-Java的数据结构有那些？" class="headerlink" title="8.Java的数据结构有那些？"></a>8.Java的数据结构有那些？</h3><p>线性表（ArrayList）</p>
<p>链表（LinkedList）</p>
<p>栈（Stack）</p>
<p>队列（Queue）</p>
<p>图（Map）</p>
<p>树（Tree）</p>
<h3 id="9-什么是OOP"><a href="#9-什么是OOP" class="headerlink" title="9.什么是OOP?"></a>9.什么是OOP?</h3><p>面向对象编程</p>
<h3 id="10-什么是面向对象？"><a href="#10-什么是面向对象？" class="headerlink" title="10.什么是面向对象？"></a>10.什么是面向对象？</h3><p>世间万物都可以看成一个对象。每个物体包括动态的行为和静态的属性，这些就构成了一个对象。</p>
<h3 id="11-类与对象的关系"><a href="#11-类与对象的关系" class="headerlink" title="11.类与对象的关系?"></a>11.类与对象的关系?</h3><p>类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例</p>
<h3 id="12-Java中有几种数据类型"><a href="#12-Java中有几种数据类型" class="headerlink" title="12.Java中有几种数据类型"></a>12.Java中有几种数据类型</h3><p>整形：byte,short,int,long</p>
<p>浮点型：float,double</p>
<p>字符型：char</p>
<p>布尔型：boolean</p>
<h3 id="13-什么是隐式转换，什么是显式转换"><a href="#13-什么是隐式转换，什么是显式转换" class="headerlink" title="13.什么是隐式转换，什么是显式转换"></a>13.什么是隐式转换，什么是显式转换</h3><p>显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。</p>
<h3 id="14-Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型"><a href="#14-Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型" class="headerlink" title="14.Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型"></a>14.Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型</h3><p>Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；<strong>Char&lt;int&lt;long&lt;float&lt;double</strong>；Char类型可以隐式转成int,double类型，但是不能隐式转换成string；如果char类型转成byte，short类型的时候，需要强转。</p>
<h3 id="15-什么是拆装箱？"><a href="#15-什么是拆装箱？" class="headerlink" title="15.什么是拆装箱？"></a>15.什么是拆装箱？</h3><p>拆箱：把包装类型转成基本数据类型</p>
<p>装箱：把基本数据类型转成包装类型</p>
<h3 id="16-Java中的包装类都是那些？"><a href="#16-Java中的包装类都是那些？" class="headerlink" title="16.Java中的包装类都是那些？"></a>16.Java中的包装类都是那些？</h3><p>byte：Byte </p>
<p>short：Short </p>
<p><strong>int：Integer</strong></p>
<p>long：Long </p>
<p>float：Float </p>
<p>double：Double </p>
<p><strong>char：Character</strong></p>
<p>boolean：Boolean</p>
<h3 id="17-一个java类中包含那些内容？"><a href="#17-一个java类中包含那些内容？" class="headerlink" title="17.一个java类中包含那些内容？"></a>17.一个java类中包含那些内容？</h3><p>属性、方法、内部类、构造方法、代码块。</p>
<h3 id="18-例如：-if-a-1-0-4-0-，这样做好吗？"><a href="#18-例如：-if-a-1-0-4-0-，这样做好吗？" class="headerlink" title="18.例如： if(a+1.0=4.0)，这样做好吗？"></a>18.例如： if(a+1.0=4.0)，这样做好吗？</h3><p>不好，<strong>因为计算机在浮点型数据运算的时候，会有误差，尽量在布尔表达式中不使用浮点型数据(if,while,switch中判断条件不使用浮点型)</strong></p>
<h3 id="19-那针对浮点型数据运算出现的误差的问题，你怎么解决？"><a href="#19-那针对浮点型数据运算出现的误差的问题，你怎么解决？" class="headerlink" title="19.那针对浮点型数据运算出现的误差的问题，你怎么解决？"></a>19.那针对浮点型数据运算出现的误差的问题，你怎么解决？</h3><p>使用<code>Bigdecimal</code>类进行浮点型数据的运算</p>
<h3 id="20-i与i-的区别"><a href="#20-i与i-的区别" class="headerlink" title="20.++i与i++的区别"></a>20.++i与i++的区别</h3><p>++i：先赋值，后计算</p>
<p>i++：先计算，后赋值</p>
<h3 id="21-程序的结构有那些？"><a href="#21-程序的结构有那些？" class="headerlink" title="21.程序的结构有那些？"></a>21.程序的结构有那些？</h3><p>顺序结构</p>
<p>选择结构</p>
<p>循环结构</p>
<h3 id="22-数组实例化有几种方式？"><a href="#22-数组实例化有几种方式？" class="headerlink" title="22.数组实例化有几种方式？"></a>22.数组实例化有几种方式？</h3><p><strong>静态实例化</strong>：创建数组的时候已经指定数组中的元素,</p>
<p>int[] a=new int[]{1,3,3}</p>
<p><strong>动态实例化</strong>：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值</p>
<h3 id="23-Java中各种数据默认值"><a href="#23-Java中各种数据默认值" class="headerlink" title="23.Java中各种数据默认值"></a>23.Java中各种数据默认值</h3><p>Byte,short,int,long默认是都是0</p>
<p>Boolean默认值是false</p>
<p>Char类型的默认值是’ ’</p>
<p>Float与double类型的默认是0.0</p>
<p>对象类型的默认值是null</p>
<p>26.Object类常用方法有那些？</p>
<p><strong>Equals</strong></p>
<p>Hashcode</p>
<p><strong>toString</strong></p>
<p>wait</p>
<p>notify</p>
<p>clone</p>
<p>getClass</p>
<h3 id="28-java中是值传递引用传递？"><a href="#28-java中是值传递引用传递？" class="headerlink" title="28.java中是值传递引用传递？"></a>28.java中是值传递引用传递？</h3><p><strong>理论上说，java都是引用传递</strong>，对于基本数据类型，传递是<strong>值的副本</strong>，而不是值本身。对于对象类型，传递是<strong>对象的引用</strong>，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。</p>
<h3 id="29-假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？"><a href="#29-假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？" class="headerlink" title="29.假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？"></a>29.假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？</h3><p>改变了，因为传递是对象的引用，操作的是引用所指向的对象</p>
<h3 id="30-实例化数组后，能不能改变数组长度呢？"><a href="#30-实例化数组后，能不能改变数组长度呢？" class="headerlink" title="30.实例化数组后，能不能改变数组长度呢？"></a>30.实例化数组后，能不能改变数组长度呢？</h3><p>不能，数组一旦实例化，它的长度就是固定的</p>
<h3 id="31-假设数组内有5个元素，如果对数组进行反序，该如何做？"><a href="#31-假设数组内有5个元素，如果对数组进行反序，该如何做？" class="headerlink" title="31.假设数组内有5个元素，如果对数组进行反序，该如何做？"></a>31.假设数组内有5个元素，如果对数组进行反序，该如何做？</h3><p>创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中</p>
<h3 id="32-形参与实参"><a href="#32-形参与实参" class="headerlink" title="32.形参与实参"></a>32.形参与实参</h3><p>形参：全称为“形式参数”，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值；</p>
<p>实参：全称为“实际参数”，是在调用方法时传递给该方法的实际值。</p>
<h3 id="33-构造方法能不能显式调用？"><a href="#33-构造方法能不能显式调用？" class="headerlink" title="33.构造方法能不能显式调用？"></a>33.构造方法能不能显式调用？</h3><p><strong>不能 构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用</strong></p>
<h3 id="36-内部类与静态内部类的区别？"><a href="#36-内部类与静态内部类的区别？" class="headerlink" title="36.内部类与静态内部类的区别？"></a>36.内部类与静态内部类的区别？</h3><p>静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法；</p>
<p>普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。</p>
<p>如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象</p>
<h3 id="37-Static关键字有什么作用？"><a href="#37-Static关键字有什么作用？" class="headerlink" title="37.Static关键字有什么作用？"></a>37.Static关键字有什么作用？</h3><p>Static可以修饰内部类、方法、变量、代码块</p>
<p>Static修饰的类是静态类</p>
<p>Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。</p>
<p>Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。</p>
<p>Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。</p>
<h3 id="38-Final在java中的作用"><a href="#38-Final在java中的作用" class="headerlink" title="38.Final在java中的作用"></a>38.Final在java中的作用</h3><p>Final可以修饰类，修饰方法，修饰变量。</p>
<p>修饰的类叫最终类。该类不能被继承。</p>
<p>修饰的方法不能被重写。</p>
<p><strong>修饰的变量叫常量，常量必须初始化，一旦初始化后，常量的值不能发生改变。</strong></p>
<h3 id="39-Java中操作字符串使用哪个类？"><a href="#39-Java中操作字符串使用哪个类？" class="headerlink" title="39.Java中操作字符串使用哪个类？"></a>39.Java中操作字符串使用哪个类？</h3><p>String，StringBuffer，StringBuilder</p>
<h3 id="42-String-str-”aa”-String-s-”bb”-String-aa-aa-s-一种创建了几个对象？"><a href="#42-String-str-”aa”-String-s-”bb”-String-aa-aa-s-一种创建了几个对象？" class="headerlink" title="42.String str=”aa”,String s=”bb”,String aa=aa+s;一种创建了几个对象？"></a>42.String str=”aa”,String s=”bb”,String aa=aa+s;一种创建了几个对象？</h3><p>一共有两个引用，三个对象。因为”aa”与”bb”都是常量，常量的值不能改变，当执行字符串拼接时候，会创建一个新的常量是” aabbb”,有将其存到常量池中。</p>
<h3 id="43-将下java中的math类有那些常用方法？"><a href="#43-将下java中的math类有那些常用方法？" class="headerlink" title="43.将下java中的math类有那些常用方法？"></a>43.将下java中的math类有那些常用方法？</h3><p>Pow()：幂运算</p>
<p>Sqrt()：平方根</p>
<p>Round()：四舍五入</p>
<p>Abs()：求绝对值</p>
<p>Random()：生成一个0-1的随机数，包括0不包括1</p>
<h3 id="46-与equlas有什么区别？"><a href="#46-与equlas有什么区别？" class="headerlink" title="46.==与equlas有什么区别？"></a>46.==与equlas有什么区别？</h3><p>==可以判断基本数据类型值是否相等，也可以判断两个对象指向的内存地址是否相同，也就是说判断两个对象是否是同一个对象，Equlas通常用来做字符串比较。</p>
<h3 id="53-创建一个子类对象的时候，那么父类的构造方法会执行吗？"><a href="#53-创建一个子类对象的时候，那么父类的构造方法会执行吗？" class="headerlink" title="53.创建一个子类对象的时候，那么父类的构造方法会执行吗？"></a>53.创建一个子类对象的时候，那么父类的构造方法会执行吗？</h3><p>会执行。当创建一个子类对象，调用子类构造方法的时候，子类构造方法会默认调用父类的构造方法。</p>
<h3 id="54-什么是父类引用指向子类对象？"><a href="#54-什么是父类引用指向子类对象？" class="headerlink" title="54.什么是父类引用指向子类对象？"></a>54.什么是父类引用指向子类对象？</h3><p>是java多态一种特殊的表现形式。创建父类引用，让该引用指向一个子类的对象</p>
<p>55.当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？</p>
<p>子类重写了父类方法和属性，访问的是父类的属性，调用的是子类的方法</p>
<h3 id="60-抽象类可以使用final修饰吗？"><a href="#60-抽象类可以使用final修饰吗？" class="headerlink" title="60.抽象类可以使用final修饰吗？"></a>60.抽象类可以使用final修饰吗？</h3><p>不可以。定义抽象类就是让其他继承的，而final修饰类表示该类不能被继承，与抽象类的理念违背了</p>
<h3 id="64-接口有什么特点？"><a href="#64-接口有什么特点？" class="headerlink" title="64.接口有什么特点？"></a>64.接口有什么特点？</h3><p>接口中声明全是public static final修饰的常量</p>
<p>接口中所有方法都是抽象方法</p>
<p>接口是没有构造方法的</p>
<p>接口也不能直接实例化</p>
<p>接口可以多继承</p>
<h3 id="68-异常的处理机制有几种？"><a href="#68-异常的处理机制有几种？" class="headerlink" title="68.异常的处理机制有几种？"></a>68.异常的处理机制有几种？</h3><p>异常捕捉：try…catch…finally，异常抛出：throws。</p>
<h3 id="69-如何自定义一个异常"><a href="#69-如何自定义一个异常" class="headerlink" title="69.如何自定义一个异常"></a>69.如何自定义一个异常</h3><p>继承一个异常类，通常是RumtimeException或者Exception</p>
<h3 id="70-在异常捕捉时，如果发生异常，那么try-catch-finally块外的return语句会执行吗？"><a href="#70-在异常捕捉时，如果发生异常，那么try-catch-finally块外的return语句会执行吗？" class="headerlink" title="70.在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？"></a>70.在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？</h3><p>会执行，如果有finally，在finally之后被执行，如果没有finally，在catch之后被执行</p>
<h3 id="72-Thow与thorws区别"><a href="#72-Thow与thorws区别" class="headerlink" title="72.Thow与thorws区别"></a>72.Thow与thorws区别</h3><p>Throw写在代码块内，throws后面跟的是一个具体的异常实例</p>
<p>Throw写在方法前面后面，throws后面跟的是异常类，异常类可以出现多个</p>
<h3 id="74-使用Log4j对程序有影响吗？"><a href="#74-使用Log4j对程序有影响吗？" class="headerlink" title="74.使用Log4j对程序有影响吗？"></a>74.使用Log4j对程序有影响吗？</h3><p>有，log4j是用来日志记录的，记录一些关键敏感的信息，通常会将日志记录到本地文件或者数据库中。记录在本地文件中，会有频繁的io操作，会耗费一些系统资源。记录在数据库中，会频繁地操作数据库表，对系统性能也有一定的影响。但是为了程序安全以及数据的恢复或者bug的跟踪，这点资源消耗是可以承受的。</p>
<h3 id="75-Log4j日志有几个级别？"><a href="#75-Log4j日志有几个级别？" class="headerlink" title="75.Log4j日志有几个级别？"></a>75.Log4j日志有几个级别？</h3><p>由低到高：debug、info、wran、error</p>
<h3 id="77-Java反射创建对象效率高还是通过new创建对象的效率高？"><a href="#77-Java反射创建对象效率高还是通过new创建对象的效率高？" class="headerlink" title="77.Java反射创建对象效率高还是通过new创建对象的效率高？"></a>77.Java反射创建对象效率高还是通过new创建对象的效率高？</h3><p>通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低</p>
<h3 id="85-JDBC操作的步骤"><a href="#85-JDBC操作的步骤" class="headerlink" title="85.JDBC操作的步骤"></a>85.JDBC操作的步骤</h3><p>加载数据库驱动类</p>
<p>打开数据库连接</p>
<p>执行sql语句</p>
<p>处理返回结果</p>
<p>关闭资源</p>
<h3 id="86-在使用jdbc的时候，如何防止出现sql注入的问题。"><a href="#86-在使用jdbc的时候，如何防止出现sql注入的问题。" class="headerlink" title="86.在使用jdbc的时候，如何防止出现sql注入的问题。"></a>86.在使用jdbc的时候，如何防止出现sql注入的问题。</h3><p>使用PreparedStatement类，而不是使用Statement类</p>
<h3 id="87-怎么在JDBC内调用一个存储过程"><a href="#87-怎么在JDBC内调用一个存储过程" class="headerlink" title="87.怎么在JDBC内调用一个存储过程"></a>87.怎么在JDBC内调用一个存储过程</h3><p>使用CallableStatement</p>
<h3 id="88-是否了解连接池，使用连接池有什么好处？"><a href="#88-是否了解连接池，使用连接池有什么好处？" class="headerlink" title="88.是否了解连接池，使用连接池有什么好处？"></a>88.是否了解连接池，使用连接池有什么好处？</h3><p>数据库连接是非常消耗资源的，影响到程序的性能指标。</p>
<p>连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。</p>
<h3 id="89-你所了解的数据源技术有那些？使用数据源有什么好处？"><a href="#89-你所了解的数据源技术有那些？使用数据源有什么好处？" class="headerlink" title="89.你所了解的数据源技术有那些？使用数据源有什么好处？"></a>89.你所了解的数据源技术有那些？使用数据源有什么好处？</h3><p>Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全；通过配置文件的形式来维护数据库信息，而不是通过硬编码。</p>
<p><strong>当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据库信息的更新。</strong></p>
<h3 id="91-常用io类有那些？"><a href="#91-常用io类有那些？" class="headerlink" title="91.常用io类有那些？"></a>91.常用io类有那些？</h3><p>File</p>
<p>FileInputSteam，FileOutputStream</p>
<p>BufferInputStream，BufferedOutputSream</p>
<p>Print Write</p>
<p>FileReader，FileWriter</p>
<p>BufferReader，BufferedWriter</p>
<h3 id="92-字节流与字符流的区别"><a href="#92-字节流与字符流的区别" class="headerlink" title="92.字节流与字符流的区别"></a>92.字节流与字符流的区别</h3><p>以字节为单位输入输出数据，字节流按照8位传输</p>
<p>以字符为单位输入输出数据，字符流按照16位传输</p>
<h3 id="93-final、finalize-、finally"><a href="#93-final、finalize-、finally" class="headerlink" title="93.final、finalize()、finally"></a>93.final、finalize()、finally</h3><p>性质不同</p>
<p>final为关键字；</p>
<p>finalize()为方法；</p>
<p>finally为区块标志，用于try语句中；</p>
<p>作用</p>
<p>final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；</p>
<p>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；</p>
<p>finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行；</p>
<h3 id="99-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#99-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="99.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>99.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h3><p>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p>
<h3 id="10、什么是-ThreadLocal？ThreadLocal-和-Synchonized-的区别？"><a href="#10、什么是-ThreadLocal？ThreadLocal-和-Synchonized-的区别？" class="headerlink" title="10、什么是 ThreadLocal？ThreadLocal 和 Synchonized 的区别？"></a>10、什么是 ThreadLocal？ThreadLocal 和 Synchonized 的区别？</h3><p>线程局部变量。是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。</p>
<p><strong>synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而 ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</strong></p>
<p> 6.深拷贝和浅拷贝：</p>
<p>  简单来讲就是复制、克隆；Person p=new Person(“张三”);</p>
<p>  浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错</p>
<p>  深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间</p>
<h3 id="7-值传递和引用传递："><a href="#7-值传递和引用传递：" class="headerlink" title="7.值传递和引用传递："></a>7.值传递和引用传递：</h3><p>  值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量</p>
<p>  引用传递：就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改</p>
<p>8.web 容器功能：</p>
<p>  通信支持、管理Servlet生命周期，多线程、将jsp转换成java等等</p>
<h3 id="9-java内存分配"><a href="#9-java内存分配" class="headerlink" title="9.java内存分配"></a>9.java内存分配</h3><p>  寄存器：我们无法控制</p>
<p>  静态域：static定义的静态成员</p>
<p>  常量池：编译时被确定并保存在.class文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）</p>
<p>  非ram存储：硬盘等永久存储空间</p>
<p>  <strong>堆内存：new创建的对象和数组，由java虚拟机自动垃圾回收器管理,存取速度慢</strong></p>
<p>  <strong>栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址）</strong>，速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性</p>
<h3 id="11-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#11-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="11.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>11.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p>
<p>13.简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。</p>
<p>  条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型</p>
<p>  逻辑操作不会产生短路.</p>
<p>  使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算</p>
<p>14.说说&amp;和&amp;&amp;的区别。</p>
<p>==相同点==：&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p>
<p>==&amp;&amp;具有短路功能==：即如果第一个表达式为false，则不再计算第二个表达式。</p>
<p>15.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</p>
<p>在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。<strong>long不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它不能作用于swtich语句中。</strong></p>
<p>对于string而言：JDK1.7以前是不能作为switch的，以后即可以作用于switch中。</p>
<h3 id="17-char型变量中能不能存贮一个中文汉字-为什么"><a href="#17-char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="17.char型变量中能不能存贮一个中文汉字?为什么?"></a>17.char型变量中能不能存贮一个中文汉字?为什么?</h3><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字。</p>
<p>不过要注意的是：</p>
<p>如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字</p>
<p>unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h3 id="18-用最有效率的方法算出2乘以8等於几"><a href="#18-用最有效率的方法算出2乘以8等於几" class="headerlink" title="18.用最有效率的方法算出2乘以8等於几?"></a>18.用最有效率的方法算出2乘以8等於几?</h3><p>方法：将<strong>一个数左移n位</strong>，就相当于乘以了2的n次方，那么，一个数乘以8（2的3次方），只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是将2左移3位，即2 &lt;&lt; 3。</p>
<h3 id="19-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#19-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="19.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>19.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>使用final关键字修饰一个变量时，是<strong>指引用变量不能变</strong>，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：final StringBuffer a=new StringBuffer(“immutable”);</p>
<p>执行如下语句将报告编译期错误：a=new StringBuffer(“”);</p>
<p>但是，执行如下语句则可以通过编译：a.append(“ broken!”);</p>
<p>java有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：   </p>
<p>public void method(final  StringBuffer  param)  {  }   </p>
<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：    param.append(“a”);</p>
<h3 id="20-java-中对象的创建方法有几种？"><a href="#20-java-中对象的创建方法有几种？" class="headerlink" title="20.java 中对象的创建方法有几种？"></a>20.java 中对象的创建方法有几种？</h3><p>通过new来创建</p>
<p>通过反射创建</p>
<p>通过复制创建</p>
<p>21.”==”和equals方法究竟有什么区别？</p>
<p>如果是在object对象中，那么两者所表示的都是值是否相等（public boolean equals(Object obj){return (this==obj); }）,可以看到object的equals方法是使用的“==”比较。</p>
<p>一般而言，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符，也就是比较内存中所存储的两个变量的值是否相等。</p>
<p>举例：String a=new String(“foo”); String b=new String(“foo”);它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。</p>
<p>在实际开发中，我们经常要比较传递进行来的<strong>字符串内容是否等，此时是使用的equals（）方法。</strong></p>
<p>对于equals（）而言，默认情况是从object类继承的，当希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由自己写代码来决定在什么情况即可认为两个对象的内容是相同的。</p>
<h3 id="22-静态变量和实例变量的区别？"><a href="#22-静态变量和实例变量的区别？" class="headerlink" title="22.静态变量和实例变量的区别？"></a>22.静态变量和实例变量的区别？</h3><p>在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</p>
<p>在程序运行时的区别：</p>
<p>实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。</p>
<p>静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。、</p>
<p>总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<h3 id="23-是否可以从一个static方法内部发出对非static方法的调用？"><a href="#23-是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="23.是否可以从一个static方法内部发出对非static方法的调用？"></a>23.是否可以从一个static方法内部发出对非static方法的调用？</h3><p>不可以。</p>
<p><strong>对于static修饰的静态方法，是随着类的加载而加载，且调用的时可以不用创建对象而直接调用</strong></p>
<p>非静态方法要与对象联系在一起，只有创建了对象了以后才能调用非静态方法，即当一个静态方法被调用的时候，有可能还没有创建任何实例对象。</p>
<h3 id="24-Integer与int的区别"><a href="#24-Integer与int的区别" class="headerlink" title="24.Integer与int的区别"></a>24.Integer与int的区别</h3><p>int是java提供的8种原始数据类型之一，系统给的默认值为0。</p>
<p>Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。系统给的默认值为null。</p>
<h3 id="25-Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#25-Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="25.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?"></a>25.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</h3><p>Math类中提供了三个与取整有关的方法：ceil（向上取整）、floor（向下取整）、round（四舍五入）</p>
<p>举例：</p>
<p>Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11</p>
<p>Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12</p>
<p>算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</p>
<h3 id="28-Overload和Override的区别。Overload的方法是否可以改变返回值的类型"><a href="#28-Overload和Override的区别。Overload的方法是否可以改变返回值的类型" class="headerlink" title="28.Overload和Override的区别。Overload的方法是否可以改变返回值的类型?"></a>28.Overload和Override的区别。Overload的方法是否可以改变返回值的类型?</h3><p>Overload:表示方法重载，表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数、类型、位置不同），通过定义不同的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行：</p>
<p>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；</p>
<p>不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>方法的异常类型和数目不会对重载造成影响；</p>
<p>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
<p>Override：表示方法重写（覆盖），表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，当通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。</p>
<p>重写的方法的标志必须要和被重写的方法的标志完全匹配，才能达到重写的效果；</p>
<p>重写的方法的返回值必须和被重写的方法的返回一致；</p>
<p>重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类（因为子类是解决父类的一些方法，不能比父类更多问题）；</p>
<p>被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写(子类方法的访问权限只能比父类的更大，不能更小)。</p>
<p>如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关联。椅子与腿和背时组合关系。</p>
<h3 id="31-序列化接口的id有什么用？"><a href="#31-序列化接口的id有什么用？" class="headerlink" title="31.序列化接口的id有什么用？"></a>31.序列化接口的id有什么用？</h3><p>对象经常要通过IO进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没有个统一的干法，于是，sun公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被sun的这种方案处理，必须实现Serializable接口。ObjectOutputStream.writeObject(obj);<br>Object obj = ObjectInputStream.readObject();</p>
<p>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun的jdk就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错!</p>
<h3 id="32-hashCode方法的作用？"><a href="#32-hashCode方法的作用？" class="headerlink" title="32.hashCode方法的作用？"></a>32.hashCode方法的作用？</h3><p>hashcode这个方法是用来鉴定2个对象是否相等的。</p>
<p>与equals（）方法的区别：</p>
<p>简单来讲，<strong>equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等</strong>，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了</p>
<p>hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。</p>
<p>hashcode相当于是一个对象的编码，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。</p>
<h3 id="33-构造器Constructor是否可被override"><a href="#33-构造器Constructor是否可被override" class="headerlink" title="33.构造器Constructor是否可被override?"></a>33.构造器Constructor是否可被override?</h3><p>重写发生在继承过程中（子父类间），但是构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。</p>
<h3 id="6-final-finally-finalize的区别。"><a href="#6-final-finally-finalize的区别。" class="headerlink" title="6.final, finally, finalize的区别。"></a>6.final, finally, finalize的区别。</h3><p><strong>final：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承，内部类要访问局部变量，局部变量必须定义成final类型。</strong></p>
<p><strong>finally：是异常处理语句结构的一部分，表示总是执行，除非是遇到重大错误error，才不会执行finally。</strong></p>
<p><strong>finalize</strong>：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。</p>
<p>9.Java中的异常处理机制的简单原理和应用。</p>
<p>异常是指java程序运行时（非编译）所发生的非正常情况或错误，Java使用面向对象的方式来处理异常，它把程序中发生的每s个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。</p>
<p>所有异常的根类为java.lang.Throwable：Throwable下面又派生了两个子类：Error和Exception。</p>
<p><strong>Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了（内存溢出和线程死锁等系统问题）。</strong></p>
<p><strong>Exception表示程序还能够克服和恢复的问题</strong>：</p>
<p>其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉。</p>
<p>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p>
<p>java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。</p>
<p>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。</p>
<h3 id="10-Throwable：异常的父类。"><a href="#10-Throwable：异常的父类。" class="headerlink" title="10.Throwable：异常的父类。"></a>10.Throwable：异常的父类。</h3><p>error :jvm严重错误，JVM无法继续，因此这是不可捕捉无法用程序去恢复的错误。</p>
<p>exception： 可以捕获到，可以恢复。</p>
<p>cheched exception：IO/SQL异常，JVM要求我们对出现的异常进行catch。</p>
<p>runtime exception：运行时异常，我们可以不处理，将其抛出最后可以抛给JVM处理，多线程由thread.run()抛出，单线程由main（）函数抛出。运行时异常也有一般异常的子类，可以被catch到，如果不对其处理，要么线程终止，要么主线程终止（异常的处理目标就是将异常程序恢复正常）。</p>
<h3 id="11-请写出你最常见到的5个runtime-exception。"><a href="#11-请写出你最常见到的5个runtime-exception。" class="headerlink" title="11.请写出你最常见到的5个runtime exception。"></a>11.请写出你最常见到的5个runtime exception。</h3><p>在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。</p>
<p>ArrayindexOfBoundsException：数组越界异常。</p>
<p>NullPointerException：空指针异常。</p>
<p>ClassCastException：类型转换异常。</p>
<p>ClassNotFoundException：指定类不存在。</p>
<p>ArithmeticException：数字运算异常。</p>
<p>ArrayStoreException：数组存储与声明类型不兼容。</p>
<p>numberFormatException：数字格式异常。</p>
<h3 id="12-Java语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><a href="#12-Java语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？" class="headerlink" title="12.Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？"></a>12.Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</h3><p>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。</p>
<p>try：指定一块预防所有”异常”的程序。</p>
<p>cache：紧跟在try程序后面，用来指定想要捕捉的”异常”的类型。</p>
<p>throw：不处理异常，直接明确地抛出一个”异常”，给上一层处理。</p>
<p>finally：确保一段代码不管发生什么”异常”都被执行一段代码。</p>
<h3 id="16-同步有几种实现方法"><a href="#16-同步有几种实现方法" class="headerlink" title="16.同步有几种实现方法?"></a>16.同步有几种实现方法?</h3><p>同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</p>
<p>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h3 id="17-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#17-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="17.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>17.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><p>其他方法前是否加了synchronized关键字，如果没加，则能。</p>
<p>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</p>
<p>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</p>
<h3 id="19-简述synchronized和java-util-concurrent-locks-Lock的异同？"><a href="#19-简述synchronized和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="19.简述synchronized和java.util.concurrent.locks.Lock的异同？"></a>19.简述synchronized和java.util.concurrent.locks.Lock的异同？</h3><p><strong>主要相同点：Lock能完成synchronized所实现的所有功能。</strong></p>
<p>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。</p>
<p>synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
<p>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。</p>
<p>3.Comparable和Comparator接口是干什么的。</p>
<p>Java提供了只包含一个compareTo()方法的Comparable接口。</p>
<p><strong>这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</strong></p>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口。</p>
<p><strong>compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。</strong></p>
<h3 id="1-写clone-方法时，通常都有一行代码，是什么"><a href="#1-写clone-方法时，通常都有一行代码，是什么" class="headerlink" title="1.写clone()方法时，通常都有一行代码，是什么"></a>1.写clone()方法时，通常都有一行代码，是什么</h3><p>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。</p>
<h3 id="2-面向对象的特征有哪些方面"><a href="#2-面向对象的特征有哪些方面" class="headerlink" title="2.面向对象的特征有哪些方面"></a>2.面向对象的特征有哪些方面</h3><p>==封装==：将对象封装成独立的，高度自治的，相对封闭的模块，实现“高内聚，低耦合”，降低相互的依赖性，这个对象状态（属性）由这个对象自己的行为（方法）来读取和改变，将属性（变量）定位private，只有这个类自己的方法才可以访问到这些成员变量，一个原则是：让方法和它待在一起。</p>
<p>==继承==：表示的是类与类的关系，是子类共享父类所有数据和方法的一种机制，可提高软件的可重用性和扩展性，缺点是加强了耦合性。</p>
<p>构造方法和private修饰的方法不可以被继承。</p>
<p>==多态==：程序运行时的多种状态，增强了软件的灵活性和扩展性。</p>
<p>==抽象==： 将事物的相似和共性之处，拿出来，然后将这些事物归为一个类，忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面，抽象包括行为抽象和状态抽象两个方面。</p>
<p>把握一个原则：当前系统需要什么就只考虑什么。</p>
<h3 id="2-java中实现多态的机制是什么？"><a href="#2-java中实现多态的机制是什么？" class="headerlink" title="2.java中实现多态的机制是什么？"></a>2.java中实现多态的机制是什么？</h3><p><strong>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象</strong>，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<h3 id="3-abstract-class和interface有什么区别"><a href="#3-abstract-class和interface有什么区别" class="headerlink" title="3.abstract class和interface有什么区别?"></a>3.abstract class和interface有什么区别?</h3><p><strong>抽象类</strong>：含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。</p>
<p>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。</p>
<p>abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，==所以，不能有抽象构造方法或抽象静态方法==。</p>
<p>如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p><strong>接口</strong>：（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。</p>
<p> <strong>- 接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</strong></p>
<p>==语法区别==：</p>
<p>抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），==但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型==。</p>
<p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
<p><strong>一个类可以实现多个接口，但只能继承一个抽象类。</strong></p>
<p>==应用上的区别==：</p>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约</p>
<p>而抽象类在代码实现方面发挥作用，可以实现代码的重用</p>
<h3 id="4-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized"><a href="#4-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized" class="headerlink" title="4.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?"></a>4.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</h3><p><strong>abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</strong></p>
<p><strong>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。</strong></p>
<p>例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk的源代码，可以发现FileOutputStream的open方法的定义如下：<figure class="highlight plain"><figcaption><span>native void open(String name) throws FileNotFoundException;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，==但需要在前面声明native==。</span><br><span class="line"></span><br><span class="line">**关于synchronized与abstract合用的问题，我觉得也不行，synchronized应该是作用在一个具体的方法上才有意义，而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。**</span><br><span class="line"></span><br><span class="line">### 5.什么是内部类？Static Nested Class 和 Inner Class的不同。</span><br><span class="line"></span><br><span class="line">首先内部类的总体方面的特点：例如，</span><br><span class="line"></span><br><span class="line">在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</span><br><span class="line"></span><br><span class="line">**内部类就是在一个类的内部定义的类，内部类中不能定义静态成员**（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已</span><br><span class="line"></span><br><span class="line">内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</span><br><span class="line"></span><br><span class="line">**在方法内部定义的内部类前面不能有访问类型修饰符，**</span><br><span class="line"></span><br><span class="line">### 6.内部类可以引用它的包含类的成员吗？有没有什么限制？</span><br><span class="line"></span><br><span class="line">一般而言是可以的。如果不是静态内部类，那没有什么限制！</span><br><span class="line"></span><br><span class="line">但是，如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员</span><br><span class="line"></span><br><span class="line">### 7.Anonymous Inner Class (匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?</span><br><span class="line"></span><br><span class="line">可以继承其他类或实现其他接口。不仅是可以，而是必须!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 9.jdk中哪些类是不能继承的？   </span><br><span class="line"></span><br><span class="line">**不能继承的是类是那些用final关键字修饰的类**。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中比如，System,String,StringBuffer等类型。</span><br><span class="line"></span><br><span class="line">### 10.String是最基本的数据类型吗?</span><br><span class="line"></span><br><span class="line">不是，**是属于引用类型**。引用类型还有数组，日期等类型，java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</span><br><span class="line"></span><br><span class="line">基本数据类型包括byte、int、char、long、float、double、boolean和short。</span><br><span class="line"></span><br><span class="line">### 11.String s = &quot;Hello&quot;;s = s + &quot; world!&quot;;这两行代码执行后，原始的String对象中的内容到底变了没有？</span><br><span class="line"></span><br><span class="line">**没有。因为String由final修饰，被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。**</span><br><span class="line"></span><br><span class="line">如果要使用内容相同的字符串，不必每次都new一个String。比如下面的例子，在构造器中对一个叫S的string引用变量进行初始化，将其设置为初始值：应该如下这样做</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> public class Demo &#123;</span><br><span class="line">   private String s;</span><br><span class="line">   ...</span><br><span class="line">   public Demo &#123;</span><br><span class="line">   s = &quot;Initial Value&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>而不是==s = new String(“Initial Value”)==，因为这样每次都会掉用新的构造器，生成新的对象，性能低下的同时，内存开销大</p>
<h3 id="12-是否可以继承String类"><a href="#12-是否可以继承String类" class="headerlink" title="12.是否可以继承String类?"></a>12.是否可以继承String类?</h3><p>不能，String类是final类，故不可以继承。</p>
<h3 id="13-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？"><a href="#13-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？" class="headerlink" title="13.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？"></a>13.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</h3><p>两个</p>
<p>”xyz”对应一个对象，这个对象放在==字符串常量缓冲区==，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。</p>
<p>New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象</p>
<blockquote>
<p>如果以前就用过’xyz’，就不会创建”xyz”自己了，直接从缓冲区拿。</p>
</blockquote>
<h3 id="14-String-和StringBuffer的区别"><a href="#14-String-和StringBuffer的区别" class="headerlink" title="14.String 和StringBuffer的区别"></a>14.String 和StringBuffer的区别</h3><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。</p>
<p>String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。</p>
<p>String类： 表示内容不可改变的字符串，string重写了equals（）方法，new String(“abc”).equals(new String(“abc”)的结果为true，</p>
<p>StringBuffer类： 表示内容可以被修改的字符串，因此当你知道字符数据要改变的时候你就可以使用==StringBuffer==（比如：你可以使用StringBuffer来动态构造字符数据），StringBuffer并没有实现equals（）方法，故new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p>
<p> StringBuffer sbf = new StringBuffer();<br>  for(int i=0;i&lt;100;i++){<br>   sbf.append(i);<br>  }</p>
<p>上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。<br> String str = new String();<br> for(int i=0;i&lt;100;i++){<br>   str = str + i;<br> }<br> 在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。</p>
<h3 id="15-StringBuffer与StringBuilder的区别"><a href="#15-StringBuffer与StringBuilder的区别" class="headerlink" title="15.StringBuffer与StringBuilder的区别"></a>15.StringBuffer与StringBuilder的区别</h3><p>StringBuffer和StringBuilder类都表示内容可以被修改的字符串</p>
<p><strong>StringBuilder是线程不安全的，运行效率高</strong>，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。</p>
<p>如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</p>
<h3 id="16-如何把一段逗号分割的字符串转换成一个数组"><a href="#16-如何把一段逗号分割的字符串转换成一个数组" class="headerlink" title="16.如何把一段逗号分割的字符串转换成一个数组?"></a>16.如何把一段逗号分割的字符串转换成一个数组?</h3><p>用正则表达式，代码大概为：==String [] result = orgStr.split(“,”);==</p>
<p>用 StringTokenizer 代码为(麻烦)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String orgStr = <span class="string">"aa,aa,dd,d"</span>;</span><br><span class="line"> StringTokenizer tokener = <span class="keyword">new</span> StringTokenizer(orgStr,<span class="string">","</span>);</span><br><span class="line"> String[] result = <span class="keyword">new</span> String[tokener.countTokens()];</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(tokener.hasMoreElements())&#123;</span><br><span class="line">   result[i++] = tokener.nextToken();</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : result) &#123;</span><br><span class="line">   System.out.println(s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="\61. 为什么要使用克隆？"></a>\61. 为什么要使用克隆？</h3><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>
<h3 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="\62. 如何实现对象克隆？"></a>\62. 如何实现对象克隆？</h3><p>有两种方式：</p>
<p><strong>1). 实现Cloneable接口并重写Object类中的clone()方法；</strong></p>
<p><strong>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，</strong>代码如下：</p>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p>
<h3 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="\63. 深拷贝和浅拷贝区别是什么？"></a>\63. 深拷贝和浅拷贝区别是什么？</h3><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例:assign()）</p>
<p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="12-Collection-和-Collections-有什么区别？"><a href="#12-Collection-和-Collections-有什么区别？" class="headerlink" title="12.Collection 和 Collections 有什么区别？"></a>12.Collection 和 Collections 有什么区别？</h3><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<h3 id="13-List、Set、Map-之间的区别是什么？"><a href="#13-List、Set、Map-之间的区别是什么？" class="headerlink" title="13.List、Set、Map 之间的区别是什么？"></a>13.List、Set、Map 之间的区别是什么？</h3><ol>
<li><p><strong>如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择</strong>。</p>
<p>如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,</p>
<p>如果经常添加删除元素的，那么肯定要选择LinkedList。</p>
<p>如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。</p>
</li>
<li><p><strong>保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类</strong>，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。</p>
</li>
<li><p><strong>如果你以键和值的形式进行数据存储那么 Map 是你正确的选择</strong>。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。</p>
</li>
</ol>
<h3 id="14-java的关键字（keyword）有多少个？"><a href="#14-java的关键字（keyword）有多少个？" class="headerlink" title="14.java的关键字（keyword）有多少个？"></a>14.java的关键字（keyword）有多少个？</h3><blockquote>
<p> <strong>51+2个保留字=53个关键字</strong>       (java的关键字都是小写的！！)</p>
<p>保留字:const goto</p>
</blockquote>
<h3 id="15-HashMap-和-Hashtable-有什么区别？"><a href="#15-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="15.HashMap 和 Hashtable 有什么区别？"></a>15.HashMap 和 Hashtable 有什么区别？</h3><p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</p>
<p><strong>hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。</strong></p>
<p><strong>hashMap允许空键值，而hashTable不允许。</strong></p>
<h3 id="16-如何决定使用-HashMap-还是-TreeMap？"><a href="#16-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="16.如何决定使用 HashMap 还是 TreeMap？"></a>16.如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</p>
<p>假如需要对一个有序的key集合进行遍历，TreeMap是更好的选择。</p>
<h3 id="17-说一下-HashMap-的实现原理？"><a href="#17-说一下-HashMap-的实现原理？" class="headerlink" title="17.说一下 HashMap 的实现原理？"></a>17.说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键,无序</p>
<p><strong>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</strong></p>
<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上<strong>已经存放</strong>了其他元素,那么<strong>在这个位置上</strong>的元素将<strong>以链表的形式存放</strong>,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>
<p><strong>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</strong></p>
<h3 id="18-说一下HashSet-的实现原理？"><a href="#18-说一下HashSet-的实现原理？" class="headerlink" title="18.说一下HashSet 的实现原理？"></a>18.说一下HashSet 的实现原理？</h3><p>HashSet底层由HashMap实现</p>
<p>HashSet的值存放于HashMap的key上</p>
<p>HashMap的value统一为PRESENT</p>
<h3 id="19-ArrayList-和-LinkedList-的区别是什么？"><a href="#19-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="19.ArrayList 和 LinkedList 的区别是什么？"></a>19.ArrayList 和 LinkedList 的区别是什么？</h3><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，</p>
<p>而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。</p>
<p>使用下标访问一个元素，ArrayList 的时间复杂是 O(1)，而 LinkedList 是 O(n)。</p>
<h3 id="20-如何实现数组和-List-之间的转换？"><a href="#20-如何实现数组和-List-之间的转换？" class="headerlink" title="20.如何实现数组和 List 之间的转换？"></a>20.如何实现数组和 List 之间的转换？</h3><p>List转换成为数组：调用ArrayList的toArray方法。</p>
<p>数组转换成为List：调用Arrays的asList方法。</p>
<h3 id="21-ArrayList-和-Vector-的区别是什么？"><a href="#21-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="21.ArrayList 和 Vector 的区别是什么？"></a>21.ArrayList 和 Vector 的区别是什么？</h3><p><strong>Vector是同步的，而ArrayList不是。</strong>然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 </p>
<p><strong>ArrayList比Vector快，它因为有同步，不会过载。</strong></p>
<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<h3 id="22-Array-和-ArrayList-有何区别？"><a href="#22-Array-和-ArrayList-有何区别？" class="headerlink" title="22.Array 和 ArrayList 有何区别？"></a>22.Array 和 ArrayList 有何区别？</h3><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 </p>
<p>Array是指定大小的，而ArrayList大小是固定的。</p>
<p>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>
<h3 id="23-在-Queue-中-poll-和-remove-有什么区别？"><a href="#23-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="23.在 Queue 中 poll()和 remove()有什么区别？"></a>23.在 Queue 中 poll()和 remove()有什么区别？</h3><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h3 id="24-哪些集合类是线程安全的？"><a href="#24-哪些集合类是线程安全的？" class="headerlink" title="24.哪些集合类是线程安全的？"></a>24.哪些集合类是线程安全的？</h3><p><code>vector</code>：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用.</p>
<p><code>enumeration</code>：枚举，相当于迭代器。</p>
<p><code>statck</code>：堆栈类，先进后出。(hashtable的子类)</p>
<p><code>hashtable</code>：就比hashmap多了个线程安全。</p>
<h3 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="\31. 迭代器 Iterator 是什么？"></a>\31. 迭代器 Iterator 是什么？</h3><p>迭代器是一种设计模式，它是一个对象，它可以<strong>遍历</strong>并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p>
<h3 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="\32. Iterator 怎么使用？有什么特点？"></a>\32. Iterator 怎么使用？有什么特点？</h3><p>Java中的Iterator功能比较简单，<strong>并且只能单向移动</strong>：　　</p>
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。　　</p>
<p><strong>(2) 使用next()获得序列中的下一个元素。</strong>　　</p>
<p><strong>(3) 使用hasNext()检查序列中是否还有元素。</strong>　　</p>
<p><strong>(4) 使用remove()将迭代器新返回的元素删除。</strong>　　</p>
<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>
<h3 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="\33. Iterator 和 ListIterator 有什么区别？"></a>\33. Iterator 和 ListIterator 有什么区别？</h3><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 </p>
<p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 </p>
<p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h3 id="8-ArrayList和Vector的区别。"><a href="#8-ArrayList和Vector的区别。" class="headerlink" title="8.ArrayList和Vector的区别。"></a>8.ArrayList和Vector的区别。</h3><p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，数据是允许重复的.</p>
<p>ArrayList与Vector的区别，这主要包括两个方面。</p>
<p>数据增长：</p>
<p>ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次增加多个存储单元，增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。</p>
<p><strong>Vector默认增长为原来两倍</strong>，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为<strong>原来的1.5倍</strong>）。ArrayList与Vector都可以设置初始的空间大小，<strong>Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。</strong></p>
<p>同步性：</p>
<p><strong>Vector是线程安全的，而ArrayList是线程序不安全的</strong></p>
<p>对于Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。</p>
<h3 id="9-能创建-volatile-数组吗？"><a href="#9-能创建-volatile-数组吗？" class="headerlink" title="9.能创建 volatile 数组吗？"></a>9.能创建 volatile 数组吗？</h3><p>可以，但是创建的对象或数组的地址具有可见性，里面的数据是不可见的。</p>
<h3 id="10-去掉一个Vector集合中重复的元素。"><a href="#10-去掉一个Vector集合中重复的元素。" class="headerlink" title="10.去掉一个Vector集合中重复的元素。"></a>10.去掉一个Vector集合中重复的元素。</h3><p>方法一：<strong>HashSet set = new HashSet(vector);</strong></p>
<p>方法二：</p>
<p>Vector newVector = new  Vector();<br> for (int i=0;i&lt;vector.size();i++)<br> {<br> Object obj = vector.get(i);<br>   if(!newVector.contains(obj); //不包含<br>     newVector.add(obj);<br> }</p>
<h3 id="11-说出ArrayList-Vector-LinkedList的存储性能和特性。"><a href="#11-说出ArrayList-Vector-LinkedList的存储性能和特性。" class="headerlink" title="11.说出ArrayList,Vector, LinkedList的存储性能和特性。"></a>11.说出ArrayList,Vector, LinkedList的存储性能和特性。</h3><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>
<p>Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。</p>
<p>而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。</p>
<h3 id="13-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#13-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="13.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?"></a>13.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</h3><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。</p>
<p>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</p>
<p>equals()和==方法决定引用值是否指向同一对象，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<p>14.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?   </p>
<p>对。</p>
<p>如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。</p>
<p>如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的。</p>
<p>例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。</p>
<p>15.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！   </p>
<p>当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的。</p>
<p>实验代码<br> public class Parent implements Comparable {<br>   private int age = 0;<br>   public Parent(int age){<br>     this.age = age;<br>   }<br>   public int compareTo(Object o) {<br>     System.out.println(“method of parent”);<br>     Parent o1 = (Parent)o;<br>     return age&gt;o1.age?1:age&lt;o1.age?-1:0;<br>   }<br> }<br> public class Child extends Parent {<br>   public Child(){<br>     super(3);<br>   }<br>   public int compareTo(Object o) {<br>       System.out.println(“method of child”);<br>       return 1;</p>
<p>}</p>
<p>}<br> public class TreeSetTest {<br>   public static void main(String[] args) {<br>     TreeSet set = new TreeSet();<br>     set.add(new Parent(3));<br>     set.add(new Child());<br>     set.add(new Parent(4));<br>     System.out.println(set.size());<br>   }<br> }</p>
<h3 id="16-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#16-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="16.快速失败(fail-.fast)和安全失败(fail-.safe)的区别是什么？"></a>16.快速失败(fail-.fast)和安全失败(fail-.safe)的区别是什么？</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p>
<p><strong>java.util 包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。</strong></p>
<p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<h3 id="20-HashMap什么时候进行扩容呢？"><a href="#20-HashMap什么时候进行扩容呢？" class="headerlink" title="20.HashMap什么时候进行扩容呢？"></a>20.HashMap什么时候进行扩容呢？</h3><p>HashMap的一些重要的特性是它的容量 (capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<p>​    当HshMap中的<strong>元素个数超过数组大小*</strong>loadFactor时，就会进行数组扩容，<strong>loadFactor的默认值为0.75</strong>， 也就是说，默认情况下，<strong>数组大小为16</strong>，那么当hashmap中元素<strong>个数超过16*0.75=12</strong>的时候，就把数组的大小扩展为2*16=32，即<strong>扩大一倍</strong>，  然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。  </p>
<h3 id="22-CorrentHashMap的工作原理"><a href="#22-CorrentHashMap的工作原理" class="headerlink" title="22.CorrentHashMap的工作原理?"></a>22.CorrentHashMap的工作原理?</h3><p>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p>
<p>HashMap的底层实现，之后会问ConcurrentHashMap的底层实现</p>
<p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。允许使用null值和null键。</p>
<p>ConcurrentHashMap基于双数组和链表的Map接口的同步实现<br> ConcurrentHashMap中元素的key是唯一的、value值可重复<br> ConcurrentHashMap不允许使用null值和null键<br> ConcurrentHashMap是无序的</p>
<h3 id="23-LinkedHashMap的实现原理"><a href="#23-LinkedHashMap的实现原理" class="headerlink" title="23.LinkedHashMap的实现原理?"></a>23.LinkedHashMap的实现原理?</h3><p><strong>LinkedHashMap也是基于HashMap实现的</strong></p>
<p><strong>LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</strong></p>
<h3 id="26-为什么集合类没有实现Cloneable和Serializable接口？"><a href="#26-为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="26.为什么集合类没有实现Cloneable和Serializable接口？"></a>26.为什么集合类没有实现Cloneable和Serializable接口？</h3><p><strong>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。</strong></p>
<p>因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="\35. 并行和并发有什么区别？"></a>\35. 并行和并发有什么区别？</h3><p><strong>并行</strong>是指两个或者多个事件在<strong>同一时刻发生</strong>；而<strong>并发</strong>是指两个或多个事件在<strong>同一时间间隔</strong>发生。</p>
<p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p>
<p>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</p>
<p>所以并发编程的<strong>目标是充分的利用处理器的每一个核，以达到最高的处理性能。</strong></p>
<h3 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="\36. 线程和进程的区别？"></a>\36. 线程和进程的区别？</h3><p>简而言之，进程是程序运行和资源分配的基本单位，<strong>一个程序至少有一个进程，一个进程至少有一个线程。</strong></p>
<p><strong>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源</strong>，减少切换次数，从而效率更高。</p>
<p><strong>线程是进程的一个实体，是cpu调度和分派的基本单位</strong>，是比程序更小的能独立运行的基本单位。</p>
<p>同一进程中的多个线程之间可以并发执行。</p>
<h3 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37.守护线程是什么？"></a>37.守护线程是什么？</h3><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<h3 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="\38. 创建线程有哪几种方式？"></a>\38. 创建线程有哪几种方式？</h3><h4 id="①-继承Thread类创建线程类"><a href="#①-继承Thread类创建线程类" class="headerlink" title="①. 继承Thread类创建线程类"></a>①. 继承Thread类创建线程类</h4><p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</p>
<p>创建Thread子类的实例，即创建了线程对象。</p>
<p>调用线程对象的start()方法来启动该线程。</p>
<h4 id="②-通过Runnable接口创建线程类"><a href="#②-通过Runnable接口创建线程类" class="headerlink" title="②. 通过Runnable接口创建线程类"></a>②. 通过Runnable接口创建线程类</h4><p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p>
<p>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p>
<p>调用线程对象的start()方法来启动该线程。</p>
<h4 id="③-通过Callable和Future创建线程"><a href="#③-通过Callable和Future创建线程" class="headerlink" title="③. 通过Callable和Future创建线程"></a>③. 通过Callable和Future创建线程</h4><p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值</p>
<p>使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p><strong>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</strong></p>
<h3 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="\39. 说一下 runnable 和 callable 有什么区别？"></a>\39. 说一下 runnable 和 callable 有什么区别？</h3><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p>
<p>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<h3 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="\41. sleep() 和 wait() 有什么区别？"></a>\41. sleep() 和 wait() 有什么区别？</h3><p><strong>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程</strong>，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，<strong>线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</strong></p>
<p><strong>wait()：wait()是Object类的方法</strong>，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时<strong>释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</strong></p>
<h3 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="\42. notify()和 notifyAll()有什么区别？"></a>\42. notify()和 notifyAll()有什么区别？</h3><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>
<p>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</p>
<p>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<h3 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="\43. 线程的 run()和 start()有什么区别？"></a>\43. 线程的 run()和 start()有什么区别？</h3><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p><strong>start()方法来启动一个线程，真正实现了多线程运行</strong>。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于<strong>就绪状态</strong>， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p><strong>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的</strong>。 如果<strong>直接调用run(),其实就相当于是调用了一个普通函数</strong>而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h3 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="\44. 创建线程池有哪几种方式？"></a>\44. 创建线程池有哪几种方式？</h3><h4 id="①-newFixedThreadPool-int-nThreads"><a href="#①-newFixedThreadPool-int-nThreads" class="headerlink" title="①. newFixedThreadPool(int nThreads)"></a>①. newFixedThreadPool(int nThreads)</h4><p><strong>创建一个固定长度的线程池</strong>，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<h4 id="②-newCachedThreadPool"><a href="#②-newCachedThreadPool" class="headerlink" title="②. newCachedThreadPool()"></a>②. newCachedThreadPool()</h4><p><strong>创建一个可缓存的线程池</strong>，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<h4 id="③-newSingleThreadExecutor"><a href="#③-newSingleThreadExecutor" class="headerlink" title="③. newSingleThreadExecutor()"></a>③. newSingleThreadExecutor()</h4><p><strong>这是一个单线程的Executor</strong>，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<h4 id="④-newScheduledThreadPool-int-corePoolSize"><a href="#④-newScheduledThreadPool-int-corePoolSize" class="headerlink" title="④. newScheduledThreadPool(int corePoolSize)"></a>④. newScheduledThreadPool(int corePoolSize)</h4><p><strong>创建了一个固定长度的线程池</strong>，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h3 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="\45. 线程池都有哪些状态？"></a>\45. 线程池都有哪些状态？</h3><p>线程池有5种状态：<code>Running</code>、<code>ShutDown</code>、<code>Stop</code>、<code>Tidying</code>、<code>Terminated</code>。</p>
<h3 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="\46. 线程池中 submit()和 execute()方法有什么区别？"></a>\46. 线程池中 submit()和 execute()方法有什么区别？</h3><p>接收的参数不一样</p>
<p>submit有返回值，而execute没有</p>
<p>submit方便Exception处理</p>
<h3 id="47-在-java-程序中怎么保证多线程的运行安全？"><a href="#47-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="\47. 在 java 程序中怎么保证多线程的运行安全？"></a>\47. 在 java 程序中怎么保证多线程的运行安全？</h3><p>线程安全在三个方面体现：</p>
<p><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p>
<p><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</p>
<p><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>
<h3 id="48-多线程锁的升级原理是什么？"><a href="#48-多线程锁的升级原理是什么？" class="headerlink" title="\48. 多线程锁的升级原理是什么？"></a>\48. 多线程锁的升级原理是什么？</h3><p>在Java中，锁共有4种状态，级别从低到高依次为：<strong>无状态锁，偏向锁，轻量级锁和重量级锁</strong>状态，这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>。</p>
<h3 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="\49. 什么是死锁？"></a>\49. 什么是死锁？</h3><p><strong>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称.</p>
<h3 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="\50. 怎么防止死锁？"></a>\50. 怎么防止死锁？</h3><p>死锁的四个必要条件：</p>
<p><strong>互斥条件</strong>：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</p>
<p><strong>请求和保持条件</strong>：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</p>
<p><strong>不可剥夺条件</strong>：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
<p><strong>环路等待条件</strong>：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h3 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="\51. ThreadLocal 是什么？有哪些使用场景？"></a>\51. ThreadLocal 是什么？有哪些使用场景？</h3><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</p>
<p>Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。</p>
<p>但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，J<strong>ava 应用就存在内存泄露的风险。</strong></p>
<h3 id="synchronized-底层实现原理？"><a href="#synchronized-底层实现原理？" class="headerlink" title="synchronized 底层实现原理？"></a>synchronized 底层实现原理？</h3><p><strong>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</strong></p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<p><strong>普通同步方法，锁是当前实例对象</strong></p>
<p><strong>静态同步方法，锁是当前类的class对象</strong></p>
<p>同步方法块，锁是括号里面的对象</p>
<h3 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="\53. synchronized 和 volatile 的区别是什么？"></a>\53. synchronized 和 volatile 的区别是什么？</h3><p><strong>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；</strong></p>
<p><strong>synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</strong></p>
<p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</p>
<p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p>
<p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p>
<p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<h3 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="\54. synchronized 和 Lock 有什么区别？"></a>\54. synchronized 和 Lock 有什么区别？</h3><p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p>
<p>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p>
<p>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，</p>
<p>Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p>
<p>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p>
<p>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</p>
<p><strong>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</strong></p>
<h3 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="\55. synchronized 和 ReentrantLock 区别是什么？"></a>\55. synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized是和if、else、for、while一样的关键字，</p>
<p>ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： </p>
<p>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </p>
<p>ReentrantLock可以获取各种锁的信息</p>
<p><strong>ReentrantLock可以灵活地实现多路通知</strong> </p>
<p>另外，二者的锁机制其实也是不一样的:<strong>ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中markword。</strong></p>
<h3 id="56-atomic-的原理？"><a href="#56-atomic-的原理？" class="headerlink" title="\56. atomic 的原理？"></a>\56. atomic 的原理？</h3><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，<strong>即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</strong></p>
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。</p>
<p>我们需要先知道一个东西就是Unsafe类，全名为：<code>sun.misc.Unsafe</code>，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="\57. 什么是反射？"></a>\57. 什么是反射？</h3><p><strong>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</strong></p>
<p>Java反射：</p>
<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法。对于任意一个对象，能否调用它的任意一个方法</p>
<p>Java反射机制主要提供了以下功能：</p>
<p>在运行时构造任意一个类的对象。</p>
<p>在运行时判断任意一个对象所属的类。</p>
<p>在运行时判断任意一个类所具有的成员变量和方法。</p>
<p>在运行时调用任意一个对象的方法。 </p>
<h3 id="58-什么是-java-序列化？什么情况下需要序列化？"><a href="#58-什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="\58. 什么是 java 序列化？什么情况下需要序列化？"></a>\58. 什么是 java 序列化？什么情况下需要序列化？</h3><p>简单说就是<strong>为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来</strong>。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。<br> 什么情况下需要序列化：</p>
<p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br> b）<strong>当你想用套接字在网络上传送对象的时候；</strong><br> c）当你想通过RMI传输对象的时候；</p>
<h3 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="\59. 动态代理是什么？有哪些应用？"></a>\59. 动态代理是什么？有哪些应用？</h3><p>动态代理：</p>
<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类<strong>创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类</strong>。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>
<p>动态代理的应用：</p>
<p>Spring的AOP, 加事务, 加权限, 加日志</p>
<h3 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="\60. 怎么实现动态代理？"></a>\60. 怎么实现动态代理？</h3><p>首先必须定义一个接口，还要有一个<code>InvocationHandler</code> (将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><p>- 在面向对象设计中，<strong>分工理论就是单一职责原则</strong>(Single Pesponsibility Prineiple, SRP)<br> - 两个含义<br>  - 避免相同的职责分散到不同的类中<br>  - 避免一个类承担太多职责<br> - 为什么要遵循单一设计原则<br>  - 可以减少类之间的耦合：当需求变化时，只修改一个类，从而隔离了变化。<br>  - 提高类的复用性<br>  - 单一职责使得组件可以方便的拆卸和组装<br> - 应用：用工厂模式来实现不同数据库操作类。</p>
<h3 id="2-接口隔离原则："><a href="#2-接口隔离原则：" class="headerlink" title="2.接口隔离原则："></a>2.接口隔离原则：</h3><p>- 接口隔离原则(Interface Segregation Principle, ISP): <strong>客户端不应该被强迫实现不会使用的接口</strong></p>
<p>- 接口隔离原则的主要观点 </p>
<p>- 一个类对另外一个类的依赖性应当是建立在最小的接口上<br> - ISP 可以达到不强迫客户依赖于他们不使用的方法，接口的实现类应该只呈现为单一职责的角色(遵守SRP原则)。<br> - ISP 还可降低客户端之间的相互影响——当某个客户程序要求提供新的职责(需求变更)而迫使接口发生改变时，影响到其他客户程序的可能性会是最小的。<br> - 客户端程序不应该依赖它不需要的接口方法<br> - ISP强调的是接口对客户端的承诺越少越好，并且要做到专一。<br> - 接口污染：过于臃肿的接口设计是对接口的污染。接口污染就是为接口添加不必要的职责，如果开发人员在接口中增加一个新功能的主要目的只是减少接口实现类的数目，则此设计导致接口被不断的“污染” 并 “变胖” </p>
<h3 id="3-开放-封闭原则："><a href="#3-开放-封闭原则：" class="headerlink" title="3.开放 - 封闭原则："></a>3.开放 - 封闭原则：</h3><p> - 开放：模块的行为必须是开放的、支持扩展的，而不是僵化的。<br> - 关闭：在模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。<br> <strong>- 一个模块在扩展性方面应该是开放的，在更改性方面应该是封闭的。</strong><br> - 该原则的<strong>核心是想是对抽象编程，而不是具体编程</strong>，因为抽象相对稳定。<br>  让类依赖于固定的抽象，这样的修改就是封闭的，通过面向对象的继承和多态机制，可以实现对抽象体的继承，<br>  通过覆写其方法改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。<br> - 在设计方面充分应用 抽象 和 封装 的思想。<br> - 在系统功能编程实现方面应用面向接口的编程。</p>
<h3 id="4-替换原则-："><a href="#4-替换原则-：" class="headerlink" title="4.替换原则 ："></a>4.替换原则 ：</h3><p>里氏替换原则(Liskov Substiution Principle, LSP)定义以及主要思想：<strong>子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。</strong><br>    - 父类的方法都要在子类中实现或者重写, 派生类只实现其抽象类中声明的方法, 而不应当给出多余的方法定义或实现。<br>    - 在客户端程序中只应该出现父类对象，而不是直接使用子类对象, 这样可以实现运行期绑定(多态绑定)。</p>
<h3 id="5-依赖倒置原则："><a href="#5-依赖倒置原则：" class="headerlink" title="5.依赖倒置原则："></a>5.依赖倒置原则：</h3><p><strong>依赖倒置的核心原则是解耦，</strong>如果脱离这个最原始的原则，那就是本末倒置。</p>
<p>- 将依赖关系倒置为依赖接口:<br>  - 上层模块不应该依赖下层模块, 它们共同依赖于一个抽象。<br>  - 抽象不能依赖于具体, 具体应该要依赖于抽象<br> - IOC(Inversion of Control) 是依赖倒置原则(Dependence Inversion Principle, DIP)的同义词。<br>  - DI: 依赖注入<br>  - DS: 依赖查找<br> - 如何满足DIP:<br>  - 每个较高层次类都为它所需要的服务提出一个接口声明, 较低层次实现这个接口<br>  - 每个高层类都通过该抽象接口使用服务</p>

      
    </div>

    

    
    
    
	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #fc6423;font-size:16px;">---本文结束<i class="fa fa-heart"></i>感谢您的阅读!---</div>
    
</div>
  
</div>

<div>
     
       
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2020/06/14/问题-Java基础/">问题_Java基础</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 周宏伟 的个人博客">周宏伟</a></p>
  <p><span>发布时间:</span>2020年06月14日 - 11:06</p>
  <p><span>最后更新:</span>2020年06月14日 - 18:06</p>
  <p><span>原始链接:</span><a href="/2020/06/14/问题-Java基础/" title="问题_Java基础">http://oldzhoua.github.io/2020/06/14/问题-Java基础/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://oldzhoua.github.io/2020/06/14/问题-Java基础/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>

     
     </div>



    
      <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="/images/weixin.jpg" alt style="text-align: center;width: 400px;">
  <br>
  <div>欢迎订阅我的公众号,及时推送最新文章！</div>
</div>
<!--微信二维码-->
    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>Donate comment here</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/weixinpay.jpg" alt="周宏伟 微信支付">
        <p>微信支付</p>
      </div>
    

  </div>
</div>

      </div>
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>周宏伟</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://oldzhoua.github.io/2020/06/14/问题-Java基础/" title="问题_Java基础">http://oldzhoua.github.io/2020/06/14/问题-Java基础/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzQuMC9kZWVkLnpo"><i class="fa fa-fw fa-creative-commons"></i>BY</span> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/问题/" rel="tag"># 问题</a>
          
            <a href="/tags/Java基础/" rel="tag"># Java基础</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
              <div>
                

<script src="//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.css">


  


<div class="likely">
	
 	 	<div class="twitter">Tweet</div>
	
 	 	<div class="facebook">Share</div>
	
 	 	<div class="linkedin">Link</div>
	
 	 	<div class="gplus">Plus</div>
	
 	 	<div class="vkontakte">Share</div>
	
 	 	<div class="odnoklassniki">Class</div>
	
 	 	<div class="telegram">Send</div>
	
 	 	<div class="whatsapp">Send</div>
	
 	 	<div class="pinterest">Pin</div>
	
</div>

              </div>
            
            
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/12/Java高级-注解/" rel="next" title="Java高级_注解">
                <i class="fa fa-chevron-left"></i> Java高级_注解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/14/问题-JavaWeb/" rel="prev" title="问题_JavaWeb">
                问题_JavaWeb <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="周宏伟">
            
              <p class="site-author-name" itemprop="name">周宏伟</p>
              <div class="site-description motion-element" itemprop="description">我喜欢的都很贵，所以我才要努力争取</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzQuMC9kZWVkLnpo"><img src="/images/cc-by.svg" alt="Creative Commons"></span>
             </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhvdXhzLnRvcC8yMDE5LzA1LzEyL2hleG8tZ2l0aHViLSVFNiU5MCVBRCVFNSVCQiVCQSVFNSU4RCU5QSVFNSVBRSVBMi8=" title="https://www.zhouxs.top/2019/05/12/hexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">github的文章</span>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#乱七八糟"><span class="nav-number">1.</span> <span class="nav-text">乱七八糟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JDK-和-JRE-有什么区别？"><span class="nav-number">1.1.</span> <span class="nav-text">1.JDK 和 JRE 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><span class="nav-number">1.2.</span> <span class="nav-text">2.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">1.2.1.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode"><span class="nav-number">1.2.2.</span> <span class="nav-text">hashCode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-final-在-java-中有什么作用？"><span class="nav-number">1.3.</span> <span class="nav-text">3.final 在 java 中有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-String-str-”i”与-String-str-new-String-“i”-一样吗？"><span class="nav-number">1.4.</span> <span class="nav-text">4.String str=”i”与 String str=new String(“i”)一样吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-如何将字符串反转？"><span class="nav-number">1.5.</span> <span class="nav-text">5.如何将字符串反转？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-String-类的常用方法都有那些？"><span class="nav-number">1.6.</span> <span class="nav-text">6.String 类的常用方法都有那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-抽象类必须要有抽象方法吗？"><span class="nav-number">1.7.</span> <span class="nav-text">7.抽象类必须要有抽象方法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-普通类和抽象类有哪些区别？"><span class="nav-number">1.8.</span> <span class="nav-text">8.普通类和抽象类有哪些区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-java-中-IO-流分为几种？"><span class="nav-number">1.9.</span> <span class="nav-text">9.java 中 IO 流分为几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-BIO、NIO、AIO-有什么区别？"><span class="nav-number">1.10.</span> <span class="nav-text">10.BIO、NIO、AIO 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Files的常用方法都有哪些？"><span class="nav-number">1.11.</span> <span class="nav-text">11.Files的常用方法都有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6）wait和sleep的区别，必须理解"><span class="nav-number">1.12.</span> <span class="nav-text">6）wait和sleep的区别，必须理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7）JVM的内存结构，JVM的算法"><span class="nav-number">1.13.</span> <span class="nav-text">7）JVM的内存结构，JVM的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15）说说http-https协议"><span class="nav-number">1.14.</span> <span class="nav-text">15）说说http,https协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16）osi五层网络协议"><span class="nav-number">1.15.</span> <span class="nav-text">16）osi五层网络协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18）说说tcp三次握手，四次挥手"><span class="nav-number">1.16.</span> <span class="nav-text">18）说说tcp三次握手，四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21）请写一段栈溢出、堆溢出的代码"><span class="nav-number">1.16.1.</span> <span class="nav-text">21）请写一段栈溢出、堆溢出的代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-说出一些常用的类，包，接口，请各举5个。"><span class="nav-number">1.17.</span> <span class="nav-text">29.说出一些常用的类，包，接口，请各举5个。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-描述一下JVM加载class文件的原理机制"><span class="nav-number">1.18.</span> <span class="nav-text">33.描述一下JVM加载class文件的原理机制?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？"><span class="nav-number">1.19.</span> <span class="nav-text">35.堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-GC是什么-为什么要有GC"><span class="nav-number">1.20.</span> <span class="nav-text">36.GC是什么? 为什么要有GC?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><span class="nav-number">1.21.</span> <span class="nav-text">38.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-什么时候用assert？"><span class="nav-number">1.22.</span> <span class="nav-text">39.什么时候用assert？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-java中会存在内存泄漏吗，请简单描述。"><span class="nav-number">1.23.</span> <span class="nav-text">40.java中会存在内存泄漏吗，请简单描述。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-能不能自己写个类，也叫java-lang-String？"><span class="nav-number">1.24.</span> <span class="nav-text">41.能不能自己写个类，也叫java.lang.String？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#194-说一下-jvm-的主要组成部分？及其作用？"><span class="nav-number">1.25.</span> <span class="nav-text">194.说一下 jvm 的主要组成部分？及其作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#197-队列和栈是什么？有什么区别？"><span class="nav-number">1.26.</span> <span class="nav-text">197.队列和栈是什么？有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-什么是双亲委派模型？"><span class="nav-number">1.27.</span> <span class="nav-text">198.什么是双亲委派模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#199-说一下类加载的执行过程？"><span class="nav-number">1.28.</span> <span class="nav-text">\199. 说一下类加载的执行过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-怎么判断对象是否可以被回收？"><span class="nav-number">1.29.</span> <span class="nav-text">200.怎么判断对象是否可以被回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#201-java-中都有哪些引用类型？"><span class="nav-number">1.30.</span> <span class="nav-text">\201. java 中都有哪些引用类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#202-说一下-jvm-有哪些垃圾回收算法？"><span class="nav-number">1.31.</span> <span class="nav-text">\202. 说一下 jvm 有哪些垃圾回收算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#203-说一下-jvm-有哪些垃圾回收器？"><span class="nav-number">1.32.</span> <span class="nav-text">203.说一下 jvm 有哪些垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#204-详细介绍一下-CMS-垃圾回收器？"><span class="nav-number">1.33.</span> <span class="nav-text">204.详细介绍一下 CMS 垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><span class="nav-number">1.34.</span> <span class="nav-text">205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-简述分代垃圾回收器是怎么工作的？"><span class="nav-number">1.35.</span> <span class="nav-text">\206. 简述分代垃圾回收器是怎么工作的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-说一下-jvm-调优的工具？"><span class="nav-number">1.36.</span> <span class="nav-text">207.说一下 jvm 调优的工具？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-你所知道网络协议有那些？"><span class="nav-number">1.37.</span> <span class="nav-text">2.你所知道网络协议有那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Java都有那些开发平台？"><span class="nav-number">1.38.</span> <span class="nav-text">3.Java都有那些开发平台？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Java的数据结构有那些？"><span class="nav-number">1.39.</span> <span class="nav-text">8.Java的数据结构有那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-什么是OOP"><span class="nav-number">1.40.</span> <span class="nav-text">9.什么是OOP?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-什么是面向对象？"><span class="nav-number">1.41.</span> <span class="nav-text">10.什么是面向对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-类与对象的关系"><span class="nav-number">1.42.</span> <span class="nav-text">11.类与对象的关系?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Java中有几种数据类型"><span class="nav-number">1.43.</span> <span class="nav-text">12.Java中有几种数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-什么是隐式转换，什么是显式转换"><span class="nav-number">1.44.</span> <span class="nav-text">13.什么是隐式转换，什么是显式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型"><span class="nav-number">1.45.</span> <span class="nav-text">14.Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-什么是拆装箱？"><span class="nav-number">1.46.</span> <span class="nav-text">15.什么是拆装箱？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Java中的包装类都是那些？"><span class="nav-number">1.47.</span> <span class="nav-text">16.Java中的包装类都是那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-一个java类中包含那些内容？"><span class="nav-number">1.48.</span> <span class="nav-text">17.一个java类中包含那些内容？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-例如：-if-a-1-0-4-0-，这样做好吗？"><span class="nav-number">1.49.</span> <span class="nav-text">18.例如： if(a+1.0=4.0)，这样做好吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-那针对浮点型数据运算出现的误差的问题，你怎么解决？"><span class="nav-number">1.50.</span> <span class="nav-text">19.那针对浮点型数据运算出现的误差的问题，你怎么解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-i与i-的区别"><span class="nav-number">1.51.</span> <span class="nav-text">20.++i与i++的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-程序的结构有那些？"><span class="nav-number">1.52.</span> <span class="nav-text">21.程序的结构有那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-数组实例化有几种方式？"><span class="nav-number">1.53.</span> <span class="nav-text">22.数组实例化有几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-Java中各种数据默认值"><span class="nav-number">1.54.</span> <span class="nav-text">23.Java中各种数据默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-java中是值传递引用传递？"><span class="nav-number">1.55.</span> <span class="nav-text">28.java中是值传递引用传递？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？"><span class="nav-number">1.56.</span> <span class="nav-text">29.假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-实例化数组后，能不能改变数组长度呢？"><span class="nav-number">1.57.</span> <span class="nav-text">30.实例化数组后，能不能改变数组长度呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-假设数组内有5个元素，如果对数组进行反序，该如何做？"><span class="nav-number">1.58.</span> <span class="nav-text">31.假设数组内有5个元素，如果对数组进行反序，该如何做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-形参与实参"><span class="nav-number">1.59.</span> <span class="nav-text">32.形参与实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-构造方法能不能显式调用？"><span class="nav-number">1.60.</span> <span class="nav-text">33.构造方法能不能显式调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-内部类与静态内部类的区别？"><span class="nav-number">1.61.</span> <span class="nav-text">36.内部类与静态内部类的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-Static关键字有什么作用？"><span class="nav-number">1.62.</span> <span class="nav-text">37.Static关键字有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-Final在java中的作用"><span class="nav-number">1.63.</span> <span class="nav-text">38.Final在java中的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Java中操作字符串使用哪个类？"><span class="nav-number">1.64.</span> <span class="nav-text">39.Java中操作字符串使用哪个类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-String-str-”aa”-String-s-”bb”-String-aa-aa-s-一种创建了几个对象？"><span class="nav-number">1.65.</span> <span class="nav-text">42.String str=”aa”,String s=”bb”,String aa=aa+s;一种创建了几个对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-将下java中的math类有那些常用方法？"><span class="nav-number">1.66.</span> <span class="nav-text">43.将下java中的math类有那些常用方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-与equlas有什么区别？"><span class="nav-number">1.67.</span> <span class="nav-text">46.==与equlas有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-创建一个子类对象的时候，那么父类的构造方法会执行吗？"><span class="nav-number">1.68.</span> <span class="nav-text">53.创建一个子类对象的时候，那么父类的构造方法会执行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-什么是父类引用指向子类对象？"><span class="nav-number">1.69.</span> <span class="nav-text">54.什么是父类引用指向子类对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-抽象类可以使用final修饰吗？"><span class="nav-number">1.70.</span> <span class="nav-text">60.抽象类可以使用final修饰吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-接口有什么特点？"><span class="nav-number">1.71.</span> <span class="nav-text">64.接口有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-异常的处理机制有几种？"><span class="nav-number">1.72.</span> <span class="nav-text">68.异常的处理机制有几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-如何自定义一个异常"><span class="nav-number">1.73.</span> <span class="nav-text">69.如何自定义一个异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-在异常捕捉时，如果发生异常，那么try-catch-finally块外的return语句会执行吗？"><span class="nav-number">1.74.</span> <span class="nav-text">70.在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-Thow与thorws区别"><span class="nav-number">1.75.</span> <span class="nav-text">72.Thow与thorws区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-使用Log4j对程序有影响吗？"><span class="nav-number">1.76.</span> <span class="nav-text">74.使用Log4j对程序有影响吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-Log4j日志有几个级别？"><span class="nav-number">1.77.</span> <span class="nav-text">75.Log4j日志有几个级别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-Java反射创建对象效率高还是通过new创建对象的效率高？"><span class="nav-number">1.78.</span> <span class="nav-text">77.Java反射创建对象效率高还是通过new创建对象的效率高？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85-JDBC操作的步骤"><span class="nav-number">1.79.</span> <span class="nav-text">85.JDBC操作的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-在使用jdbc的时候，如何防止出现sql注入的问题。"><span class="nav-number">1.80.</span> <span class="nav-text">86.在使用jdbc的时候，如何防止出现sql注入的问题。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#87-怎么在JDBC内调用一个存储过程"><span class="nav-number">1.81.</span> <span class="nav-text">87.怎么在JDBC内调用一个存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-是否了解连接池，使用连接池有什么好处？"><span class="nav-number">1.82.</span> <span class="nav-text">88.是否了解连接池，使用连接池有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89-你所了解的数据源技术有那些？使用数据源有什么好处？"><span class="nav-number">1.83.</span> <span class="nav-text">89.你所了解的数据源技术有那些？使用数据源有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91-常用io类有那些？"><span class="nav-number">1.84.</span> <span class="nav-text">91.常用io类有那些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-字节流与字符流的区别"><span class="nav-number">1.85.</span> <span class="nav-text">92.字节流与字符流的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-final、finalize-、finally"><span class="nav-number">1.86.</span> <span class="nav-text">93.final、finalize()、finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#99-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><span class="nav-number">1.87.</span> <span class="nav-text">99.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、什么是-ThreadLocal？ThreadLocal-和-Synchonized-的区别？"><span class="nav-number">1.88.</span> <span class="nav-text">10、什么是 ThreadLocal？ThreadLocal 和 Synchonized 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-值传递和引用传递："><span class="nav-number">1.89.</span> <span class="nav-text">7.值传递和引用传递：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-java内存分配"><span class="nav-number">1.90.</span> <span class="nav-text">9.java内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><span class="nav-number">1.91.</span> <span class="nav-text">11.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-char型变量中能不能存贮一个中文汉字-为什么"><span class="nav-number">1.92.</span> <span class="nav-text">17.char型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-用最有效率的方法算出2乘以8等於几"><span class="nav-number">1.93.</span> <span class="nav-text">18.用最有效率的方法算出2乘以8等於几?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><span class="nav-number">1.94.</span> <span class="nav-text">19.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-java-中对象的创建方法有几种？"><span class="nav-number">1.95.</span> <span class="nav-text">20.java 中对象的创建方法有几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-静态变量和实例变量的区别？"><span class="nav-number">1.96.</span> <span class="nav-text">22.静态变量和实例变量的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-是否可以从一个static方法内部发出对非static方法的调用？"><span class="nav-number">1.97.</span> <span class="nav-text">23.是否可以从一个static方法内部发出对非static方法的调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-Integer与int的区别"><span class="nav-number">1.98.</span> <span class="nav-text">24.Integer与int的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Math-round-11-5-等於多少-Math-round-11-5-等於多少"><span class="nav-number">1.99.</span> <span class="nav-text">25.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-Overload和Override的区别。Overload的方法是否可以改变返回值的类型"><span class="nav-number">1.100.</span> <span class="nav-text">28.Overload和Override的区别。Overload的方法是否可以改变返回值的类型?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-序列化接口的id有什么用？"><span class="nav-number">1.101.</span> <span class="nav-text">31.序列化接口的id有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-hashCode方法的作用？"><span class="nav-number">1.102.</span> <span class="nav-text">32.hashCode方法的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-构造器Constructor是否可被override"><span class="nav-number">1.103.</span> <span class="nav-text">33.构造器Constructor是否可被override?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-final-finally-finalize的区别。"><span class="nav-number">1.104.</span> <span class="nav-text">6.final, finally, finalize的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Throwable：异常的父类。"><span class="nav-number">1.105.</span> <span class="nav-text">10.Throwable：异常的父类。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-请写出你最常见到的5个runtime-exception。"><span class="nav-number">1.106.</span> <span class="nav-text">11.请写出你最常见到的5个runtime exception。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Java语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><span class="nav-number">1.107.</span> <span class="nav-text">12.Java语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-同步有几种实现方法"><span class="nav-number">1.108.</span> <span class="nav-text">16.同步有几种实现方法?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><span class="nav-number">1.109.</span> <span class="nav-text">17.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-简述synchronized和java-util-concurrent-locks-Lock的异同？"><span class="nav-number">1.110.</span> <span class="nav-text">19.简述synchronized和java.util.concurrent.locks.Lock的异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-写clone-方法时，通常都有一行代码，是什么"><span class="nav-number">1.111.</span> <span class="nav-text">1.写clone()方法时，通常都有一行代码，是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-面向对象的特征有哪些方面"><span class="nav-number">1.112.</span> <span class="nav-text">2.面向对象的特征有哪些方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-java中实现多态的机制是什么？"><span class="nav-number">1.113.</span> <span class="nav-text">2.java中实现多态的机制是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-abstract-class和interface有什么区别"><span class="nav-number">1.114.</span> <span class="nav-text">3.abstract class和interface有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized"><span class="nav-number">1.115.</span> <span class="nav-text">4.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-是否可以继承String类"><span class="nav-number">1.116.</span> <span class="nav-text">12.是否可以继承String类?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？"><span class="nav-number">1.117.</span> <span class="nav-text">13.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-String-和StringBuffer的区别"><span class="nav-number">1.118.</span> <span class="nav-text">14.String 和StringBuffer的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-StringBuffer与StringBuilder的区别"><span class="nav-number">1.119.</span> <span class="nav-text">15.StringBuffer与StringBuilder的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-如何把一段逗号分割的字符串转换成一个数组"><span class="nav-number">1.120.</span> <span class="nav-text">16.如何把一段逗号分割的字符串转换成一个数组?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-为什么要使用克隆？"><span class="nav-number">1.121.</span> <span class="nav-text">\61. 为什么要使用克隆？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-如何实现对象克隆？"><span class="nav-number">1.122.</span> <span class="nav-text">\62. 如何实现对象克隆？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-深拷贝和浅拷贝区别是什么？"><span class="nav-number">1.123.</span> <span class="nav-text">\63. 深拷贝和浅拷贝区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">2.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Collection-和-Collections-有什么区别？"><span class="nav-number">2.1.</span> <span class="nav-text">12.Collection 和 Collections 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-List、Set、Map-之间的区别是什么？"><span class="nav-number">2.2.</span> <span class="nav-text">13.List、Set、Map 之间的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-java的关键字（keyword）有多少个？"><span class="nav-number">2.3.</span> <span class="nav-text">14.java的关键字（keyword）有多少个？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-HashMap-和-Hashtable-有什么区别？"><span class="nav-number">2.4.</span> <span class="nav-text">15.HashMap 和 Hashtable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-如何决定使用-HashMap-还是-TreeMap？"><span class="nav-number">2.5.</span> <span class="nav-text">16.如何决定使用 HashMap 还是 TreeMap？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-说一下-HashMap-的实现原理？"><span class="nav-number">2.6.</span> <span class="nav-text">17.说一下 HashMap 的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-说一下HashSet-的实现原理？"><span class="nav-number">2.7.</span> <span class="nav-text">18.说一下HashSet 的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-ArrayList-和-LinkedList-的区别是什么？"><span class="nav-number">2.8.</span> <span class="nav-text">19.ArrayList 和 LinkedList 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-如何实现数组和-List-之间的转换？"><span class="nav-number">2.9.</span> <span class="nav-text">20.如何实现数组和 List 之间的转换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-ArrayList-和-Vector-的区别是什么？"><span class="nav-number">2.10.</span> <span class="nav-text">21.ArrayList 和 Vector 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Array-和-ArrayList-有何区别？"><span class="nav-number">2.11.</span> <span class="nav-text">22.Array 和 ArrayList 有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-在-Queue-中-poll-和-remove-有什么区别？"><span class="nav-number">2.12.</span> <span class="nav-text">23.在 Queue 中 poll()和 remove()有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-哪些集合类是线程安全的？"><span class="nav-number">2.13.</span> <span class="nav-text">24.哪些集合类是线程安全的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-迭代器-Iterator-是什么？"><span class="nav-number">2.14.</span> <span class="nav-text">\31. 迭代器 Iterator 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-Iterator-怎么使用？有什么特点？"><span class="nav-number">2.15.</span> <span class="nav-text">\32. Iterator 怎么使用？有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-Iterator-和-ListIterator-有什么区别？"><span class="nav-number">2.16.</span> <span class="nav-text">\33. Iterator 和 ListIterator 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-ArrayList和Vector的区别。"><span class="nav-number">2.17.</span> <span class="nav-text">8.ArrayList和Vector的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-能创建-volatile-数组吗？"><span class="nav-number">2.18.</span> <span class="nav-text">9.能创建 volatile 数组吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-去掉一个Vector集合中重复的元素。"><span class="nav-number">2.19.</span> <span class="nav-text">10.去掉一个Vector集合中重复的元素。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-说出ArrayList-Vector-LinkedList的存储性能和特性。"><span class="nav-number">2.20.</span> <span class="nav-text">11.说出ArrayList,Vector, LinkedList的存储性能和特性。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><span class="nav-number">2.21.</span> <span class="nav-text">13.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><span class="nav-number">2.22.</span> <span class="nav-text">16.快速失败(fail-.fast)和安全失败(fail-.safe)的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-HashMap什么时候进行扩容呢？"><span class="nav-number">2.23.</span> <span class="nav-text">20.HashMap什么时候进行扩容呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-CorrentHashMap的工作原理"><span class="nav-number">2.24.</span> <span class="nav-text">22.CorrentHashMap的工作原理?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-LinkedHashMap的实现原理"><span class="nav-number">2.25.</span> <span class="nav-text">23.LinkedHashMap的实现原理?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-为什么集合类没有实现Cloneable和Serializable接口？"><span class="nav-number">2.26.</span> <span class="nav-text">26.为什么集合类没有实现Cloneable和Serializable接口？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#35-并行和并发有什么区别？"><span class="nav-number">3.1.</span> <span class="nav-text">\35. 并行和并发有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-线程和进程的区别？"><span class="nav-number">3.2.</span> <span class="nav-text">\36. 线程和进程的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-守护线程是什么？"><span class="nav-number">3.3.</span> <span class="nav-text">37.守护线程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-创建线程有哪几种方式？"><span class="nav-number">3.4.</span> <span class="nav-text">\38. 创建线程有哪几种方式？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#①-继承Thread类创建线程类"><span class="nav-number">3.4.1.</span> <span class="nav-text">①. 继承Thread类创建线程类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#②-通过Runnable接口创建线程类"><span class="nav-number">3.4.2.</span> <span class="nav-text">②. 通过Runnable接口创建线程类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#③-通过Callable和Future创建线程"><span class="nav-number">3.4.3.</span> <span class="nav-text">③. 通过Callable和Future创建线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-说一下-runnable-和-callable-有什么区别？"><span class="nav-number">3.5.</span> <span class="nav-text">\39. 说一下 runnable 和 callable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-sleep-和-wait-有什么区别？"><span class="nav-number">3.6.</span> <span class="nav-text">\41. sleep() 和 wait() 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-notify-和-notifyAll-有什么区别？"><span class="nav-number">3.7.</span> <span class="nav-text">\42. notify()和 notifyAll()有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-线程的-run-和-start-有什么区别？"><span class="nav-number">3.8.</span> <span class="nav-text">\43. 线程的 run()和 start()有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-创建线程池有哪几种方式？"><span class="nav-number">3.9.</span> <span class="nav-text">\44. 创建线程池有哪几种方式？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#①-newFixedThreadPool-int-nThreads"><span class="nav-number">3.9.1.</span> <span class="nav-text">①. newFixedThreadPool(int nThreads)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#②-newCachedThreadPool"><span class="nav-number">3.9.2.</span> <span class="nav-text">②. newCachedThreadPool()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#③-newSingleThreadExecutor"><span class="nav-number">3.9.3.</span> <span class="nav-text">③. newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#④-newScheduledThreadPool-int-corePoolSize"><span class="nav-number">3.9.4.</span> <span class="nav-text">④. newScheduledThreadPool(int corePoolSize)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-线程池都有哪些状态？"><span class="nav-number">3.10.</span> <span class="nav-text">\45. 线程池都有哪些状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-线程池中-submit-和-execute-方法有什么区别？"><span class="nav-number">3.11.</span> <span class="nav-text">\46. 线程池中 submit()和 execute()方法有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-在-java-程序中怎么保证多线程的运行安全？"><span class="nav-number">3.12.</span> <span class="nav-text">\47. 在 java 程序中怎么保证多线程的运行安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-多线程锁的升级原理是什么？"><span class="nav-number">3.13.</span> <span class="nav-text">\48. 多线程锁的升级原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-什么是死锁？"><span class="nav-number">3.14.</span> <span class="nav-text">\49. 什么是死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-怎么防止死锁？"><span class="nav-number">3.15.</span> <span class="nav-text">\50. 怎么防止死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-ThreadLocal-是什么？有哪些使用场景？"><span class="nav-number">3.16.</span> <span class="nav-text">\51. ThreadLocal 是什么？有哪些使用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-底层实现原理？"><span class="nav-number">3.17.</span> <span class="nav-text">synchronized 底层实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-synchronized-和-volatile-的区别是什么？"><span class="nav-number">3.18.</span> <span class="nav-text">\53. synchronized 和 volatile 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-synchronized-和-Lock-有什么区别？"><span class="nav-number">3.19.</span> <span class="nav-text">\54. synchronized 和 Lock 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-synchronized-和-ReentrantLock-区别是什么？"><span class="nav-number">3.20.</span> <span class="nav-text">\55. synchronized 和 ReentrantLock 区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-atomic-的原理？"><span class="nav-number">3.21.</span> <span class="nav-text">\56. atomic 的原理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">4.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#57-什么是反射？"><span class="nav-number">4.1.</span> <span class="nav-text">\57. 什么是反射？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-什么是-java-序列化？什么情况下需要序列化？"><span class="nav-number">4.2.</span> <span class="nav-text">\58. 什么是 java 序列化？什么情况下需要序列化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-动态代理是什么？有哪些应用？"><span class="nav-number">4.3.</span> <span class="nav-text">\59. 动态代理是什么？有哪些应用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-怎么实现动态代理？"><span class="nav-number">4.4.</span> <span class="nav-text">\60. 怎么实现动态代理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象设计原则"><span class="nav-number">5.</span> <span class="nav-text">面向对象设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-单一职责原则"><span class="nav-number">5.1.</span> <span class="nav-text">1.单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-接口隔离原则："><span class="nav-number">5.2.</span> <span class="nav-text">2.接口隔离原则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-开放-封闭原则："><span class="nav-number">5.3.</span> <span class="nav-text">3.开放 - 封闭原则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-替换原则-："><span class="nav-number">5.4.</span> <span class="nav-text">4.替换原则 ：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-依赖倒置原则："><span class="nav-number">5.5.</span> <span class="nav-text">5.依赖倒置原则：</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周宏伟</span>
  
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">151k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">2:17</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  



  
    
    
      
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js"></script>











  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/jquery_lazyload@1.9.3/jquery.lazyload.min.js"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="//cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/js/jquery.fancybox.pack.js"></script>

  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1.1/reading_progress.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  
  <script src="/js/js.cookie.js?v=7.1.0"></script>
  <script src="/js/scroll-cookie.js?v=7.1.0"></script>


  
  <script src="/js/exturl.js?v=7.1.0"></script>


  
  
  
    
  

  

  
  
  


  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  
  
  
    
  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1.0.0/bookmark.min.js"></script>
  <script>
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
